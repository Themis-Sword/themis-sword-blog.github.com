<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: python | Themis_Sword's Blog]]></title>
  <link href="http://www.aprilzephyr.com/blog/categories/python/atom.xml" rel="self"/>
  <link href="http://www.aprilzephyr.com/"/>
  <updated>2015-06-26T15:34:27+08:00</updated>
  <id>http://www.aprilzephyr.com/</id>
  <author>
    <name><![CDATA[Themis_Sword]]></name>
    <email><![CDATA[licong0419@outlook.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Nifty Python tricks(FW)]]></title>
    <link href="http://www.aprilzephyr.com/blog/05292015/nifty-python-tricks-fw/"/>
    <updated>2015-05-29T10:12:24+08:00</updated>
    <id>http://www.aprilzephyr.com/blog/05292015/nifty-python-tricks-fw</id>
    <content type="html"><![CDATA[<p>Hi there folks. It’s been a long time since I last published a post. I have been busy. However in this post I am going to share some really informative tips and tricks which you might not have known about. So without wasting any time lets get straight to them:</p>

<h4>Enumerate</h4>

<p>Instead of doing:</p>

<pre><code>i = 0 
for item in iterable: 
    print i, item 
    i += 1
</code></pre>

<p>We can do:</p>

<pre><code>for i, item in enumerate(iterable):
    print i, item
</code></pre>

<p>Enumerate can also take a second argument. Here is an example:</p>

<pre><code>&gt;&gt;&gt; list(enumerate('abc')) 
[(0, 'a'), (1, 'b'), (2, 'c')] 

&gt;&gt;&gt; list(enumerate('abc', 1)) 
[(1, 'a'), (2, 'b'), (3, 'c')]
</code></pre>

<!--more-->


<h4>Dict/Set comprehensions</h4>

<p>You might know about list comprehensions but you might not be aware of dict/set comprehensions. They are simple to use and just as effective. Here is an example:</p>

<pre><code>my_dict = {i: i * i for i in xrange(100)} 
my_set = {i * 15 for i in xrange(100)}

# There is only a difference of ':' in both
</code></pre>

<h4>Forcing float division:</h4>

<p>If we divide whole numbers Python gives us the result as a whole number even if the result was a float. In order to circumvent this issue we have to do something like this:</p>

<pre><code>result = 1.0/2
</code></pre>

<p>But there is another way to solve this problem which even I wasn’t aware of. You can do:</p>

<pre><code>from __future__ import division 
result = 1/2
# print(result)
# 0.5
</code></pre>

<p>Voila! Now you don’t need to append .0 in order to get an accurate answer. Do note that this trick is for Python 2 only. In Python 3 there is no need to do the import as it handles this case by default.</p>

<h4>Simple Server</h4>

<p>Do you want to quickly and easily share files from a directory? You can simply do:</p>

<pre><code># Python2
python -m SimpleHTTPServer

# Python 3
python3 -m http.server
</code></pre>

<p>This would start up a server.</p>

<h4>Evaluating Python expressions</h4>

<p>We all know about eval but do we all know about literal_eval? Perhaps not. You can do:</p>

<pre><code>import ast 
my_list = ast.literal_eval(expr)
</code></pre>

<p>Instead of:</p>

<pre><code>expr = "[1, 2, 3]" 
my_list = eval(expr)
</code></pre>

<p>I am sure that it’s something new for most of us but it has been a part of Python for a long time.</p>

<h4>Profiling a script</h4>

<p>You can easily profile a script by running it like this:</p>

<pre><code>python -m cProfile my_script.py
</code></pre>

<h4>Object introspection</h4>

<p>You can inspect objects in Python by using dir(). Here is a simple example:</p>

<pre><code>&gt;&gt;&gt; foo = [1, 2, 3, 4]
&gt;&gt;&gt; dir(foo) 
['__add__', '__class__', '__contains__', 
'__delattr__', '__delitem__', '__delslice__', ... , 
'extend', 'index', 'insert', 'pop', 'remove', 
'reverse', 'sort']
</code></pre>

<h4>Debugging scripts</h4>

<p>You can easily set breakpoints in your script using the pdb module. Here is an example:</p>

<pre><code>import pdb
pdb.set_trace()
</code></pre>

<p>You can write pdb.set_trace() anywhere in your script and it will set a breakpoint there. Super convenient. You should also read more about <a href="https://docs.python.org/3/library/pdb.html">pdb</a> as it has a couple of other hidden gems as well.</p>

<h4>Simplify if constructs</h4>

<p>If you have to check for several values you can easily do:</p>

<pre><code>if n in [1,4,5,6]:
</code></pre>

<p>instead of:</p>

<pre><code>if n==1 or n==4 or n==5 or n==6:
</code></pre>

<h4>Reversing a list/string</h4>

<p>You can quickly reverse a list by using:</p>

<pre><code>&gt;&gt;&gt; a = [1,2,3,4]
&gt;&gt;&gt; a[::-1]
[4, 3, 2, 1]

# This creates a new reversed list. 
# If you want to reverse a list in place you can do:

a.reverse()
</code></pre>

<p>and the same can be applied to a string as well:</p>

<pre><code>&gt;&gt;&gt; foo = "yasoob"
&gt;&gt;&gt; foo[::-1]
'boosay'
</code></pre>

<h4>Pretty print</h4>

<p>You can print dicts and lists in a beautiful way by doing:</p>

<pre><code>from pprint import pprint 
pprint(my_dict)
</code></pre>

<p>This is more effective on dicts. Moreover, if you want to pretty print json quickly from a file then you can simply do:</p>

<pre><code>cat file.json | python -m json.tools
</code></pre>

<h4>Ternary Operators</h4>

<p>Ternary operators are shortcut for an if-else statement, and are also known as a conditional operators. Here are some examples which you can use to make your code compact and more beautiful.</p>

<pre><code>[on_true] if [expression] else [on_false]
x, y = 50, 25
small = x if x &lt; y else y
</code></pre>

<p>Thats all for today! I hope you enjoyed this article and picked up a trick or two along the way. See you in the next article. Make sure that you follow us on <a href="https://www.facebook.com/freepythontips">Facebook</a> and <a href="https://twitter.com/yasoobkhalid">Twitter</a>!</p>

<p>Do you have any comments or suggestions? You can write a comment or email me on <a href="&#x6d;&#x61;&#105;&#108;&#116;&#111;&#x3a;&#121;&#97;&#x73;&#x6f;&#x6f;&#98;&#46;&#x6b;&#104;&#x6c;&#100;&#x40;&#103;&#109;&#x61;&#105;&#x6c;&#46;&#99;&#x6f;&#109;">&#121;&#x61;&#x73;&#x6f;&#111;&#98;&#46;&#107;&#104;&#x6c;&#100;&#64;&#103;&#x6d;&#x61;&#x69;&#x6c;&#x2e;&#x63;&#x6f;&#x6d;</a></p>

<p><a href="http://pythontips.com/2015/04/19/nifty-python-tricks/">Origin</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Python Tools for Machine Learning(FW)]]></title>
    <link href="http://www.aprilzephyr.com/blog/05142015/python-tools-for-machine-learning-fw/"/>
    <updated>2015-05-14T11:15:31+08:00</updated>
    <id>http://www.aprilzephyr.com/blog/05142015/python-tools-for-machine-learning-fw</id>
    <content type="html"><![CDATA[<p>Python is one of the best programming languages out there, with an extensive coverage in scientific computing: computer vision, artificial intelligence, mathematics, astronomy to name a few. Unsurprisingly, this holds true for machine learning as well.</p>

<p>Of course, it has some disadvantages too; one of which is that the tools and libraries for Python are scattered. If you are a unix-minded person, this works quite conveniently as every tool does one thing and does it well. However, this also requires you to know different libraries and tools, including their advantages and disadvantages, to be able to make a sound decision for the systems that you are building. Tools by themselves do not make a system or product better, but with the right tools we can work much more efficiently and be more productive. Therefore, knowing the right tools for your work domain is crucially important.<!--more--></p>

<p>This post aims to list and describe the most useful machine learning tools and libraries that are available for Python. To make this list, we did not require the library to be written in Python; it was sufficient for it to have a Python interface. We also have a small section on Deep Learning at the end as it has received a fair amount of attention recently.</p>

<p>We do not aim to list <strong>all</strong> the machine learning libraries available in Python (the Python package index returns 139 results for “machine learning”) but rather the ones that we found useful and well-maintained to the best of our knowledge. Moreover, although some of modules could be used for various machine learning tasks, we included libraries whose main focus is machine learning. For example, although <a href="http://docs.scipy.org/doc/scipy/reference/index.html">Scipy</a> has some <a href="http://docs.scipy.org/doc/scipy/reference/cluster.vq.html#module-scipy.cluster.vq">clustering algorithms</a>, the main focus of this module is not machine learning but rather in being a comprehensive set of tools for scientific computing. Therefore, we excluded libraries like Scipy from our list (though we use it too!).</p>

<p>Another thing worth mentioning is that we also evaluated the library based on how it integrates with other scientific computing libraries because machine learning (either supervised or unsupervised) is part of a data processing system. If the library that you are using does not fit with your rest of data processing system, then you may find yourself spending a tremendous amount of time to creating intermediate layers between different libraries. It is important to have a great library in your toolset but it is also important for that library to integrate well with other libraries.</p>

<p>If you are great in another language but want to use Python packages, we also briefly go into how you could integrate with Python to use the libraries listed in the post.</p>

<h3>Scikit-Learn</h3>

<p><a href="http://scikit-learn.org/stable/">Scikit Learn</a> is our machine learning tool of choice at CB Insights. We use it for classification, feature selection, feature extraction and clustering. What we like most about it is that it has a consistent API which is easy to use while also providing <strong>a lot of</strong> evaluation, diagnostic and cross-validation methods out of the box (sound familiar? Python has batteries-included approach as well). The icing on the cake is that it uses Scipy data structures under the hood and fits quite well with the rest of scientific computing in Python with Scipy, Numpy, Pandas and Matplotlib packages. Therefore, if you want to visualize the performance of your classifiers (say, using a precision-recall graph or Receiver Operating Characteristics (ROC) curve) those could be quickly visualized with help of Matplotlib. Considering how much time is spent on cleaning and structuring the data, this makes it very convenient to use the library as it tightly integrates to other scientific computing packages.</p>

<p>Moreover, it has also limited Natural Language Processing feature extraction capabilities as well such as bag of words, tfidf, preprocessing (stop-words, custom preprocessing, analyzer). Moreover, if you want to quickly perform different benchmarks on toy datasets, it has a datasets module which provides common and useful datasets. You could also build toy datasets from these datasets for your own purposes to see if your model performs well before applying the model to the real-world dataset. For parameter optimization and tuning, it also provides grid search and random search. These features could not be accomplished if it did not have great community support or if it was not well-maintained. We look forward to its first stable release.</p>

<h3>Statsmodels</h3>

<p><a href="http://statsmodels.sourceforge.net/">Statsmodels</a> is another great library which focuses on statistical models and is used mainly for predictive and exploratory analysis. If you want to fit linear models, do statistical analysis, maybe a bit of predictive modeling, then Statsmodels is a great fit. The statistical tests it provides are quite comprehensive and cover validation tasks for most of the cases. If you are R or S user, it also accepts R syntax for some of its statistical models. It also accepts Numpy arrays as well as Pandas data-frames for its models making creating intermediate data structures a thing of the past!</p>

<h3>PyMC</h3>

<p><a href="http://pymc-devs.github.io/pymc/">PyMC</a> is the tool of choice for <strong>Bayesians</strong>. It includes Bayesian models, statistical distributions and diagnostic tools for the convergence of models. It includes some hierarchical models as well. If you want to do Bayesian Analysis, you should check it out.</p>

<h3>Shogun</h3>

<p><a href="http://www.shogun-toolbox.org/page/home/">Shogun</a> is a machine learning toolbox with a focus on Support Vector Machines (SVM) that is written in C++. It is actively developed and maintained, provides a Python interface and the Python interface is mostly documented well. However, we’ve found its API hard to use compared to Scikit-learn. Also, it does not provide many diagnostics or evaluation algorithms out of the box. However, its speed is a great advantage.</p>

<h3>Gensim</h3>

<p><a href="http://radimrehurek.com/gensim/">Gensim</a> is defined as “topic modeling for humans”. As its homepage describes, its main focus is Latent Dirichlet Allocation (LDA) and its variants. Different from other packages, it has support for Natural Language Processing which makes it easier to combine NLP pipeline with other machine learning algorithms. If your domain is in NLP and you want to do clustering and basic classification, you may want to check it out. Recently, they introduced Recurrent Neural Network based text representation called word2vec from Google to their API as well. This library is written purely in Python.</p>

<h3>Orange</h3>

<p><a href="http://orange.biolab.si/">Orange</a> is the only library that has a Graphical User Interface (GUI) among the libraries listed in this post. It is also quite comprehensive in terms of classification, clustering and feature selection methods and has some cross-validation methods. It is better than Scikit-learn in some aspects (classification methods, some preprocessing capabilities) as well, but it does not fit well with the rest of the scientific computing ecosystem (Numpy, Scipy, Matplotlib, Pandas) as nicely as Scikit-learn.</p>

<p>Having a GUI is an important advantage over other libraries however. You could visualize cross-validation results, models and feature selection methods (you need to install Graphviz for some of the capabilities separately). Orange has its own data structures for most of the algorithms so you need to wrap the data into Orange-compatible data structures which makes the learning curve steeper.</p>

<h3>PyMVPA</h3>

<p><a href="http://www.pymvpa.org/index.html">PyMVPA</a> is another statistical learning library which is similar to Scikit-learn in terms of its API. It has cross-validation and diagnostic tools as well, but it is not as comprehensive as Scikit-learn.</p>

<h3>Deep Learning</h3>

<p>Even though deep learning is a subsection Machine Learning, we created a separate section for this field as it has received tremendous attention recently with various acqui-hires by Google and Facebook.</p>

<h4>Theano</h4>

<p><a href="http://deeplearning.net/software/theano/">Theano</a> is the most mature of deep learning library. It provides nice data structures (tensors) to represent layers of neural networks and they are efficient in terms of linear algebra similar to Numpy arrays. One caution is that, its API may not be very intuitive, which increases learning curve for users. There are a lot of libraries which build on top of Theano exploiting its data structures. It has support for GPU programming out of the box as well.</p>

<h4>PyLearn2</h4>

<p>There is another library built on top of Theano, called <a href="http://deeplearning.net/software/pylearn2/">PyLearn2</a> which brings modularity and configurability to Theano where you could create your neural network through different configuration files so that it would be easier to experiment different parameters. Arguably, it provides more modularity by separating the parameters and properties of neural network to the configuration file.</p>

<h4>Decaf</h4>

<p><a href="http://caffe.berkeleyvision.org/">Decaf</a> is a recently released deep learning library from UC Berkeley which has state of art neural network implementations which are tested on the Imagenet classification competition.</p>

<h4>Nolearn</h4>

<p>If you want to use excellent Scikit-learn library api in deep learning as well, <a href="http://packages.python.org/nolearn/">Nolearn</a> wraps Decaf to make the life easier for you. It is a wrapper on top of Decaf and it is compatible(mostly) with Scikit-learn, which makes Decaf even more awesome.</p>

<h4>OverFeat</h4>

<p><a href="https://github.com/sermanet/OverFeat">OverFeat</a> is a recent winner of <a href="https://plus.google.com/+PierreSermanet/posts/GxZHEH9ynoj">Dogs vs Cats (kaggle competition)</a> which is written in C++ but it comes with a Python wrapper as well(along with Matlab and Lua). It uses GPU through Torch library so it is quite fast. It also won the detection and localization competition in ImageNet classification. If your main domain is in computer vision, you may want to check it out.</p>

<h4>Hebel</h4>

<p><a href="https://github.com/hannes-brt/hebel">Hebel</a> is another neural network library comes along with GPU support out of the box. You could determine the properties of your neural networks through YAML files(similar to Pylearn2) which provides a nice way to separate your neural network from the code and quickly run your models. Since it has been recently developed, documentation is lacking in terms of depth and breadth. It is also limited in terms of neural network models as it only has one type of neural network model(feed-forward). However, it is written in pure Python and it will be nice library as it has a lot of utility functions such as schedulers and monitors which we did not see any library provides such functionalities.</p>

<h4>Neurolab</h4>

<p><a href="https://code.google.com/p/neurolab/">NeuroLab</a> is another neural network library which has nice api(similar to Matlab’s api if you are familiar) It has different variants of Recurrent Neural Network(RNN) implementation unlike other libraries. If you want to use RNN, this library might be one of the best choice with its simple API.</p>

<h3>Integration with other languages</h3>

<p>You do not know any Python but great in another language? Do not despair! One of the strengths of Python (among many other) is that it is a perfect glue language that you could use your tool of choice programming language with these libraries through access from Python. Following packages for respective programming languages could be used to combine Python with other programming languages:</p>

<ul>
<li>R &ndash;> <a href="http://rpython.r-forge.r-project.org/">RPython</a></li>
<li>Matlab &ndash;> <a href="http://algoholic.eu/matpy/">matpython</a></li>
<li>Java &ndash;> <a href="http://www.jython.org/jythonbook/en/1.0/JythonAndJavaIntegration.html">Jython</a></li>
<li>Lua &ndash;> <a href="http://labix.org/lunatic-python">Lunatic Python</a></li>
<li>Julia &ndash;> <a href="https://github.com/stevengj/PyCall.jl">PyCall.jl</a></li>
</ul>


<h3>Inactive Libraries</h3>

<p>These are the libraries that did not release any updates for more than one year, we are listing them because some may find it useful, but it is unlikely that these libraries will be maintained for bug fixes and especially enhancements in the future:</p>

<ul>
<li><a href="https://github.com/mdp-toolkit/mdp-toolkit">MDP</a></li>
<li><a href="http://mlpy.sourceforge.net/docs/3.5/">MlPy</a></li>
<li><a href="http://ffnet.sourceforge.net/">FFnet</a></li>
<li><a href="http://pybrain.org/">PyBrain</a></li>
</ul>


<p>If we are missing one of your favorite packages in Python for machine learning, feel free to let us know in the comments. We will gladly add that library to our blog post as well.</p>

<p><a href="https://www.cbinsights.com/blog/python-tools-machine-learning/">Origin</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Python數據分析入門(轉)]]></title>
    <link href="http://www.aprilzephyr.com/blog/05142015/pythonshu-ju-fen-xi-ru-men-zhuan/"/>
    <updated>2015-05-14T10:46:30+08:00</updated>
    <id>http://www.aprilzephyr.com/blog/05142015/pythonshu-ju-fen-xi-ru-men-zhuan</id>
    <content type="html"><![CDATA[<p>最近，<a href="http://alstatr.blogspot.com/">Analysis with Programming</a>加入了<a href="http://planetpython.org/">Planet Python</a>。作為該網站的首批特約博客，我這裏來分享一下如何通過Python來開始數據分析。具體內容如下：</p>

<ol>
<li>數據導入<br/>
** 導入本地的或者web端的CSV文件；</li>
<li>數據變換；</li>
<li>數據統計描述；</li>
<li>假設檢驗<br/>
** 單樣本t檢驗；</li>
<li>可視化；</li>
<li>創建自定義函數。<!--more--></li>
</ol>


<h3>數據導入</h3>

<p>這是很關鍵的一步，為了後續的分析我們首先需要導入數據。通常來說，數據是CSV格式，就算不是，至少也可以轉換成CSV格式。在Python中，我們的操作如下：</p>

<pre><code>import pandas as pd

# Reading data locally
df = pd.read_csv('/Users/al-ahmadgaidasaad/Documents/d.csv')

# Reading data from web
data_url = "https://raw.githubusercontent.com/alstat/Analysis-with-Programming/master/2014/Python/Numerical-Descriptions-of-the-Data/data.csv"
df = pd.read_csv(data_url)
</code></pre>

<p>為了讀取本地CSV文件，我們需要pandas這個數據分析庫中的相應模塊。其中的read_csv函數能夠讀取本地和web數據。</p>

<h3>數據變換</h3>

<p>既然在工作空間有了數據，接下來就是數據變換。統計學家和科學家們通常會在這一步移除分析中的非必要數據。我們先看看數據：</p>

<pre><code># Head of the data
print df.head()

# OUTPUT
    Abra  Apayao  Benguet  Ifugao  Kalinga
0   1243    2934      148    3300    10553
1   4158    9235     4287    8063    35257
2   1787    1922     1955    1074     4544
3  17152   14501     3536   19607    31687
4   1266    2385     2530    3315     8520

# Tail of the data
print df.tail()

# OUTPUT
 Abra  Apayao  Benguet  Ifugao  Kalinga
74   2505   20878     3519   19737    16513
75  60303   40065     7062   19422    61808
76   6311    6756     3561   15910    23349
77  13345   38902     2583   11096    68663
78   2623   18264     3745   16787    16900
</code></pre>

<p>對R語言程序員來說，上述操作等價於通過print(head(df))來打印數據的前6行，以及通過print(tail(df))來打印數據的後6行。當然Python中，默認打印是5行，而R則是6行。因此R的代碼head(df, n = 10)，在Python中就是df.head(n = 10)，打印數據尾部也是同樣道理。</p>

<p>在R語言中，數據列和行的名字通過colnames和rownames來分別進行提取。在Python中，我們則使用columns和index屬性來提取，如下：</p>

<pre><code># Extracting column names
print df.columns

# OUTPUT
Index([u'Abra', u'Apayao', u'Benguet', u'Ifugao', u'Kalinga'], dtype='object')

# Extracting row names or the index
print df.index

# OUTPUT
Int64Index([0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78], dtype='int64')
</code></pre>

<p>數據轉置使用T方法，</p>

<pre><code># Transpose data
print df.T

# OUTPUT
            0      1     2      3     4      5     6      7     8      9  
Abra      1243   4158  1787  17152  1266   5576   927  21540  1039   5424  
Apayao    2934   9235  1922  14501  2385   7452  1099  17038  1382  10588  
Benguet    148   4287  1955   3536  2530    771  2796   2463  2592   1064  
Ifugao    3300   8063  1074  19607  3315  13134  5134  14226  6842  13828  
Kalinga  10553  35257  4544  31687  8520  28252  3106  36238  4973  40140  

         ...       69     70     71     72     73     74     75     76     77 
Abra     ...    12763   2470  59094   6209  13316   2505  60303   6311  13345  
Apayao   ...    37625  19532  35126   6335  38613  20878  40065   6756  38902  
Benguet  ...     2354   4045   5987   3530   2585   3519   7062   3561   2583  
Ifugao   ...     9838  17125  18940  15560   7746  19737  19422  15910  11096  
Kalinga  ...    65782  15279  52437  24385  66148  16513  61808  23349  68663  

            78 
Abra      2623 
Apayao   18264 
Benguet   3745 
Ifugao   16787 
Kalinga  16900 

Other transformations such as sort can be done using &lt;code&gt;sort&lt;/code&gt; attribute. Now let's extract a specific column. In Python, we do it using either &lt;code&gt;iloc&lt;/code&gt; or &lt;code&gt;ix&lt;/code&gt; attributes, but &lt;code&gt;ix&lt;/code&gt; is more robust and thus I prefer it. Assuming we want the head of the first column of the data, we have
</code></pre>

<p>其他變換，例如排序就是用sort屬性。現在我們提取特定的某列數據。Python中，可以使用iloc或者ix屬性。但是我更喜歡用ix，因為它更穩定一些。假設我們需數據第一列的前5行，我們有：</p>

<pre><code>print df.ix[:, 0].head()

# OUTPUT
0     1243
1     4158
2     1787
3    17152
4     1266
Name: Abra, dtype: int64
</code></pre>

<p>順便提一下，Python的索引是從0開始而非1。為了取出從11到20行的前3列數據，我們有：</p>

<pre><code>print df.ix[10:20, 0:3]

# OUTPUT
    Abra  Apayao  Benguet
10    981    1311     2560
11  27366   15093     3039
12   1100    1701     2382
13   7212   11001     1088
14   1048    1427     2847
15  25679   15661     2942
16   1055    2191     2119
17   5437    6461      734
18   1029    1183     2302
19  23710   12222     2598
20   1091    2343     2654
</code></pre>

<p>上述命令相當於df.ix[10:20, [&lsquo;Abra&rsquo;, &lsquo;Apayao&rsquo;, &lsquo;Benguet&rsquo;]]。</p>

<p>為了舍棄數據中的列，這裏是列1(Apayao)和列2(Benguet)，我們使用drop屬性，如下：</p>

<pre><code>print df.drop(df.columns[[1, 2]], axis = 1).head()

# OUTPUT
    Abra  Ifugao  Kalinga
0   1243    3300    10553
1   4158    8063    35257
2   1787    1074     4544
3  17152   19607    31687
4   1266    3315     8520
</code></pre>

<p>axis 參數告訴函數到底舍棄列還是行。如果axis等於0，那麽就舍棄行。</p>

<h3>統計描述</h3>

<p>下一步就是通過describe屬性，對數據的統計特性進行描述：</p>

<pre><code>print df.describe()

# OUTPUT
               Abra        Apayao      Benguet        Ifugao       Kalinga
count     79.000000     79.000000    79.000000     79.000000     79.000000
mean   12874.379747  16860.645570  3237.392405  12414.620253  30446.417722
std    16746.466945  15448.153794  1588.536429   5034.282019  22245.707692
min      927.000000    401.000000   148.000000   1074.000000   2346.000000
25%     1524.000000   3435.500000  2328.000000   8205.000000   8601.500000
50%     5790.000000  10588.000000  3202.000000  13044.000000  24494.000000
75%    13330.500000  33289.000000  3918.500000  16099.500000  52510.500000
max    60303.000000  54625.000000  8813.000000  21031.000000  68663.000000
</code></pre>

<h3>假設檢驗</h3>

<p>Python有一個很好的統計推斷包。那就是scipy裏面的stats。ttest_1samp實現了單樣本t檢驗。因此，如果我們想檢驗數據Abra列的稻谷產量均值，通過零假設，這裏我們假定總體稻谷產量均值為15000，我們有：</p>

<pre><code>from scipy import stats as ss

# Perform one sample t-test using 1500 as the true mean
print ss.ttest_1samp(a = df.ix[:, 'Abra'], popmean = 15000)

# OUTPUT
(-1.1281738488299586, 0.26270472069109496)
</code></pre>

<p>返回下述值組成的元祖：<br/>
* t : 浮點或數組類型<br/>
t統計量<br/>
* prob : 浮點或數組類型<br/>
two-tailed p-value 雙側概率值</p>

<p>通過上面的輸出，看到p值是0.267遠大於α等於0.05，因此沒有充分的證據說平均稻谷產量不是150000。將這個檢驗應用到所有的變量，同樣假設均值為15000，我們有：</p>

<pre><code>print ss.ttest_1samp(a = df, popmean = 15000)

# OUTPUT
(array([ -1.12817385,   1.07053437, -65.81425599,  -4.564575  ,   6.17156198]),
 array([  2.62704721e-01,   2.87680340e-01,   4.15643528e-70,
          1.83764399e-05,   2.82461897e-08]))
</code></pre>

<p>第一個數組是t統計量，第二個數組則是相應的p值。</p>

<h3>可視化</h3>

<p>Python中有許多可視化模塊，最流行的當屬matpalotlib庫。稍加提及，我們也可選擇bokeh和seaborn模塊。之前的博文中，我已經說明了matplotlib庫中的盒須圖模塊功能。<br/>
<img src="/images/pda/1.jpg"></p>

<pre><code># Import the module for plotting
import matplotlib.pyplot as plt
 plt.show(df.plot(kind = 'box'))
</code></pre>

<p>現在，我們可以用pandas模塊中集成R的ggplot主題來美化圖表。要使用ggplot，我們只需要在上述代碼中多加一行，</p>

<pre><code>import matplotlib.pyplot as plt
pd.options.display.mpl_style = 'default' # Sets the plotting display theme to ggplot2
df.plot(kind = 'box')
</code></pre>

<p>這樣我們就得到如下圖表：
<img src="/images/pda/2.jpg"></p>

<p>比matplotlib.pyplot主題簡潔太多。但是在本博文中，我更願意引入seaborn模塊，該模塊是一個統計數據可視化庫。因此我們有：<br/>
<img src="/images/pda/3.jpg"></p>

<pre><code># Import the seaborn library
import seaborn as sns
 # Do the boxplot
plt.show(sns.boxplot(df, widths = 0.5, color = "pastel"))
</code></pre>

<p>多性感的盒式圖，繼續往下看。<br/>
<img src="/images/pda/4.jpg"></p>

<pre><code>plt.show(sns.violinplot(df, widths = 0.5, color = "pastel"))
</code></pre>

<p><img src="/images/pda/5.jpg"></p>

<pre><code>plt.show(sns.distplot(df.ix[:,2], rug = True, bins = 15))
</code></pre>

<p><img src="/images/pda/6.jpg"></p>

<pre><code>with sns.axes_style("white"):
    plt.show(sns.jointplot(df.ix[:,1], df.ix[:,2], kind = "kde"))
</code></pre>

<p><img src="/images/pda/7.jpg"></p>

<pre><code>plt.show(sns.lmplot("Benguet", "Ifugao", df))
</code></pre>

<h3>創建自定義函數</h3>

<p>在Python中，我們使用def函數來實現一個自定義函數。例如，如果我們要定義一個兩數相加的函數，如下即可：</p>

<pre><code>def add_2int(x, y):
    return x + y

print add_2int(2, 2)

# OUTPUT
4
</code></pre>

<p>順便說一下，Python中的縮進是很重要的。通過縮進來定義函數作用域，就像在R語言中使用大括號{…}一樣。這有一個我們之前博文的例子：</p>

<ol>
<li>產生10個正態分布樣本，其中u=3和σ<sup>2</sup>=5</li>
<li>基於95%的置信度，計算x̄和<img src="http://latex.codecogs.com/gif.latex?\bar{x}\mp&space;z_{a/}(2\frac{\sigma&space;}{\sqrt{n}})" title="\bar{x}\mp z_{a/}(2\frac{\sigma }{\sqrt{n}})" />;</li>
<li>重復100次; 然後</li>
<li>計算出置信區間包含真實均值的百分比</li>
</ol>


<p>Python中，程序如下：</p>

<pre><code>import numpy as np
import scipy.stats as ss

def case(n = 10, mu = 3, sigma = np.sqrt(5), p = 0.025, rep = 100):
    m = np.zeros((rep, 4))

    for i in range(rep):
        norm = np.random.normal(loc = mu, scale = sigma, size = n)
        xbar = np.mean(norm)
        low = xbar - ss.norm.ppf(q = 1 - p) * (sigma / np.sqrt(n))
        up = xbar + ss.norm.ppf(q = 1 - p) * (sigma / np.sqrt(n))

        if (mu &gt; low) &amp; (mu &lt; up):
            rem = 1
        else:
            rem = 0

        m[i, :] = [xbar, low, up, rem]

    inside = np.sum(m[:, 3])
    per = inside / rep
    desc = "There are " + str(inside) + " confidence intervals that contain "
           "the true mean (" + str(mu) + "), that is " + str(per) + " percent of the total CIs"

    return {"Matrix": m, "Decision": desc}
</code></pre>

<p>上述代碼讀起來很簡單，但是循環的時候就很慢了。下面針對上述代碼進行了改進，這多虧了 Python專家，看我上篇博文的<a href="http://alstatr.blogspot.com/2014/01/python-and-r-is-python-really-faster.html#disqus_thread">15條意見</a>吧。</p>

<pre><code>import numpy as np
import scipy.stats as ss

def case2(n = 10, mu = 3, sigma = np.sqrt(5), p = 0.025, rep = 100):
    scaled_crit = ss.norm.ppf(q = 1 - p) * (sigma / np.sqrt(n))
    norm = np.random.normal(loc = mu, scale = sigma, size = (rep, n))

    xbar = norm.mean(1)
    low = xbar - scaled_crit
    up = xbar + scaled_crit

    rem = (mu &gt; low) &amp; (mu &lt; up)
    m = np.c_[xbar, low, up, rem]

    inside = np.sum(m[:, 3])
    per = inside / rep
    desc = "There are " + str(inside) + " confidence intervals that contain "
           "the true mean (" + str(mu) + "), that is " + str(per) + " percent of the total CIs"
    return {"Matrix": m, "Decision": desc}
</code></pre>

<h3>更新</h3>

<p>那些對於本文ipython notebook版本感興趣的，請點擊<a href="http://nuttenscl.be/Python_Getting_Started_with_Data_Analysis.html">這裏</a>。這篇文章由<a href="https://twitter.com/NuttensC">Nuttens Claude</a>負責轉換成 ipython notebook 。</p>

<p>關於作者: <a href="http://python.jobbole.com/author/dengcy/">Den</a></p>

<p><a href="http://alstatr.blogspot.ca/2015/02/python-getting-started-with-data.html">Origin</a><br/>
<a href="http://python.jobbole.com/81133/">中文譯文</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Potential Pythonic Pitfalls(FW)]]></title>
    <link href="http://www.aprilzephyr.com/blog/05142015/potential-pythonic-pitfalls-fw/"/>
    <updated>2015-05-14T09:24:13+08:00</updated>
    <id>http://www.aprilzephyr.com/blog/05142015/potential-pythonic-pitfalls-fw</id>
    <content type="html"><![CDATA[<p>Python is a very expressive language. It provides us with a large standard library and many builtins to get the job done quickly. However, many can get lost in the power that it provides, fail to make full use of the standard library, value one liners over clarity and misunderstand its basic constructs. This is a non-exhaustive list of a few of the pitfalls programmers new to Python fall into.<!--more--></p>

<h2>Not Knowing the Python Version</h2>

<p>This is a recurring problem in StackOverflow questions. Many write perfectly working code for one version but they have a different version of Python installed on their system.<sup>[1]</sup> Make sure that you know the Python version you&rsquo;re working with. You can check via the following:</p>

<pre><code>$ python --version
Python 2.7.9
</code></pre>

<h2>Not using Pyenv</h2>

<p><a href="https://github.com/yyuu/pyenv">pyenv</a> is a great tool for managing different Python versions. Unfortunately, it only works on *nix systems. On Mac OS, one can simply install it via  <code>brew install pyenv</code>  and on Linux, there is an <a href="https://github.com/yyuu/pyenv-installer">automatic installer</a>.</p>

<h2>Obsessing Over One-Liners</h2>

<p>Some get a real kick out of one liners. Many boast about their one-liner solutions even if they are less efficient than a multi-line solution.</p>

<p>What this essentially means in Python is convoluted comprehensions having multiple expressions. For example:</p>

<pre><code>l = [m for a, b in zip(this, that) if b.method(a) != b for m in b if not m.method(a, b) and reduce(lambda x, y: a + y.method(), (m, a, b))]
</code></pre>

<p>To be perfectly honest, I made the above example up. But, I&rsquo;ve seen plenty of people write code like it. Code like this will make no sense in a week&rsquo;s time. If you&rsquo;re trying to do something a little more complex that simply adding an item to a <code>list</code> or <code>set</code> with a condition then you&rsquo;re probably making a mistake.</p>

<p>One-Liners are not achievements, yes they can seem very clever but they are not achievements. Its like thinking that shoving everything into your closet is an actual attempt at cleaning your room. Good code is clean, easy to read and efficient.</p>

<h2>Initializing a set the Wrong Way</h2>

<p>This is a more subtle problem that can catch you off guard. <code>set</code> comprehensions are a lot like list comprehensions.</p>

<pre><code>&gt;&gt;&gt; { n for n in range(10) if n % 2 == 0 }
{0, 8, 2, 4, 6}
&gt;&gt;&gt; type({ n for n in range(10) if n % 2 == 0 })
&lt;class 'set'&gt;
</code></pre>

<p>The above is one such example of a set comprehension. Sets are like lists in that they are containers. The difference is that a set cannot have any duplicate values and sets are unordered. Seeing set comprehensions people often make the mistake of thinking that <code>{}</code> initializes an empty set. It does not, it initializes an empty dict.</p>

<pre><code>&gt;&gt;&gt; {}
{}
&gt;&gt;&gt; type({})
&lt;class 'dict'&gt;
</code></pre>

<p>If we wish to initialize an empty set, then we simply call <code>set()</code>.</p>

<pre><code>&gt;&gt;&gt; set()
set()
&gt;&gt;&gt; type(set())
&lt;class 'set'&gt;
</code></pre>

<p>Note how an empty set is denoted as <code>set()</code> but a set containing something is denoted as items surrounded by curly braces.</p>

<pre><code>&gt;&gt;&gt; s = set()
&gt;&gt;&gt; s
set()
&gt;&gt;&gt; s.add(1)
&gt;&gt;&gt; s
{1}
&gt;&gt;&gt; s.add(2)
&gt;&gt;&gt; s
{1, 2}
</code></pre>

<p>This is rather counter intuitive, since you&rsquo;d expect something like <code>set([1, 2])</code>.</p>

<h2>Misunderstanding the GIL</h2>

<p>The GIL (Global Interpreter Lock) means that only one thread in a Python program can be running at any one time. This implies that when we create a thread and expect to run in parallel it doesn&rsquo;t. What the Python interpreter is actually doing is quickly switching between different running threads. But this is an oversimplified version of what is actually happening. There are many instances in which things do run in parallel, like when using libraries that are essentially C extensions. But when running Python code, you don&rsquo;t get parallel execution most of the time. In other words, threads in Python are not like Threads in Java or C++.</p>

<p>Many will try to defend Python by saying that these are real threads<sup>[2]</sup>. This is indeed true, but does not change the fact that how Python handles threads is different from what you&rsquo;d generally expect. This is the same case for a language like Ruby (which also has an interpreter lock).</p>

<p>The prescribed solution to this is using the <code>multiprocessing</code> module. The <code>multiprocessing</code> module provides you with the <code>Process</code> class which is basically a nice cover over a fork. However, a fork is much more expensive than a thread, so you might not always see the performance benefits since now the different processes have to do a lot of work to co-ordinate with each other.</p>

<p>However, this problem does not exist every implementation of Python. <a href="http://pypy.readthedocs.org/en/latest/stm.html">PyPy-stm</a> for example is an implementation of Python that tries to get rid of the GIL (still not stable yet). Implementations built on top of other platforms like the JVM (Jython) or CLR (IronPython) do not have GIL problems.</p>

<p>All in all, be careful when using the <code>Thread</code> class, what you get might not be what you expect.</p>

<h2>Using Old Style Classes</h2>

<p>In Python 2 there are two types of classes, there&rsquo;s the &ldquo;old style&rdquo; classes, and there&rsquo;s the &ldquo;new style&rdquo; classes. If you&rsquo;re using Python 3, then you&rsquo;re using the &ldquo;new style&rdquo; classes by default. In order to make sure that you&rsquo;re using &ldquo;new style&rdquo; classes in Python 2, you need to inherit from <code>object</code> for any new class you create that isn&rsquo;t already inheriting from a builtin like <code>int</code> or <code>list</code>. In other words, your base class, the class that isn&rsquo;t inheriting from anything else, should always inherit from object.</p>

<pre><code>class MyNewObject(object):
    # stuff here
</code></pre>

<p>These &ldquo;new style&rdquo; classes fix some very fundamental flaws in the old style classes that we really don&rsquo;t need to get into. However, if anyone is interested they can find the information in the <a href="https://docs.python.org/2/reference/datamodel.html#new-style-and-classic-classes">related documentation</a>.</p>

<h2>Iterating the Wrong Way</h2>

<p>Its very common to see the following code from users who are relatively new to the language:</p>

<pre><code>for name_index in range(len(names)):
    print(names[name_index])
</code></pre>

<p>There is no need to call <code>len</code> in the above example, since iterating over the list is actually much simpler:</p>

<pre><code>for name in names:
    print(name)
</code></pre>

<p>Furthermore, there are a whole host of other tools at your disposal to make iteration easier. For example, <code>zip</code> can be used to iterate over two lists at once<sup>[3]</sup>:</p>

<pre><code>for cat, dog in zip(cats, dogs):
    print(cat, dog)
</code></pre>

<p>If we want to take into consideration both the index and the value list variable, we can use <code>enumerate</code>:<sup>[4]</sup></p>

<pre><code>for index, cat in enumerate(cats):
    print(cat, index)
</code></pre>

<p>There are also many useful functions to choose from in <a href="https://docs.python.org/3/library/itertools.html">itertools</a>. Please note however, that using <code>itertools</code> functions is not always the right choice. If one of the functions in <code>itertools</code> offers a very convenient solution to the problem you&rsquo;re trying to solve, like flattening a list or creating a getting the permutations of the contents of a given list, then go for it. But don&rsquo;t try to fit it into some part of your code just because you want to.</p>

<p>The problem with <code>itertools</code> abuse happens so often that one highly respected Python contributor on StackOverflow has dedicated a significant part of their profile to it.<sup>[5]</sup></p>

<h2>Using Mutable Default Arguments</h2>

<p>I&rsquo;ve seen the following quite a lot:</p>

<pre><code>def foo(a, b, c=[]):
    # append to c
    # do some more stuff
</code></pre>

<p>Never use mutable default arguments, instead use the following:</p>

<pre><code>def foo(a, b, c=None):
    if c is None:
        c = []
    # append to c
    # do some more stuff
</code></pre>

<p>Instead of explaining what the problem is, its better to show the effects of using mutable default arguments:</p>

<pre><code>In[2]: def foo(a, b, c=[]):
...     c.append(a)
...     c.append(b)
...     print(c)
...
In[3]: foo(1, 1)
[1, 1]
In[4]: foo(1, 1)
[1, 1, 1, 1]
In[5]: foo(1, 1)
[1, 1, 1, 1, 1, 1]
</code></pre>

<p>The same <code>c</code> is being referenced again and again every time the function is called. This can have some very unwanted consequences.</p>

<h2>Takeaway</h2>

<p>These are just some of the problems that one might run into when relatively new at Python. Please note however, that this is far from a comprehensive list of the problems that one might run into. The other pitfalls however are largely to do with people using Python like Java or C++ and trying to use Python in a way that they are familiar with. So, as a continuation of this, try diving into things like Python&rsquo;s <code>super</code> function. Take a look at <code>classmethod</code>, <code>staticmethod</code> and <code>__slots__</code>.</p>

<h2>Update</h2>

<p>Last Updated on 12 May 2015 4:50 PM (GMT +6)</p>

<p>Made the section on <a href="http://nafiulis.me/potential-pythonic-pitfalls.html#misunderstanding-the-gil">Misunderstanding the GIL</a></p>

<hr />

<p>[1] Most people are taught Python using Python 2. However, when they go home and try things out themselves, they install Python 3 (quite a natural thing to install the latest version).<br/>
[2] When people talk about real threads what they essentially mean is that these threads are real CPU threads, which are scheduled by the OS (Operating System).<br/>
[3] <a href="https://docs.python.org/3/library/functions.html#zip">https://docs.python.org/3/library/functions.html#zip</a><br/>
[4] <code>enumerate</code> can be further configured to produce the kind of index you want. <a href="https://docs.python.org/3/library/functions.html#enumerate">https://docs.python.org/3/library/functions.html#enumerate</a><br/>
[5] <a href="http://stackoverflow.com/users/908494/abarnert">http://stackoverflow.com/users/908494/abarnert</a></p>

<p><a href="http://nafiulis.me/potential-pythonic-pitfalls.html">Original</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[The Python IAQ: Infrequently Answered Questions]]></title>
    <link href="http://www.aprilzephyr.com/blog/05052015/python-infrequently-answered-questions/"/>
    <updated>2015-05-05T13:02:30+08:00</updated>
    <id>http://www.aprilzephyr.com/blog/05052015/python-infrequently-answered-questions</id>
    <content type="html"><![CDATA[<h3>1 Q: 什麽是"少有回答的問題(Infrequently Answered Question)&ldquo; ?</h3>

<p>一個問題之所以很少有人回答，要麽是因為很少有人知道問題的答案，要麽是因為它涉及到一個晦澀而隱蔽的知識點(但可能是你關心的)。我過去認為是我在<a href="http://www.norvig.com/java-iaq.html">Java IAQ</a>中發明了這個詞組，但是它也出現在了以資料豐富而著稱的<a href="http://urbanlegends.about.com/library/weekly/aa082497.htm">About.com Urban Legends</a>網站上. 關於Python的FAQ有很多,但是Python的IAQ只有這一個。(&ldquo;少見問題列表"倒是有一些，其中一個是有諷刺意味的<a href="http://www.plethora.net/%7Eseebs/faqs/c-iaq.html">C</a>。)<!--more--></p>

<h3>2 Q: finally子句中的代碼每次都會被執行,對嗎?</h3>

<p>每次?應該說，幾乎每次。在try子句被執行後，無論是否出現異常，finally子句中的代碼都會被執行，即使調用了sys.exit. 不過如果程序沒有執行到finally子句的話，它就沒有辦法運行了。下面的代碼中，無論choice取何值，都會發生這樣的情況:</p>

<pre><code>try:
    if choice:
        while 1:
            pass
    else:
        print "Please pull the plug on your computer sometime soon..."
        time.sleep(60 * 60 * 24 * 365 * 10000)
finally:
    print "Finally ..."
</code></pre>

<h3>3 Q: 多態真是太棒了!無論一個列表(list)中的元素是什麽類型,我都可以用sort對它排序,對嗎?</h3>

<p>不對。考慮這種情況:</p>

<pre><code>&gt;&gt;&gt; x = [1, 1j]
&gt;&gt;&gt; x.sort()
Traceback (most recent call last):
  File "&lt;pyshell#13&gt;", line 1, in ?
    x.sort()
TypeError: cannot compare complex numbers using &lt;, &lt;=, &gt;, &gt;=
</code></pre>

<p>(1j是一個數，表示-1的平方根)問題在於:sort方法(在目前的實現中)使用__lt__方法來 比較元素的大小。而__lt__方法拒絕比較復數的大小(因為它們是不能排序的)。奇怪的是,complex.__lt__會毫不猶豫的比較復數與字符串，列表(list)和其他所有類型，除了復數。所以答案是,你可以對支持__lt__方法的對象序列(sequence)進行排序(當然如果將來實現變了，可能就是其它方法了)。</p>

<p>對於問題的地一部份，“多態真棒”，我同意。但是Python有時會讓使用多態變得困難，因為許多Python的類型(比如序列和數)的定義不太符合規則。</p>

<h3>4 Q: 在Python中我能寫++x和x++嗎?</h3>

<p>從語法上說，++x能， x++不能。但是從實際使用來說，別這樣做。這麽說什麽意思？<br/>
* 可以， ++x是合法的Python語法。不過如果你是一個C++或者Java程序員的話，它表示不是你想的那個意思。加號+是一個單目前綴操作符，所以++x被解析為+(+x),它表示的(至少對於數字來說)就是x。<br/>
* 不可以， x++本身就不是一個合法的表達式, 雖然在某些上下文時合法。比如， x++ -y被解析為x++(&ndash;(y)), 對於數字來說，等於x &ndash; y。當然，你可以創建一個類，讓++x有(很有限的)意義。比如可以讓這個類保存一個數字，然後使單目操作符+使它增加0.5(或者有0.5的概率增加1，如果你喜歡隨機化算法)，但是&hellip;<br/>
* 不可以，那樣真傻。最好還是用Python 2.0已經中加入的x += 1。
進一步的問題:為什麽Python不允許 x++？ 我相信原因與Python不允許在表達式中賦值一樣: Python想要清晰的區分語句和表達式。如果我覺得這兩者應該有所區別，那麽不允許++就是最好的決定。另一方面，函數語言的鼓吹者認為語句就應該是表達式。我跟我的丹麥老鄉，Bjarne Stroustrup，都這樣認為。他在The Design and Evolution of C++中說:“如果是從頭來設計一種語言的話，我會按照Algol68的方式，讓每條語句和聲明都是一個有返回值的表達式”。</p>

<h3>5 Q: 我能使用C++中對ostreams那樣的語法嗎，像這樣麽: count &lt;&lt; x &lt;&lt; y &hellip;?</h3>

<p>當然可以。如果你不喜歡寫"print x,y"，你可以試試這個：</p>

<pre><code>import sys

class ostream:
    def __init__(self, file):
        self.file = file

    def __lshift__(self, obj):
        self.file.write(str(obj));
        return self

cout = ostream(sys.stdout)
cerr = ostream(sys.stderr)
nl = '\n'
-----------------------------------
cout &lt;&lt; x &lt;&lt; " " &lt;&lt; y &lt;&lt; nl
</code></pre>

<p>(本文中所有的文件中的代碼都在橫線以上，使用這些代碼的例子在橫線以下。)這樣你就可以使用一種不同的語法了，但是它不能給你帶來一種新的輸出格式，它只是把Python中以有str的格式封裝了一層而已。這個做法很像Java裏面的toString()格式。C++使用的是一種迥異的格式：它沒有定義一組把對象轉換為字符串的規則，而定義了一種把對象打印到流的規則(也許是不完整的規則，因為很多C++程序仍然使用printf)。用流來實現會更加復雜，但是它的優勢在於如果你需要打印一個相當巨大的對象，就不用創建一個巨大的臨時對象來做這件事。</p>

<h3>6 Q: 如果我喜歡C++的printf呢?</h3>

<p>在Python中定義一個printf不是一個壞主意. 你可能認為printf(&ldquo;%d = %s&rdquo;, num, result)比print &ldquo;%d = %s&rdquo; % (num, result)更加自然, 因為那一對括號在更熟悉的位置(而且你不想要那個%)。更和況, 滿足這個需求輕而易舉:</p>

<pre><code>def printf(format, *args): print format % args,
</code></pre>

<p>即使是像這樣的一行代碼，也有幾個不同實現。首先，我必需要決定是否在結尾添加逗號。為了更像C++, 我決定加上(這就意味著如果你想在結尾換行，你需要自己在格式字符串的末尾添加)。其次，結尾處會打印一個空格。如果你不想要它，使用sys.stdout.write來代替print. 最後, 把一切都變得更像C好是一件好事嗎? 是，因為你需要一個打印函數(而不是一個打印語句)在只接受函數不接受語句的地方使用。比如，在lambda表達式中和map的第一個參數。事實上，這樣一個函數使用起來是很趁手的，你可能想要一個沒有格式化功能的:</p>

<pre><code>def prin(x): print x,
</code></pre>

<p>現在map(prin, seq)將打印seq中的每一個元素. 但是map(print, seq)是一個語法錯誤. 我曾經見過有些粗心大意的程序員(好吧, 沒錯, 我自己就是. 但是我知道我自己很粗心 )認為把這兩個函數合二為一是個好主意, 像這樣:</p>

<pre><code>def printf(format, *args): print str(format) % args,  
</code></pre>

<p>這樣 printf(42)， printf(&lsquo;A multi-line\n message&rsquo;)和 printf(&lsquo;%4.2f&rsquo;, 42)都能工作。但是當你用了pring(&lsquo;100% guaranteed&rsquo;)或者是其他任何含有%字符卻並不是一個格式化指令時，"好主意"就會變成"我想啥呢?&ldquo;。如果你真的實現了這麽一個printf，它需要這樣的註釋:</p>

<pre><code>def printf(format, *args): 
    """使用第一個參數作為格式字符串來格式化args, 然後打印. 
    如果format不是字符串, 將被str轉換成字符串. 如果x可能含
    有%和反斜線字符, 你必須使用printf('%s', x)來代替 printf(x).
    """ 
  print str(format) % args,
</code></pre>

<h3>7 Q: 關於字典(Dictionary)，有沒有更好的語法? 我使用的鍵(key)都是標識符.</h3>

<p>有!用一對引號來包括鍵的確是一件麻煩的事情，尤其當鍵是一個很長的字符串時. 起初我認為Python中加入特別的語法是有幫助的，用{a=1, b=2}來代替現在必需的{&lsquo;a&rsquo;:1, &lsquo;b&rsquo;:2}。在Python 2.3中，你可以用的語法是dict(a=1, b=2, c=3, dee=4)，這和我的想法一樣好。在Python 2.3以前，我使用一個只有一行的函數def Dict(**dict): return dict</p>

<p>一個讀者指出，對於散列Perl也有類似的特殊符號: 在Perl中對於散列文本，你可以寫(&ldquo;a&rdquo;, 1, &ldquo;b&rdquo;, 2)或者(a=>1, b=>2)。這是事實，但不是事實的全部。"man perlop"說"=>符號最多只是逗號操作符的同意詞&hellip;&ldquo;而且事實上當a和b是barewords時，你可以寫(a, 1, b, 2)。但是，就像Dag Asheim指出的，如果你打開strict，你將會從這個寫法中得到一個錯誤。你必須要麽使用字符串，要麽使用=>操作符。最後，Larry Wall已經申明，"Perl 6中將不會有bareword"。(關於perl的這以部分，我的翻譯可能有很大問題，因為我根本不會Perl!&mdash;譯註)</p>

<h3>8 Q: 那麽，對象有沒有類似的簡便辦法呢?</h3>

<p>的確是有的。如果你想要創建一個對象來把數據保存在不同的域中，下面的代碼就可以做到:</p>

<pre><code>class Struct:
    def __init__(self, **entries):      self.__dict__.update(entries)
&gt;&gt;&gt; globals = Struct(answer=42, linelen = 80,   font='courier')
&gt;&gt;&gt; globals.answer
42
&gt;&gt;&gt; globals.answer = 'plastics'
&gt;&gt;&gt; vars(globals)
{'answer': 'plastics', 'font': 'courier', 'linelen': 80}
</code></pre>

<p>從本質上說，我們在這裏做的是創建一個匿名類。好吧，我知道globals的類是 Struct，但是因為我們在它裏面添加了slots，就像是創建了一個新的，未命名的類(這和lambda創建匿名函數是很像的)。我討厭再給Struct添加什麽了，因為它現在很簡潔，不過如果你添加下面的方法，就可以漂亮打印出它的每個結構。</p>

<pre><code>def __repr__(self):
    args = ['%s=%s' % (k, repr(v)) for (k,v) in     vars(self).items()]
    return 'Struct(%s)' % ', '.join(args)
&gt;&gt;&gt; globals
------------------------------------------------
Struct(answer='plastics', font='courier', linelen=80)
</code></pre>

<h3>9 Q: 這樣創建新對象是很方便，但是要更新時怎麽辦呢?</h3>

<p>是這樣的，字典是有一個update方法的，所以當d是一個字典時，你可以用d.update(dict(a=100, b=200))。但是對象沒有對應的方法，所以你只能用obj.a = 100;obj.b = 200。或者你可以定義一個函數update(x, a=100, b=200)來更新x，無論它是字典還是對象都可以:</p>

<pre><code>import types

def update(x, **entries):
    if type(x) == types.DictType: x.update(entries)
    else: x.__dict__.update(entries)
    return x
</code></pre>

<p>把它用於構造函數特別漂亮:</p>

<pre><code>def __init__(self, a, b, c, d=42, e=None, f=()):
    update(self, a=a, b=b, c=c, d=d, e=e, f=f) 
</code></pre>

<h3>10 Q: 我能創建一個默認值為0或者[]的或者別的什麽的字典麽?</h3>

<p>如果你常常要對某個東西計數，咱們會有同感: count[x] ＋＝ 1比被迫用的count[x] = count.get(x, 0) + 1要優美許多。在Python 2.2以後，繼承內建的dict類可以輕松的搞定這個。我把它叫做我的DefaultDict。註意copy.deepcopy的使用: 有了它，就不會讓dict裏面的每個key都使用同一個[]作為默認值(雖然拷貝0浪費了一點時間，不過如果你使用更新和訪問比初始化更頻繁的話，還算可以接受):</p>

<pre><code>class DefaultDict(dict):
"""Dictionary with a default value for unknown keys."""
    def __init__(self, default):
        self.default = default

   def __getitem__(self, key):
        if key in self: return self.get(key)
        return self.setdefault(key, copy.deepcopy(self.default))
--------------------------------------
&gt;&gt;&gt; d = DefaultDict(0)
&gt;&gt;&gt; d['hello'] += 1
&gt;&gt;&gt; d
{'hello': 1}
&gt;&gt;&gt; d2 = DefaultDict([])
&gt;&gt;&gt; d2[1].append('hello')
&gt;&gt;&gt; d2[2].append('world')
&gt;&gt;&gt; d2[1].append('there')
&gt;&gt;&gt; d2
{1: ['hello', 'there'], 2: ['world']}

def bigrams(words):
    "Counts of word pairs, in a dict of dicts."
    d = DefaultDict(DefaultDict(0))
    for (w1, w2) in zip([None] + words, words + [None]):
        d[w1][w2] += 1
    return d

&gt;&gt;&gt; bigrams('i am what i am'.split())
{None: {'i': 1}, 'i': {'am': 2}, 'what': {'i': 1},  'am': {None: 1, 'what': 1}}
</code></pre>

<p>值得註意的是，如果沒有DefaultDict，bigram例子程序中的d[w1][w2] += 1就大概應該象這樣:</p>

<pre><code>d.setdefault(w1,{}).setdefault(w2, 0); d[w1][w2] += 1
</code></pre>

<h3>11 Q: 嘿，你能用0.0007KB或者更少的代碼做一個矩陣變換麽?</h3>

<p>我還以為你永遠不會問呢. 如果你用序列組成的序列來表示矩陣的話，用zip就可以搞定了:</p>

<pre><code>&gt;&gt;&gt; m = [(1,2,3), (4,5,6)] 
&gt;&gt;&gt; zip(*m) 
[(1, 4), (2, 5), (3, 6)]
</code></pre>

<p>要想理解它，你需要知道f(*m)就像於apply(f,m)。你問的是一個古老的Lisp問題，在Python中它的等價答案是map(None, *m)，但是用Chih-Chung Chang建議的zip版代碼會更短小。你可能認為這些代碼唯一的用處就是在Letterman的Stupid Programmer'sTricks(David Michael Letterman, 美國晚間脫口秀主持人，他主持的一個著名節目是Stupid Pet Tricks——譯註)中露臉，但是有一天我遇到了這個問題:有一個數據庫行的列表，每一行中都是排序過的值的列表。找出每一列中不重復的值，組成一個列表。我的答案是：</p>

<pre><code>possible_values = map(unique, zip(*db))  
</code></pre>

<h3>12 Q: 用f(*m)的技巧很酷. 有沒有同樣的語法可以用在方法調用上, 比如x.f(*y)?</h3>

<p>這個問題暴露一個錯誤的概念。根本就沒有方法調用的語法！Python語法中，有函數調用的，也有從對象中取得域的，也有綁定方法的。把這三者結合起來，就讓x.f(y)看起來像一塊單獨的語法，而事實上，它等價於(x.f)(y)，後者又等價於(getattr(x, &lsquo;f&rsquo;))(y)。我猜你可能不相信我，來看:</p>

<pre><code>class X:
    def f(self, y): return 2 * y
    --------------------------------------
&gt;&gt;&gt; x = X()
&gt;&gt;&gt; x.f
&lt;bound method X.f of &lt;__main__.X instance at 0x009C7DB0&gt;&gt;
&gt;&gt;&gt; y = 21
&gt;&gt;&gt; x.f(y)
42
&gt;&gt;&gt; (x.f)(y)
42
&gt;&gt;&gt; (getattr(x, 'f'))(y)
42
&gt;&gt;&gt; xf = x.f
&gt;&gt;&gt; xf(y)
42
&gt;&gt;&gt; map(x.f, range(5))
[0, 2, 4, 6, 8]
</code></pre>

<p>所以這個問題的答案是:你可以在方法調用中使用*y或**y(或者其他任何你可以放在函數調用中的)，因為方法調用就是函數調用。</p>

<h3>13 Q: 你能用用0行代碼實現Python的抽象類嗎? 4行呢?</h3>

<p>Java中有一個abstract關鍵詞。你可以用它來定義一個只能繼承不能被實例化的抽象類，該類中所有的抽象方法都需要你來實現。很少有人知道在Python中，你可以用幾乎一樣的方式使用abstract。不同的是，當你想要調用一個沒有實現的方式時，你得到的是一個運行時錯誤而不是編譯錯誤。比較下面的代碼:</p>

<pre><code>## Python
class MyAbstractClass:
    def method1(self): abstract

class MyClass(MyAbstractClass): 
    pass
    --------------------------------------
&gt;&gt;&gt; MyClass().method1()
Traceback (most recent call last):
    ...
NameError: name 'abstract' is not defined
</code></pre>

<p>==============================================</p>

<pre><code>    /* Java */
public abstract class MyAbstractClass {
    public abstract void method1();
}

class MyClass extends MyAbstractClass {}
----------------------------------------------
% javac MyAbstractClass
MyAbstractClass.java:5: 
  class MyClass must be declared abstract. 
  It does not define void method1() from class MyAbstractClass.
</code></pre>

<p>別花太多時間在Python語言參考手冊裏面尋找abstract關鍵字，它根本就不在那裏。我把它加入了Python語言中，並且最美妙的是，它的實現用了0行代碼! 當你調用methord1，你會得到一個NameError錯誤，因為不存在abstract變量。(你也許會說這是欺騙，如果有人定義一個變量叫做abstract它就沒有效果了) 但是如果代碼中依賴的一個變量被人重定義的話，任何程序都難逃錯誤的命運。這裏唯一的區別就是我們依賴的是沒有定義的變量。</p>

<p>如果你願意寫abstract()替代abstract，那麽你可以定義一個函數拋出一個更有意義的NotImplementedError以取代NameError。(同樣，如果有人重定義abstract為零參數函數以外的任何東西，你還是會得到一個錯誤信息。)為了讓abstract的錯誤信息看起來舒服一點，只需去函數調用棧(stack frame)中看看誰是這個討厭的調用者:</p>

<pre><code>def abstract():
    import inspect
    caller = inspect.getouterframes(inspect.currentframe())[1][3]
    raise NotImplementedError(caller + ' must be implemented in subclass')
    ----------------------------------------------
&gt;&gt;&gt; MyDerivedClass().method1()
Traceback (most recent call last):
    ...
NotImplementedError: method1 must be implemented in subclass
</code></pre>

<h3>14 Q: 在Python中我怎麽實現枚舉類型呢?</h3>

<p>這個問題沒有一個答案，因為在Python中有好幾個答案，取決於你對枚舉的期望。如果你只是想有幾個變量，每個都有不同的整數值，你可以這樣:</p>

<pre><code>red, green, blue = range(3)
</code></pre>

<p>缺點是當你想在左邊添加一個新的變量，需要同時增加右邊的整數。不過這不算太壞，因為當你忘記的時候Python會拋出一個錯誤。如果你把枚舉隔離在類中可能更幹凈一點:</p>

<pre><code>class Colors:
    red, green, blue = range(3)
</code></pre>

<p>現在Colors.red會得到0, 並且dir(Colors)可能也能派上用場(雖然你還需要忽略__doc__和__module__兩項). 如果你想完全控制每個枚舉變量的值, 可以使用好幾個問題以前的Struct函數, 就像下面:</p>

<pre><code>Enum = Struct
Colors = Enum(red=0, green=100, blue=200)
</code></pre>

<p>盡管這些簡單的辦法通常已經夠了，可有人還想要更多。在 <a href="http://www.python.org/doc/essays/metaclasses/Enum.py">python.org</a>，<a href="http://aspn.activestate.com/ASPN/Cookbook/Python/Recipe/67107">ASPN</a>和<a href="http://www.faqts.com/knowledge_base/view.phtml/aid/4415">faqts</a>上都有枚舉類型的實現。下面是我的版本，它(幾乎)涵蓋所有人的需要，並且仍然保持合理的簡潔(一共44行，其中有22行代碼):</p>

<pre><code>class Enum:

    """創建一個可的枚舉類型, 然後給他添加變量/值對. 構造函數
    和.ints(names)方法接受變量名的列表並且將連續的整數賦予他們. 方法.strs(names)將每個變量名賦給它自己(就是說變量'v'有值'v'). 方法.vals(a=99, b=200) 讓你可以給任何變量賦任何值. "變量名列表"也可以是一個字符串, 它將被.split()分開. 方法.end()返回最大整數值加1,比如: opcode = Enum("add sub load store").vals(illegal=255)."""

    def __init__(self, names=[]): self.ints(names)

    def set(self, var, val):
    """Set var to the value val in the enum."""
        if var in vars(self).keys(): raise AttributeError("duplicate var in enum")
        if val in vars(self).values(): raise ValueError("duplicate value in enum")
        vars(self)[var] = val
        return self

    def strs(self, names):
    """Set each of the names to itself (as a string) in the enum."""
        for var in self._parse(names): self.set(var, var)
        return self

    def ints(self, names):
    """Set each of the names to the next highest int in the enum."""
        for var in self._parse(names): self.set(var, self.end())
        return self

    def vals(self, **entries):
    """Set each of var=val pairs in the enum."""
        for (var, val) in entries.items(): self.set(var, val)
        return self

    def end(self):
    """One more than the largest int value in the enum, or 0 if none."""
        try: return max([x for x in vars(self).values() if type(x)==type(0)]) + 1
        except ValueError: return 0

    def _parse(self, names):
    ### If names is a string, parse it as a list of names.
        if type(names) == type(""): return names.split()
        else: return names
</code></pre>

<p>下面是使用它的例子:</p>

<pre><code>&gt;&gt;&gt; opcodes = Enum("add sub load store").vals(illegal=255)
&gt;&gt;&gt; opcodes.add
  0
&gt;&gt;&gt; opcodes.illegal
  255
&gt;&gt;&gt; opcodes.end()
  256
&gt;&gt;&gt; dir(opcodes)
  ['add', 'illegal', 'load', 'store', 'sub']
&gt;&gt;&gt; vars(opcodes)
  {'store': 3, 'sub': 1, 'add': 0, 'illegal': 255, 'load': 2}
&gt;&gt;&gt; vars(opcodes).values()
  [3, 1, 0, 255, 2]
</code></pre>

<p>註意這些方法都是層疊(cascaded)的，在構造函數後你可以把.strs， .ints和.vals組合在一行代碼中。還要註意的dir和vals輔助使用，它們不會被任何東西幹擾, 除了你定義的變量。為了遍歷所有的枚舉值，你可以使用for x in vars(opcodes).values()。還有就是，如果你願意，可以使用非整數值來賦給枚舉變量。使用.strs和.vals方法就行了。最後，註意重復變量名和值都是一種錯誤。有時你可能想有一個重復的值(比如為了創建別名)。你可以刪掉拋出ValueError的那行，或者像這樣用:vars(opcodes)[&lsquo;first_op&rsquo;] = 0。這裏我最不喜歡的是很有可能把vals和value搞混。也許我可以給vals想一個更好的名字。</p>

<h3>15 Q: 為什麽Python中沒有"集合(Set)&ldquo;類型?</h3>

<p>當這個問題第一個發布在這裏的時候還沒有, 程序員們通常用字典來代替它. 但是在Python 2.4中有一個很好的內建<a href="http://docs.python.org/lib/types-set.html">set類型</a>。</p>

<h3>16 Q: 我能用布爾類型嗎?</h3>

<p>當這個問題第一次發布在這裏時，Python中還沒有布爾類型。現在嘛，Python 2.3以後都內建有一個<a href="http://docs.python.org/lib/node31.html">bool類型</a>。</p>

<h3>17 Q: Python中有能與(test?result:alternative)等價的操作嗎?</h3>

<p>Java和C++都有三目運算符(test?result:alternative)。Python一直拒絕它，但在將來的Python 2.5中，將允許(result if test else alternative)形式的表達式。這樣的結果是破壞了Python中表達式和語句清楚的區別，不過它是對許多人要求的妥協。</p>

<p>在Python 2.5到來前，你怎麽辦?這裏有幾個選擇:</p>

<ol>
<li>. 你可以試試[alternaticve, result][test]. 註意如果alternative和result中有遞歸調用或者昂貴的操作的話, 這個方法不太好, 因為它們兩個都會被求值. 如果test可以返回一個非布爾值, 那就下面這個</li>
<li>. [result, alternative][not test]. 這兩個的可讀性都很好.</li>
<li>. test and result or alternative 有人很習慣這樣，有人卻覺得它令人糊塗. 它只在能確認result非假後使用.</li>
<li>. (test and [result] or [alternative])[0] 避免了上面那個限制.</li>
<li>. [lambda: result, lambda: alternative][not not test]()擺脫了上面所有的限制(除了可讀性), 但別跟人家說是我告訴你這樣做的. 你甚至可以把它封裝在一個函數裏面. 公認的命名規範是, 對於模仿關鍵詞的變量, 在後面跟一個下劃線. 所以我們有:</li>
<li>. if_(test, result, lambda: alternative)
這裏我們定義</li>
</ol>


<hr />

<pre><code>def if_(test, result, alternative=None):
"If test is true, 'do' result, else alternative. 'Do' means call if callable."
    if test:
    if callable(result): result = result()
    return result
else:
    if callable(alternative): alternative = alternative()
    return alternative
--------------------------------------------------
&gt;&gt;&gt; fact = lambda n: if_(n &lt;= 1, 1, lambda: n *     fact(n-1))
&gt;&gt;&gt; fact(6)
720
</code></pre>

<ol>
<li>. 現在假定你因為某種原因, 與"if(test, &hellip;&ldquo;的語法相比, 就是更喜歡"if(test) &hellip;&rdquo;(並且, 你從來不想擺脫alternative那個部分). 你可以試試這個:</li>
</ol>


<hr />

<pre><code>def _if(test):
    return lambda alternative: \
               lambda result: \
                   [delay(result), delay(alternative)][not not test]()

def delay(f):
    if callable(f): return f
    else: return lambda: f
&gt;&gt;&gt; fact = lambda n: _if (n &lt;= 1) (1) (lambda: n *  fact(n-1))
&gt;&gt;&gt; fact(100)
93326215443944152681699238856266700490715968264381621468592963895217599993229915608941463976156518286253697920827223758251185210916864000000000000000000000000L
</code></pre>

<p>If u cn rd ths, u cn gt a jb in fncnl prg (if thr wr any)。(這個就不翻了吧:) )</p>

<h3>18 Q: 還有其他主要類型是Python缺少的嗎?</h3>

<p>關於Python，有一件很爽的事情就是你可以使用數字，字符串，列表，和字典(現在還有集合和布爾)就能走很遠。但是還有幾個主要類型是缺少的. 對我來說，最重要的是一個可變的字符串。一次又一次的使用str ＋＝ x 是很慢的，而維護字符組成的列表(或者子字符串的列表)意味著你放棄了一些很棒的字符串函數。一個可能的解決是array.array(&lsquo;c&rsquo;)。另一個是UserString.MutableString，盡管它本來的目的是用於教學而不是實踐。第三個是mmap模塊, 第四是cStringIO. 這些方法都不完美，不過加在一起也提供了足夠的選擇。最後，我發現我經常需要一個某種順序的隊列。標準庫中有一個<a href="http://www.python.org/doc/current/lib/module-Queue.html">Queue module</a>，但它是專用於線程的隊列。因為這裏有太多選項了，所以我就不為了實現一個標準隊列的去遊說了。不過呢，我將提供我實現的幾種隊列，FIFO，LIFO和優先隊列:</p>

<pre><code>"""
This module provides three types of queues, with these constructors:
  Stack([items])  -- Create a Last In First Out queue, implemented as a list
  Queue([items])  -- Create a First In First Out queue
  PriorityQueue([items]) -- Create a queue where minimum item (by &lt;) is first
Here [items] is an optional list of initial items; if omitted, queue is empty.
Each type supports the following methods and functions:
  len(q)          -- number of items in q (also q.__len__())
  q.append(item)  -- add an item to the queue
  q.extend(items) -- add each of the items to the queue
  q.pop()         -- remove and return the "first" item from the queue
"""

def Stack(items=None):
    "A stack, or last-in-first-out queue, is    implemented as a list."
    return items or []

class Queue:
    "A first-in-first-out queue."
    def __init__(self, items=None): self.start = 0;     self.A = items or []
    def __len__(self):                return    len(self.A) - self.start
    def append(self, item):             self.A.append(item)
    def extend(self, items):            self.A.extend(items)

    def pop(self):
        A = self.A
        item = A[self.start]
        self.start += 1
        if self.start &gt; 100 and self.start &gt; len(A)/2:
            del A[:self.start]
            self.start = 0
        return item

class PriorityQueue:
    "A queue in which the minimum element (as determined by cmp) is first."
    def __init__(self, items=None, cmp=operator.lt):
          self.A = []; self.cmp = cmp;
          if items: self.extend(items)

    def __len__(self): return len(self.A)

    def append(self, item):
        A, cmp = self.A, self.cmp
        A.append(item)
        i = len(A) - 1
        while i &gt; 0 and cmp(item, A[i//2]):
            A[i], i = A[i//2], i//2
        A[i] = item

    def extend(self, items):
        for item in items: self.append(item)

    def pop(self):
        A = self.A
        if len(A) == 1: return A.pop()
        e = A[0]
        A[0] = A.pop()
        self.heapify(0)
        return e

    def heapify(self, i):
        "Assumes A is an array whose left and right children are heaps,"
        "move A[i] into the correct position.  See CLR&amp;S p. 130"
        A, cmp = self.A, self.cmp
        left, right, N = 2*i + 1, 2*i + 2, len(A)-1
        if left &lt;= N and cmp(A[left], A[i]):
            smallest = left
        else:
            smallest = i
        if right &lt;= N and cmp(A[right], A[smallest]):
            smallest = right
        if smallest != i:
            A[i], A[smallest] = A[smallest], A[i]
            self.heapify(smallest)
</code></pre>

<p>註意一個技巧"items or []&ldquo;，下面這樣做是非常錯誤的</p>

<pre><code>def Stack(items=[]): return items
</code></pre>

<p>這是想說明默認值是一個空的列表。如果我們這樣作了，那麽不同的堆棧將會共享一個列表。通過使默認值為None(一個有效輸入之外的false值)，我們可以安排每個實例得到它自己的新列表。可能拒絕使用這個技巧的理由，在下面例子中，一個用戶這樣用</p>

<pre><code>s = Stack(items)
</code></pre>

<p>他可能覺得之後的s和items應該是相同的。但這是只會在發生在當items非空的時候。我認為這樣的反對理由是不太嚴重的，因為這裏並沒有什麽明確的承諾。(事實上，一個用戶也可能期望items保持不變，這只在item為空時候成立)。</p>

<h3>19 Q: 在Python裏面怎麽實現Singleton模式?</h3>

<p>我假定你的意思是：你希望一個類只可以被實例化一次，然後當你再次實例化時拋出一個異常。我知道的最簡單的辦法是定義一個函數施行這個想法，然後在你的類構造函數裏面調用這個函數:</p>

<pre><code>def singleton(object, instantiated=[]):
    "Raise an exception if an object of this class has been instantiated before."
    assert object.__class__ not in instantiated, \
        "%s is a Singleton class but is already instantiated" % object.__class__
    instantiated.append(object.__class__)

class YourClass:
    "A singleton class to do something ..."
    def __init__(self, args):
        singleton(self)
        ...
</code></pre>

<p>你也可以跟metaclass打交道，這樣你可以寫出class YourClass(Singletion)，但是為什麽自找麻煩呢?在"四人幫"把理論帶給我們以前，"singleton"(沒有那個公式化的名字)只是一個簡單的想法，剛好與一行簡單代碼相配，而不是一套信仰.</p>

<h3>20 Q: 沒有"news"是好消息嗎?</h3>

<p>我假設你的意思是Python沒有new關鍵字。的確是的。在C++中，new用來標記堆的分配而不是棧的。這時，這個關鍵字是有用的。在Java中，所有的對象都是在堆上分配的，所以new沒有真正的意義。它只是作為一個區別構造函數和其他靜態方法的提醒。但是這個區別可能對Java弊大於利，因為它是低層次的，它強迫實現代碼過早決定那些真正應該延後的東西。我想Python作出了正確的選擇，保持構造函數和一個普通函數調用使用相同的語法。</p>

<p>比如說，在有bool類出現之前，我們曾經想實現一個。為了跟內建的有所區別的，我們就叫它Bool。假設我們想實現這樣的想法:Bool類型只有一個true和一個false對象。一個辦法是把類名從Bool改為_Bool(這樣它不會被導出)，然後定義一個函數Bool:</p>

<pre><code>def Bool(val):
    if val: return true
    else: return false

true, false = _Bool(1), _Bool(0)
</code></pre>

<p>這就讓函數Bool變成_Bool對象的一個工廠(誠然是一個小得少見的工廠)。要點在於調用Bool(1)的程序員不應該知道或者關心返回的對象是一個新的還是回收的(至少對於不可變對象是這樣)。Python語法允許隱藏這個區別，但是Java語法不行。</p>

<p>在一些著作中這裏有點混淆。有些人使用術語"Singleton Pattern"稱呼這樣的工廠，因為這裏對構造函數的每個不同的參數有一個單獨的對象。和大多數人一樣，我贊同前一個問題中我下的定義。這個模式也可以封裝一個類型。我們可以叫它"CachedFactory"。這個想法來源於當你寫下</p>

<pre><code>class Bool:
    ... ## see here for Bool's definition

Bool = CachedFactory(Bool)
</code></pre>

<p>然後當你第一次調用Bool(1)，參數列表(1,)，得到原來的Bool類的代理。但是任何後續的對Bool(1)調用將返回第一個對象，它是被保存在緩存中：</p>

<pre><code>class CachedFactory:
    def __init__(self, klass):
        self.cache = {}
        self.klass = klass

    def __call__(self, *args):
        if self.cache.has_key(args):
            return self.cache[args]
        else:
            object = self.cache[args] = self.klass(*args)
            return object
</code></pre>

<p>需要註意的一件事情是，類和構造函數沒有任何其余的東西。這個模式將適用於所有可調用的對象。當擴展到普通的函數，它被稱作"Memoization Pattern"。實現代碼是一樣的，只是名字變了:</p>

<pre><code>class Memoize:
    def __init__(self, fn):
        self.cache = {}
        self.fn = fn

    def __call__(self, *args):
        if self.cache.has_key(args):
            return self.cache[args]
        else:
            object = self.cache[args] = self.fn(*args)
            return object
</code></pre>

<p>現在你可以寫下fact = Memoize(fact)，現在階乘運算的時間復雜度是分攤到每次調用的O(1)，而不是O(n)。</p>

<h3>21 Q: 我能有一個像shell裏面一樣的歷史記錄嗎?</h3>

<p>能。如果你要是這個麽?</p>

<pre><code>&gt;&gt;&gt; from shellhistory import h
h[2] &gt;&gt;&gt; 7*8
56
h[3] &gt;&gt;&gt; 9*9
81
h[4] &gt;&gt;&gt; h[2]
56
h[5] &gt;&gt;&gt; 'hello' + ' world'
'hello world'
h[6] &gt;&gt;&gt; h
[None, 9, 56, 81, 56, 'hello world']
h[7] &gt;&gt;&gt; h[5] * 2
'hello worldhello world'
h[8] &gt;&gt;&gt;  h[7] is _ is h[-1]
1
</code></pre>

<p>這是怎辦到的?變量sys.ps1是系統提示符，默認值是字符串'>>>&lsquo;，但是你可以設置成其它任何東西。如果你設置了一個非字符串對象，這個對象的__str__方法將被調用。所以我們將創建這麽一個對象，它的字符串方法把最近的結果(變量_)添加到一個叫h(代表history)的列表中, 然後返回一個包含列表長度，接著是&rsquo;>>>&lsquo;的提示字符串。至少原來計劃是這樣。結果是(在IDLE 2.2的Windows實現中)，sys.ps1.__str__被調用了三次，而不是提示符被打印前的一次。別問我為什麽。為了解決這個問題，只有當_不是歷史列表中最後一個元素時，我才加入它。而且我也不自討麻煩的把None加入歷史列表中了，因為它不會被Python的交互循環顯示。我還排除了向h自己中添加h，因為這樣的環形結構可以能會帶來打印和比較時的麻煩。另一個復雜因素是Python解釋器實際上是嘗試打印&rsquo;\n' + sys.ps1，(它本來應該單獨的打印'\n'，或者打印'\n' + str(sys.ps1))這就意味著sys.ps1也需要一個__radd__方法. 最後，如果Python session中(或者是在.python啟動文件中)一開始的輸入是導入我的第一版模塊，它將會失敗。在檢查了一番之後，我發現這是因為直到第一個表達式被求值以後，變量_才被綁定。所以我捕獲了_未綁定的異常。然後就有:</p>

<pre><code>import sys

h = [None]

class Prompt:
    "Create a prompt that stores results (i.e. _) in the array h."
    def __init__(self, str='h[%d] &gt;&gt;&gt; '):
        self.str = str;

    def __str__(self):
        try:
            if _ not in [h[-1], None, h]: h.append(_);
        except NameError:
            pass
        return self.str % len(h);

    def __radd__(self, other):
        return str(other) + str(self)

sys.ps1 = Prompt()
</code></pre>

<h3>22 Q: 怎麽得到我的函數的執行時間?</h3>

<p>下面是一個簡單的答案:</p>

<pre><code>def timer(fn, *args):
    "Time the application of fn to args. Return (result, seconds)."
    import time
    start = time.clock()
    return fn(*args), time.clock() - start
&gt;&gt;&gt;timer(max, range(1e6))
(999999, 0.4921875)
</code></pre>

<p>在我的utils module裏還有一個更復雜的答案。</p>

<h3>23 Q: 我的.python啟動文件是什麽樣子的?</h3>

<p>現在它是看起來像這樣，但是它已經改變了很多了:</p>

<pre><code>from __future__ import nested_scopes
import sys, os, string, time
from utils import *

################ Interactive Prompt and Debugging ################

try:
    import readline
except ImportError:
    print "Module readline not available."
else:
    import rlcompleter
    readline.parse_and_bind("tab: complete")

h = [None]

class Prompt:
    def __init__(self, str='h[%d] &gt;&gt;&gt; '):
        self.str = str;

    def __str__(self):
        try:
            if _ not in [h[-1], None, h]: h.append(_);
        except NameError:
           pass
        return self.str % len(h);

  def __radd__(self, other):
        return str(other) + str(self)


if os.environ.get('TERM') in [ 'xterm', 'vt100' ]:
    sys.ps1 = Prompt('\001\033[0:1;31m\002h[%d] &gt;&gt;&gt; \001\033[0m\002')
else:
    sys.ps1 = Prompt()
sys.ps2 = ''
</code></pre>

<p><a href="mailto:%20peter@norvig.com">Peter Norvig</a><br/>
<a href="http://norvig.com/python-iaq.html">Origin</a><br/>
<a href="http://pythonic.zoomquiet.io/data/20071017193806/index.html#11">中文翻譯</a></p>
]]></content>
  </entry>
  
</feed>
