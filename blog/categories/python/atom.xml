<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: python | Themis_Sword's Blog]]></title>
  <link href="http://www.aprilzephyr.com/blog/categories/python/atom.xml" rel="self"/>
  <link href="http://www.aprilzephyr.com/"/>
  <updated>2015-05-12T17:58:51+08:00</updated>
  <id>http://www.aprilzephyr.com/</id>
  <author>
    <name><![CDATA[Themis_Sword]]></name>
    <email><![CDATA[licong0419@outlook.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[The Python IAQ: Infrequently Answered Questions]]></title>
    <link href="http://www.aprilzephyr.com/blog/05052015/python-infrequently-answered-questions/"/>
    <updated>2015-05-05T13:02:30+08:00</updated>
    <id>http://www.aprilzephyr.com/blog/05052015/python-infrequently-answered-questions</id>
    <content type="html"><![CDATA[<h3>1 Q: 什麽是"少有回答的問題(Infrequently Answered Question)&ldquo; ?</h3>

<p>一個問題之所以很少有人回答，要麽是因為很少有人知道問題的答案，要麽是因為它涉及到一個晦澀而隱蔽的知識點(但可能是你關心的)。我過去認為是我在<a href="http://www.norvig.com/java-iaq.html">Java IAQ</a>中發明了這個詞組，但是它也出現在了以資料豐富而著稱的<a href="http://urbanlegends.about.com/library/weekly/aa082497.htm">About.com Urban Legends</a>網站上. 關於Python的FAQ有很多,但是Python的IAQ只有這一個。(&ldquo;少見問題列表"倒是有一些，其中一個是有諷刺意味的<a href="http://www.plethora.net/%7Eseebs/faqs/c-iaq.html">C</a>。)<!--more--></p>

<h3>2 Q: finally子句中的代碼每次都會被執行,對嗎?</h3>

<p>每次?應該說，幾乎每次。在try子句被執行後，無論是否出現異常，finally子句中的代碼都會被執行，即使調用了sys.exit. 不過如果程序沒有執行到finally子句的話，它就沒有辦法運行了。下面的代碼中，無論choice取何值，都會發生這樣的情況:</p>

<pre><code>try:
    if choice:
        while 1:
            pass
    else:
        print "Please pull the plug on your computer sometime soon..."
        time.sleep(60 * 60 * 24 * 365 * 10000)
finally:
    print "Finally ..."
</code></pre>

<h3>3 Q: 多態真是太棒了!無論一個列表(list)中的元素是什麽類型,我都可以用sort對它排序,對嗎?</h3>

<p>不對。考慮這種情況:</p>

<pre><code>&gt;&gt;&gt; x = [1, 1j]
&gt;&gt;&gt; x.sort()
Traceback (most recent call last):
  File "&lt;pyshell#13&gt;", line 1, in ?
    x.sort()
TypeError: cannot compare complex numbers using &lt;, &lt;=, &gt;, &gt;=
</code></pre>

<p>(1j是一個數，表示-1的平方根)問題在於:sort方法(在目前的實現中)使用__lt__方法來 比較元素的大小。而__lt__方法拒絕比較復數的大小(因為它們是不能排序的)。奇怪的是,complex.__lt__會毫不猶豫的比較復數與字符串，列表(list)和其他所有類型，除了復數。所以答案是,你可以對支持__lt__方法的對象序列(sequence)進行排序(當然如果將來實現變了，可能就是其它方法了)。</p>

<p>對於問題的地一部份，“多態真棒”，我同意。但是Python有時會讓使用多態變得困難，因為許多Python的類型(比如序列和數)的定義不太符合規則。</p>

<h3>4 Q: 在Python中我能寫++x和x++嗎?</h3>

<p>從語法上說，++x能， x++不能。但是從實際使用來說，別這樣做。這麽說什麽意思？<br/>
* 可以， ++x是合法的Python語法。不過如果你是一個C++或者Java程序員的話，它表示不是你想的那個意思。加號+是一個單目前綴操作符，所以++x被解析為+(+x),它表示的(至少對於數字來說)就是x。<br/>
* 不可以， x++本身就不是一個合法的表達式, 雖然在某些上下文時合法。比如， x++ -y被解析為x++(&ndash;(y)), 對於數字來說，等於x &ndash; y。當然，你可以創建一個類，讓++x有(很有限的)意義。比如可以讓這個類保存一個數字，然後使單目操作符+使它增加0.5(或者有0.5的概率增加1，如果你喜歡隨機化算法)，但是&hellip;<br/>
* 不可以，那樣真傻。最好還是用Python 2.0已經中加入的x += 1。
進一步的問題:為什麽Python不允許 x++？ 我相信原因與Python不允許在表達式中賦值一樣: Python想要清晰的區分語句和表達式。如果我覺得這兩者應該有所區別，那麽不允許++就是最好的決定。另一方面，函數語言的鼓吹者認為語句就應該是表達式。我跟我的丹麥老鄉，Bjarne Stroustrup，都這樣認為。他在The Design and Evolution of C++中說:“如果是從頭來設計一種語言的話，我會按照Algol68的方式，讓每條語句和聲明都是一個有返回值的表達式”。</p>

<h3>5 Q: 我能使用C++中對ostreams那樣的語法嗎，像這樣麽: count &lt;&lt; x &lt;&lt; y &hellip;?</h3>

<p>當然可以。如果你不喜歡寫"print x,y"，你可以試試這個：</p>

<pre><code>import sys

class ostream:
    def __init__(self, file):
        self.file = file

    def __lshift__(self, obj):
        self.file.write(str(obj));
        return self

cout = ostream(sys.stdout)
cerr = ostream(sys.stderr)
nl = '\n'
-----------------------------------
cout &lt;&lt; x &lt;&lt; " " &lt;&lt; y &lt;&lt; nl
</code></pre>

<p>(本文中所有的文件中的代碼都在橫線以上，使用這些代碼的例子在橫線以下。)這樣你就可以使用一種不同的語法了，但是它不能給你帶來一種新的輸出格式，它只是把Python中以有str的格式封裝了一層而已。這個做法很像Java裏面的toString()格式。C++使用的是一種迥異的格式：它沒有定義一組把對象轉換為字符串的規則，而定義了一種把對象打印到流的規則(也許是不完整的規則，因為很多C++程序仍然使用printf)。用流來實現會更加復雜，但是它的優勢在於如果你需要打印一個相當巨大的對象，就不用創建一個巨大的臨時對象來做這件事。</p>

<h3>6 Q: 如果我喜歡C++的printf呢?</h3>

<p>在Python中定義一個printf不是一個壞主意. 你可能認為printf(&ldquo;%d = %s&rdquo;, num, result)比print &ldquo;%d = %s&rdquo; % (num, result)更加自然, 因為那一對括號在更熟悉的位置(而且你不想要那個%)。更和況, 滿足這個需求輕而易舉:</p>

<pre><code>def printf(format, *args): print format % args,
</code></pre>

<p>即使是像這樣的一行代碼，也有幾個不同實現。首先，我必需要決定是否在結尾添加逗號。為了更像C++, 我決定加上(這就意味著如果你想在結尾換行，你需要自己在格式字符串的末尾添加)。其次，結尾處會打印一個空格。如果你不想要它，使用sys.stdout.write來代替print. 最後, 把一切都變得更像C好是一件好事嗎? 是，因為你需要一個打印函數(而不是一個打印語句)在只接受函數不接受語句的地方使用。比如，在lambda表達式中和map的第一個參數。事實上，這樣一個函數使用起來是很趁手的，你可能想要一個沒有格式化功能的:</p>

<pre><code>def prin(x): print x,
</code></pre>

<p>現在map(prin, seq)將打印seq中的每一個元素. 但是map(print, seq)是一個語法錯誤. 我曾經見過有些粗心大意的程序員(好吧, 沒錯, 我自己就是. 但是我知道我自己很粗心 )認為把這兩個函數合二為一是個好主意, 像這樣:</p>

<pre><code>def printf(format, *args): print str(format) % args,  
</code></pre>

<p>這樣 printf(42)， printf(&lsquo;A multi-line\n message&rsquo;)和 printf(&lsquo;%4.2f&rsquo;, 42)都能工作。但是當你用了pring(&lsquo;100% guaranteed&rsquo;)或者是其他任何含有%字符卻並不是一個格式化指令時，"好主意"就會變成"我想啥呢?&ldquo;。如果你真的實現了這麽一個printf，它需要這樣的註釋:</p>

<pre><code>def printf(format, *args): 
    """使用第一個參數作為格式字符串來格式化args, 然後打印. 
    如果format不是字符串, 將被str轉換成字符串. 如果x可能含
    有%和反斜線字符, 你必須使用printf('%s', x)來代替 printf(x).
    """ 
  print str(format) % args,
</code></pre>

<h3>7 Q: 關於字典(Dictionary)，有沒有更好的語法? 我使用的鍵(key)都是標識符.</h3>

<p>有!用一對引號來包括鍵的確是一件麻煩的事情，尤其當鍵是一個很長的字符串時. 起初我認為Python中加入特別的語法是有幫助的，用{a=1, b=2}來代替現在必需的{&lsquo;a&rsquo;:1, &lsquo;b&rsquo;:2}。在Python 2.3中，你可以用的語法是dict(a=1, b=2, c=3, dee=4)，這和我的想法一樣好。在Python 2.3以前，我使用一個只有一行的函數def Dict(**dict): return dict</p>

<p>一個讀者指出，對於散列Perl也有類似的特殊符號: 在Perl中對於散列文本，你可以寫(&ldquo;a&rdquo;, 1, &ldquo;b&rdquo;, 2)或者(a=>1, b=>2)。這是事實，但不是事實的全部。"man perlop"說"=>符號最多只是逗號操作符的同意詞&hellip;&ldquo;而且事實上當a和b是barewords時，你可以寫(a, 1, b, 2)。但是，就像Dag Asheim指出的，如果你打開strict，你將會從這個寫法中得到一個錯誤。你必須要麽使用字符串，要麽使用=>操作符。最後，Larry Wall已經申明，"Perl 6中將不會有bareword"。(關於perl的這以部分，我的翻譯可能有很大問題，因為我根本不會Perl!&mdash;譯註)</p>

<h3>8 Q: 那麽，對象有沒有類似的簡便辦法呢?</h3>

<p>的確是有的。如果你想要創建一個對象來把數據保存在不同的域中，下面的代碼就可以做到:</p>

<pre><code>class Struct:
    def __init__(self, **entries):      self.__dict__.update(entries)
&gt;&gt;&gt; globals = Struct(answer=42, linelen = 80,   font='courier')
&gt;&gt;&gt; globals.answer
42
&gt;&gt;&gt; globals.answer = 'plastics'
&gt;&gt;&gt; vars(globals)
{'answer': 'plastics', 'font': 'courier', 'linelen': 80}
</code></pre>

<p>從本質上說，我們在這裏做的是創建一個匿名類。好吧，我知道globals的類是 Struct，但是因為我們在它裏面添加了slots，就像是創建了一個新的，未命名的類(這和lambda創建匿名函數是很像的)。我討厭再給Struct添加什麽了，因為它現在很簡潔，不過如果你添加下面的方法，就可以漂亮打印出它的每個結構。</p>

<pre><code>def __repr__(self):
    args = ['%s=%s' % (k, repr(v)) for (k,v) in     vars(self).items()]
    return 'Struct(%s)' % ', '.join(args)
&gt;&gt;&gt; globals
------------------------------------------------
Struct(answer='plastics', font='courier', linelen=80)
</code></pre>

<h3>9 Q: 這樣創建新對象是很方便，但是要更新時怎麽辦呢?</h3>

<p>是這樣的，字典是有一個update方法的，所以當d是一個字典時，你可以用d.update(dict(a=100, b=200))。但是對象沒有對應的方法，所以你只能用obj.a = 100;obj.b = 200。或者你可以定義一個函數update(x, a=100, b=200)來更新x，無論它是字典還是對象都可以:</p>

<pre><code>import types

def update(x, **entries):
    if type(x) == types.DictType: x.update(entries)
    else: x.__dict__.update(entries)
    return x
</code></pre>

<p>把它用於構造函數特別漂亮:</p>

<pre><code>def __init__(self, a, b, c, d=42, e=None, f=()):
    update(self, a=a, b=b, c=c, d=d, e=e, f=f) 
</code></pre>

<h3>10 Q: 我能創建一個默認值為0或者[]的或者別的什麽的字典麽?</h3>

<p>如果你常常要對某個東西計數，咱們會有同感: count[x] ＋＝ 1比被迫用的count[x] = count.get(x, 0) + 1要優美許多。在Python 2.2以後，繼承內建的dict類可以輕松的搞定這個。我把它叫做我的DefaultDict。註意copy.deepcopy的使用: 有了它，就不會讓dict裏面的每個key都使用同一個[]作為默認值(雖然拷貝0浪費了一點時間，不過如果你使用更新和訪問比初始化更頻繁的話，還算可以接受):</p>

<pre><code>class DefaultDict(dict):
"""Dictionary with a default value for unknown keys."""
    def __init__(self, default):
        self.default = default

   def __getitem__(self, key):
        if key in self: return self.get(key)
        return self.setdefault(key, copy.deepcopy(self.default))
--------------------------------------
&gt;&gt;&gt; d = DefaultDict(0)
&gt;&gt;&gt; d['hello'] += 1
&gt;&gt;&gt; d
{'hello': 1}
&gt;&gt;&gt; d2 = DefaultDict([])
&gt;&gt;&gt; d2[1].append('hello')
&gt;&gt;&gt; d2[2].append('world')
&gt;&gt;&gt; d2[1].append('there')
&gt;&gt;&gt; d2
{1: ['hello', 'there'], 2: ['world']}

def bigrams(words):
    "Counts of word pairs, in a dict of dicts."
    d = DefaultDict(DefaultDict(0))
    for (w1, w2) in zip([None] + words, words + [None]):
        d[w1][w2] += 1
    return d

&gt;&gt;&gt; bigrams('i am what i am'.split())
{None: {'i': 1}, 'i': {'am': 2}, 'what': {'i': 1},  'am': {None: 1, 'what': 1}}
</code></pre>

<p>值得註意的是，如果沒有DefaultDict，bigram例子程序中的d[w1][w2] += 1就大概應該象這樣:</p>

<pre><code>d.setdefault(w1,{}).setdefault(w2, 0); d[w1][w2] += 1
</code></pre>

<h3>11 Q: 嘿，你能用0.0007KB或者更少的代碼做一個矩陣變換麽?</h3>

<p>我還以為你永遠不會問呢. 如果你用序列組成的序列來表示矩陣的話，用zip就可以搞定了:</p>

<pre><code>&gt;&gt;&gt; m = [(1,2,3), (4,5,6)] 
&gt;&gt;&gt; zip(*m) 
[(1, 4), (2, 5), (3, 6)]
</code></pre>

<p>要想理解它，你需要知道f(*m)就像於apply(f,m)。你問的是一個古老的Lisp問題，在Python中它的等價答案是map(None, *m)，但是用Chih-Chung Chang建議的zip版代碼會更短小。你可能認為這些代碼唯一的用處就是在Letterman的Stupid Programmer'sTricks(David Michael Letterman, 美國晚間脫口秀主持人，他主持的一個著名節目是Stupid Pet Tricks——譯註)中露臉，但是有一天我遇到了這個問題:有一個數據庫行的列表，每一行中都是排序過的值的列表。找出每一列中不重復的值，組成一個列表。我的答案是：</p>

<pre><code>possible_values = map(unique, zip(*db))  
</code></pre>

<h3>12 Q: 用f(*m)的技巧很酷. 有沒有同樣的語法可以用在方法調用上, 比如x.f(*y)?</h3>

<p>這個問題暴露一個錯誤的概念。根本就沒有方法調用的語法！Python語法中，有函數調用的，也有從對象中取得域的，也有綁定方法的。把這三者結合起來，就讓x.f(y)看起來像一塊單獨的語法，而事實上，它等價於(x.f)(y)，後者又等價於(getattr(x, &lsquo;f&rsquo;))(y)。我猜你可能不相信我，來看:</p>

<pre><code>class X:
    def f(self, y): return 2 * y
    --------------------------------------
&gt;&gt;&gt; x = X()
&gt;&gt;&gt; x.f
&lt;bound method X.f of &lt;__main__.X instance at 0x009C7DB0&gt;&gt;
&gt;&gt;&gt; y = 21
&gt;&gt;&gt; x.f(y)
42
&gt;&gt;&gt; (x.f)(y)
42
&gt;&gt;&gt; (getattr(x, 'f'))(y)
42
&gt;&gt;&gt; xf = x.f
&gt;&gt;&gt; xf(y)
42
&gt;&gt;&gt; map(x.f, range(5))
[0, 2, 4, 6, 8]
</code></pre>

<p>所以這個問題的答案是:你可以在方法調用中使用*y或**y(或者其他任何你可以放在函數調用中的)，因為方法調用就是函數調用。</p>

<h3>13 Q: 你能用用0行代碼實現Python的抽象類嗎? 4行呢?</h3>

<p>Java中有一個abstract關鍵詞。你可以用它來定義一個只能繼承不能被實例化的抽象類，該類中所有的抽象方法都需要你來實現。很少有人知道在Python中，你可以用幾乎一樣的方式使用abstract。不同的是，當你想要調用一個沒有實現的方式時，你得到的是一個運行時錯誤而不是編譯錯誤。比較下面的代碼:</p>

<pre><code>## Python
class MyAbstractClass:
    def method1(self): abstract

class MyClass(MyAbstractClass): 
    pass
    --------------------------------------
&gt;&gt;&gt; MyClass().method1()
Traceback (most recent call last):
    ...
NameError: name 'abstract' is not defined
</code></pre>

<p>==============================================</p>

<pre><code>    /* Java */
public abstract class MyAbstractClass {
    public abstract void method1();
}

class MyClass extends MyAbstractClass {}
----------------------------------------------
% javac MyAbstractClass
MyAbstractClass.java:5: 
  class MyClass must be declared abstract. 
  It does not define void method1() from class MyAbstractClass.
</code></pre>

<p>別花太多時間在Python語言參考手冊裏面尋找abstract關鍵字，它根本就不在那裏。我把它加入了Python語言中，並且最美妙的是，它的實現用了0行代碼! 當你調用methord1，你會得到一個NameError錯誤，因為不存在abstract變量。(你也許會說這是欺騙，如果有人定義一個變量叫做abstract它就沒有效果了) 但是如果代碼中依賴的一個變量被人重定義的話，任何程序都難逃錯誤的命運。這裏唯一的區別就是我們依賴的是沒有定義的變量。</p>

<p>如果你願意寫abstract()替代abstract，那麽你可以定義一個函數拋出一個更有意義的NotImplementedError以取代NameError。(同樣，如果有人重定義abstract為零參數函數以外的任何東西，你還是會得到一個錯誤信息。)為了讓abstract的錯誤信息看起來舒服一點，只需去函數調用棧(stack frame)中看看誰是這個討厭的調用者:</p>

<pre><code>def abstract():
    import inspect
    caller = inspect.getouterframes(inspect.currentframe())[1][3]
    raise NotImplementedError(caller + ' must be implemented in subclass')
    ----------------------------------------------
&gt;&gt;&gt; MyDerivedClass().method1()
Traceback (most recent call last):
    ...
NotImplementedError: method1 must be implemented in subclass
</code></pre>

<h3>14 Q: 在Python中我怎麽實現枚舉類型呢?</h3>

<p>這個問題沒有一個答案，因為在Python中有好幾個答案，取決於你對枚舉的期望。如果你只是想有幾個變量，每個都有不同的整數值，你可以這樣:</p>

<pre><code>red, green, blue = range(3)
</code></pre>

<p>缺點是當你想在左邊添加一個新的變量，需要同時增加右邊的整數。不過這不算太壞，因為當你忘記的時候Python會拋出一個錯誤。如果你把枚舉隔離在類中可能更幹凈一點:</p>

<pre><code>class Colors:
    red, green, blue = range(3)
</code></pre>

<p>現在Colors.red會得到0, 並且dir(Colors)可能也能派上用場(雖然你還需要忽略__doc__和__module__兩項). 如果你想完全控制每個枚舉變量的值, 可以使用好幾個問題以前的Struct函數, 就像下面:</p>

<pre><code>Enum = Struct
Colors = Enum(red=0, green=100, blue=200)
</code></pre>

<p>盡管這些簡單的辦法通常已經夠了，可有人還想要更多。在 <a href="http://www.python.org/doc/essays/metaclasses/Enum.py">python.org</a>，<a href="http://aspn.activestate.com/ASPN/Cookbook/Python/Recipe/67107">ASPN</a>和<a href="http://www.faqts.com/knowledge_base/view.phtml/aid/4415">faqts</a>上都有枚舉類型的實現。下面是我的版本，它(幾乎)涵蓋所有人的需要，並且仍然保持合理的簡潔(一共44行，其中有22行代碼):</p>

<pre><code>class Enum:

    """創建一個可的枚舉類型, 然後給他添加變量/值對. 構造函數
    和.ints(names)方法接受變量名的列表並且將連續的整數賦予他們. 方法.strs(names)將每個變量名賦給它自己(就是說變量'v'有值'v'). 方法.vals(a=99, b=200) 讓你可以給任何變量賦任何值. "變量名列表"也可以是一個字符串, 它將被.split()分開. 方法.end()返回最大整數值加1,比如: opcode = Enum("add sub load store").vals(illegal=255)."""

    def __init__(self, names=[]): self.ints(names)

    def set(self, var, val):
    """Set var to the value val in the enum."""
        if var in vars(self).keys(): raise AttributeError("duplicate var in enum")
        if val in vars(self).values(): raise ValueError("duplicate value in enum")
        vars(self)[var] = val
        return self

    def strs(self, names):
    """Set each of the names to itself (as a string) in the enum."""
        for var in self._parse(names): self.set(var, var)
        return self

    def ints(self, names):
    """Set each of the names to the next highest int in the enum."""
        for var in self._parse(names): self.set(var, self.end())
        return self

    def vals(self, **entries):
    """Set each of var=val pairs in the enum."""
        for (var, val) in entries.items(): self.set(var, val)
        return self

    def end(self):
    """One more than the largest int value in the enum, or 0 if none."""
        try: return max([x for x in vars(self).values() if type(x)==type(0)]) + 1
        except ValueError: return 0

    def _parse(self, names):
    ### If names is a string, parse it as a list of names.
        if type(names) == type(""): return names.split()
        else: return names
</code></pre>

<p>下面是使用它的例子:</p>

<pre><code>&gt;&gt;&gt; opcodes = Enum("add sub load store").vals(illegal=255)
&gt;&gt;&gt; opcodes.add
  0
&gt;&gt;&gt; opcodes.illegal
  255
&gt;&gt;&gt; opcodes.end()
  256
&gt;&gt;&gt; dir(opcodes)
  ['add', 'illegal', 'load', 'store', 'sub']
&gt;&gt;&gt; vars(opcodes)
  {'store': 3, 'sub': 1, 'add': 0, 'illegal': 255, 'load': 2}
&gt;&gt;&gt; vars(opcodes).values()
  [3, 1, 0, 255, 2]
</code></pre>

<p>註意這些方法都是層疊(cascaded)的，在構造函數後你可以把.strs， .ints和.vals組合在一行代碼中。還要註意的dir和vals輔助使用，它們不會被任何東西幹擾, 除了你定義的變量。為了遍歷所有的枚舉值，你可以使用for x in vars(opcodes).values()。還有就是，如果你願意，可以使用非整數值來賦給枚舉變量。使用.strs和.vals方法就行了。最後，註意重復變量名和值都是一種錯誤。有時你可能想有一個重復的值(比如為了創建別名)。你可以刪掉拋出ValueError的那行，或者像這樣用:vars(opcodes)[&lsquo;first_op&rsquo;] = 0。這裏我最不喜歡的是很有可能把vals和value搞混。也許我可以給vals想一個更好的名字。</p>

<h3>15 Q: 為什麽Python中沒有"集合(Set)&ldquo;類型?</h3>

<p>當這個問題第一個發布在這裏的時候還沒有, 程序員們通常用字典來代替它. 但是在Python 2.4中有一個很好的內建<a href="http://docs.python.org/lib/types-set.html">set類型</a>。</p>

<h3>16 Q: 我能用布爾類型嗎?</h3>

<p>當這個問題第一次發布在這裏時，Python中還沒有布爾類型。現在嘛，Python 2.3以後都內建有一個<a href="http://docs.python.org/lib/node31.html">bool類型</a>。</p>

<h3>17 Q: Python中有能與(test?result:alternative)等價的操作嗎?</h3>

<p>Java和C++都有三目運算符(test?result:alternative)。Python一直拒絕它，但在將來的Python 2.5中，將允許(result if test else alternative)形式的表達式。這樣的結果是破壞了Python中表達式和語句清楚的區別，不過它是對許多人要求的妥協。</p>

<p>在Python 2.5到來前，你怎麽辦?這裏有幾個選擇:</p>

<ol>
<li>. 你可以試試[alternaticve, result][test]. 註意如果alternative和result中有遞歸調用或者昂貴的操作的話, 這個方法不太好, 因為它們兩個都會被求值. 如果test可以返回一個非布爾值, 那就下面這個</li>
<li>. [result, alternative][not test]. 這兩個的可讀性都很好.</li>
<li>. test and result or alternative 有人很習慣這樣，有人卻覺得它令人糊塗. 它只在能確認result非假後使用.</li>
<li>. (test and [result] or [alternative])[0] 避免了上面那個限制.</li>
<li>. [lambda: result, lambda: alternative][not not test]()擺脫了上面所有的限制(除了可讀性), 但別跟人家說是我告訴你這樣做的. 你甚至可以把它封裝在一個函數裏面. 公認的命名規範是, 對於模仿關鍵詞的變量, 在後面跟一個下劃線. 所以我們有:</li>
<li>. if_(test, result, lambda: alternative)
這裏我們定義</li>
</ol>


<hr />

<pre><code>def if_(test, result, alternative=None):
"If test is true, 'do' result, else alternative. 'Do' means call if callable."
    if test:
    if callable(result): result = result()
    return result
else:
    if callable(alternative): alternative = alternative()
    return alternative
--------------------------------------------------
&gt;&gt;&gt; fact = lambda n: if_(n &lt;= 1, 1, lambda: n *     fact(n-1))
&gt;&gt;&gt; fact(6)
720
</code></pre>

<ol>
<li>. 現在假定你因為某種原因, 與"if(test, &hellip;&ldquo;的語法相比, 就是更喜歡"if(test) &hellip;&rdquo;(並且, 你從來不想擺脫alternative那個部分). 你可以試試這個:</li>
</ol>


<hr />

<pre><code>def _if(test):
    return lambda alternative: \
               lambda result: \
                   [delay(result), delay(alternative)][not not test]()

def delay(f):
    if callable(f): return f
    else: return lambda: f
&gt;&gt;&gt; fact = lambda n: _if (n &lt;= 1) (1) (lambda: n *  fact(n-1))
&gt;&gt;&gt; fact(100)
93326215443944152681699238856266700490715968264381621468592963895217599993229915608941463976156518286253697920827223758251185210916864000000000000000000000000L
</code></pre>

<p>If u cn rd ths, u cn gt a jb in fncnl prg (if thr wr any)。(這個就不翻了吧:) )</p>

<h3>18 Q: 還有其他主要類型是Python缺少的嗎?</h3>

<p>關於Python，有一件很爽的事情就是你可以使用數字，字符串，列表，和字典(現在還有集合和布爾)就能走很遠。但是還有幾個主要類型是缺少的. 對我來說，最重要的是一個可變的字符串。一次又一次的使用str ＋＝ x 是很慢的，而維護字符組成的列表(或者子字符串的列表)意味著你放棄了一些很棒的字符串函數。一個可能的解決是array.array(&lsquo;c&rsquo;)。另一個是UserString.MutableString，盡管它本來的目的是用於教學而不是實踐。第三個是mmap模塊, 第四是cStringIO. 這些方法都不完美，不過加在一起也提供了足夠的選擇。最後，我發現我經常需要一個某種順序的隊列。標準庫中有一個<a href="http://www.python.org/doc/current/lib/module-Queue.html">Queue module</a>，但它是專用於線程的隊列。因為這裏有太多選項了，所以我就不為了實現一個標準隊列的去遊說了。不過呢，我將提供我實現的幾種隊列，FIFO，LIFO和優先隊列:</p>

<pre><code>"""
This module provides three types of queues, with these constructors:
  Stack([items])  -- Create a Last In First Out queue, implemented as a list
  Queue([items])  -- Create a First In First Out queue
  PriorityQueue([items]) -- Create a queue where minimum item (by &lt;) is first
Here [items] is an optional list of initial items; if omitted, queue is empty.
Each type supports the following methods and functions:
  len(q)          -- number of items in q (also q.__len__())
  q.append(item)  -- add an item to the queue
  q.extend(items) -- add each of the items to the queue
  q.pop()         -- remove and return the "first" item from the queue
"""

def Stack(items=None):
    "A stack, or last-in-first-out queue, is    implemented as a list."
    return items or []

class Queue:
    "A first-in-first-out queue."
    def __init__(self, items=None): self.start = 0;     self.A = items or []
    def __len__(self):                return    len(self.A) - self.start
    def append(self, item):             self.A.append(item)
    def extend(self, items):            self.A.extend(items)

    def pop(self):
        A = self.A
        item = A[self.start]
        self.start += 1
        if self.start &gt; 100 and self.start &gt; len(A)/2:
            del A[:self.start]
            self.start = 0
        return item

class PriorityQueue:
    "A queue in which the minimum element (as determined by cmp) is first."
    def __init__(self, items=None, cmp=operator.lt):
          self.A = []; self.cmp = cmp;
          if items: self.extend(items)

    def __len__(self): return len(self.A)

    def append(self, item):
        A, cmp = self.A, self.cmp
        A.append(item)
        i = len(A) - 1
        while i &gt; 0 and cmp(item, A[i//2]):
            A[i], i = A[i//2], i//2
        A[i] = item

    def extend(self, items):
        for item in items: self.append(item)

    def pop(self):
        A = self.A
        if len(A) == 1: return A.pop()
        e = A[0]
        A[0] = A.pop()
        self.heapify(0)
        return e

    def heapify(self, i):
        "Assumes A is an array whose left and right children are heaps,"
        "move A[i] into the correct position.  See CLR&amp;S p. 130"
        A, cmp = self.A, self.cmp
        left, right, N = 2*i + 1, 2*i + 2, len(A)-1
        if left &lt;= N and cmp(A[left], A[i]):
            smallest = left
        else:
            smallest = i
        if right &lt;= N and cmp(A[right], A[smallest]):
            smallest = right
        if smallest != i:
            A[i], A[smallest] = A[smallest], A[i]
            self.heapify(smallest)
</code></pre>

<p>註意一個技巧"items or []&ldquo;，下面這樣做是非常錯誤的</p>

<pre><code>def Stack(items=[]): return items
</code></pre>

<p>這是想說明默認值是一個空的列表。如果我們這樣作了，那麽不同的堆棧將會共享一個列表。通過使默認值為None(一個有效輸入之外的false值)，我們可以安排每個實例得到它自己的新列表。可能拒絕使用這個技巧的理由，在下面例子中，一個用戶這樣用</p>

<pre><code>s = Stack(items)
</code></pre>

<p>他可能覺得之後的s和items應該是相同的。但這是只會在發生在當items非空的時候。我認為這樣的反對理由是不太嚴重的，因為這裏並沒有什麽明確的承諾。(事實上，一個用戶也可能期望items保持不變，這只在item為空時候成立)。</p>

<h3>19 Q: 在Python裏面怎麽實現Singleton模式?</h3>

<p>我假定你的意思是：你希望一個類只可以被實例化一次，然後當你再次實例化時拋出一個異常。我知道的最簡單的辦法是定義一個函數施行這個想法，然後在你的類構造函數裏面調用這個函數:</p>

<pre><code>def singleton(object, instantiated=[]):
    "Raise an exception if an object of this class has been instantiated before."
    assert object.__class__ not in instantiated, \
        "%s is a Singleton class but is already instantiated" % object.__class__
    instantiated.append(object.__class__)

class YourClass:
    "A singleton class to do something ..."
    def __init__(self, args):
        singleton(self)
        ...
</code></pre>

<p>你也可以跟metaclass打交道，這樣你可以寫出class YourClass(Singletion)，但是為什麽自找麻煩呢?在"四人幫"把理論帶給我們以前，"singleton"(沒有那個公式化的名字)只是一個簡單的想法，剛好與一行簡單代碼相配，而不是一套信仰.</p>

<h3>20 Q: 沒有"news"是好消息嗎?</h3>

<p>我假設你的意思是Python沒有new關鍵字。的確是的。在C++中，new用來標記堆的分配而不是棧的。這時，這個關鍵字是有用的。在Java中，所有的對象都是在堆上分配的，所以new沒有真正的意義。它只是作為一個區別構造函數和其他靜態方法的提醒。但是這個區別可能對Java弊大於利，因為它是低層次的，它強迫實現代碼過早決定那些真正應該延後的東西。我想Python作出了正確的選擇，保持構造函數和一個普通函數調用使用相同的語法。</p>

<p>比如說，在有bool類出現之前，我們曾經想實現一個。為了跟內建的有所區別的，我們就叫它Bool。假設我們想實現這樣的想法:Bool類型只有一個true和一個false對象。一個辦法是把類名從Bool改為_Bool(這樣它不會被導出)，然後定義一個函數Bool:</p>

<pre><code>def Bool(val):
    if val: return true
    else: return false

true, false = _Bool(1), _Bool(0)
</code></pre>

<p>這就讓函數Bool變成_Bool對象的一個工廠(誠然是一個小得少見的工廠)。要點在於調用Bool(1)的程序員不應該知道或者關心返回的對象是一個新的還是回收的(至少對於不可變對象是這樣)。Python語法允許隱藏這個區別，但是Java語法不行。</p>

<p>在一些著作中這裏有點混淆。有些人使用術語"Singleton Pattern"稱呼這樣的工廠，因為這裏對構造函數的每個不同的參數有一個單獨的對象。和大多數人一樣，我贊同前一個問題中我下的定義。這個模式也可以封裝一個類型。我們可以叫它"CachedFactory"。這個想法來源於當你寫下</p>

<pre><code>class Bool:
    ... ## see here for Bool's definition

Bool = CachedFactory(Bool)
</code></pre>

<p>然後當你第一次調用Bool(1)，參數列表(1,)，得到原來的Bool類的代理。但是任何後續的對Bool(1)調用將返回第一個對象，它是被保存在緩存中：</p>

<pre><code>class CachedFactory:
    def __init__(self, klass):
        self.cache = {}
        self.klass = klass

    def __call__(self, *args):
        if self.cache.has_key(args):
            return self.cache[args]
        else:
            object = self.cache[args] = self.klass(*args)
            return object
</code></pre>

<p>需要註意的一件事情是，類和構造函數沒有任何其余的東西。這個模式將適用於所有可調用的對象。當擴展到普通的函數，它被稱作"Memoization Pattern"。實現代碼是一樣的，只是名字變了:</p>

<pre><code>class Memoize:
    def __init__(self, fn):
        self.cache = {}
        self.fn = fn

    def __call__(self, *args):
        if self.cache.has_key(args):
            return self.cache[args]
        else:
            object = self.cache[args] = self.fn(*args)
            return object
</code></pre>

<p>現在你可以寫下fact = Memoize(fact)，現在階乘運算的時間復雜度是分攤到每次調用的O(1)，而不是O(n)。</p>

<h3>21 Q: 我能有一個像shell裏面一樣的歷史記錄嗎?</h3>

<p>能。如果你要是這個麽?</p>

<pre><code>&gt;&gt;&gt; from shellhistory import h
h[2] &gt;&gt;&gt; 7*8
56
h[3] &gt;&gt;&gt; 9*9
81
h[4] &gt;&gt;&gt; h[2]
56
h[5] &gt;&gt;&gt; 'hello' + ' world'
'hello world'
h[6] &gt;&gt;&gt; h
[None, 9, 56, 81, 56, 'hello world']
h[7] &gt;&gt;&gt; h[5] * 2
'hello worldhello world'
h[8] &gt;&gt;&gt;  h[7] is _ is h[-1]
1
</code></pre>

<p>這是怎辦到的?變量sys.ps1是系統提示符，默認值是字符串'>>>&lsquo;，但是你可以設置成其它任何東西。如果你設置了一個非字符串對象，這個對象的__str__方法將被調用。所以我們將創建這麽一個對象，它的字符串方法把最近的結果(變量_)添加到一個叫h(代表history)的列表中, 然後返回一個包含列表長度，接著是&rsquo;>>>&lsquo;的提示字符串。至少原來計劃是這樣。結果是(在IDLE 2.2的Windows實現中)，sys.ps1.__str__被調用了三次，而不是提示符被打印前的一次。別問我為什麽。為了解決這個問題，只有當_不是歷史列表中最後一個元素時，我才加入它。而且我也不自討麻煩的把None加入歷史列表中了，因為它不會被Python的交互循環顯示。我還排除了向h自己中添加h，因為這樣的環形結構可以能會帶來打印和比較時的麻煩。另一個復雜因素是Python解釋器實際上是嘗試打印&rsquo;\n' + sys.ps1，(它本來應該單獨的打印'\n'，或者打印'\n' + str(sys.ps1))這就意味著sys.ps1也需要一個__radd__方法. 最後，如果Python session中(或者是在.python啟動文件中)一開始的輸入是導入我的第一版模塊，它將會失敗。在檢查了一番之後，我發現這是因為直到第一個表達式被求值以後，變量_才被綁定。所以我捕獲了_未綁定的異常。然後就有:</p>

<pre><code>import sys

h = [None]

class Prompt:
    "Create a prompt that stores results (i.e. _) in the array h."
    def __init__(self, str='h[%d] &gt;&gt;&gt; '):
        self.str = str;

    def __str__(self):
        try:
            if _ not in [h[-1], None, h]: h.append(_);
        except NameError:
            pass
        return self.str % len(h);

    def __radd__(self, other):
        return str(other) + str(self)

sys.ps1 = Prompt()
</code></pre>

<h3>22 Q: 怎麽得到我的函數的執行時間?</h3>

<p>下面是一個簡單的答案:</p>

<pre><code>def timer(fn, *args):
    "Time the application of fn to args. Return (result, seconds)."
    import time
    start = time.clock()
    return fn(*args), time.clock() - start
&gt;&gt;&gt;timer(max, range(1e6))
(999999, 0.4921875)
</code></pre>

<p>在我的utils module裏還有一個更復雜的答案。</p>

<h3>23 Q: 我的.python啟動文件是什麽樣子的?</h3>

<p>現在它是看起來像這樣，但是它已經改變了很多了:</p>

<pre><code>from __future__ import nested_scopes
import sys, os, string, time
from utils import *

################ Interactive Prompt and Debugging ################

try:
    import readline
except ImportError:
    print "Module readline not available."
else:
    import rlcompleter
    readline.parse_and_bind("tab: complete")

h = [None]

class Prompt:
    def __init__(self, str='h[%d] &gt;&gt;&gt; '):
        self.str = str;

    def __str__(self):
        try:
            if _ not in [h[-1], None, h]: h.append(_);
        except NameError:
           pass
        return self.str % len(h);

  def __radd__(self, other):
        return str(other) + str(self)


if os.environ.get('TERM') in [ 'xterm', 'vt100' ]:
    sys.ps1 = Prompt('\001\033[0:1;31m\002h[%d] &gt;&gt;&gt; \001\033[0m\002')
else:
    sys.ps1 = Prompt()
sys.ps2 = ''
</code></pre>

<p><a href="mailto:%20peter@norvig.com">Peter Norvig</a><br/>
<a href="http://norvig.com/python-iaq.html">Origin</a><br/>
<a href="http://pythonic.zoomquiet.io/data/20071017193806/index.html#11">中文翻譯</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Python 正則表達式指南(轉)]]></title>
    <link href="http://www.aprilzephyr.com/blog/05042014/python-zheng-ze-biao-da-shi-zhi-nan-zhuan/"/>
    <updated>2014-05-04T14:49:04+08:00</updated>
    <id>http://www.aprilzephyr.com/blog/05042014/python-zheng-ze-biao-da-shi-zhi-nan-zhuan</id>
    <content type="html"><![CDATA[<h4>1. 正則表達式基礎</h4>

<h5>1.1 簡單介紹</h5>

<p>正則表達式並不是Python的一部分。正則表達式是用於處理字符串的強大工具，擁有自己獨特的語法以及一個獨立的處理引擎，效率上可能不如str自帶的方法，但功能十分強大。得益於這一點，在提供了正則表達式的語言裏，正則表達式的語法都是一樣的，區別只在於不同的編程語言實現支持的語法數量不同；但不用擔心，不被支持的語法通常是不常用的部分。如果已經在其他語言裏使用過正則表達式，只需要簡單看一看就可以上手了。</p>

<p>下圖展示了使用正則表達式進行匹配的流程：<!--more--><br/>
<img src="/images/zhengzbds.png"></p>

<p>正則表達式的大致匹配過程是：依次拿出表達式和文本中的字符比較，如果每一個字符都能匹配，則匹配成功；一旦有匹配不成功的字符則匹配失敗。如果表達式中有量詞或邊界，這個過程會稍微有一些不同，但也是很好理解的，看下圖中的示例以及自己多使用幾次就能明白。</p>

<p>下錶列出了Python支持的正則表達式元字符和語法：</p>

<table><tbody>
<tr><td><em> 語法 </em></td><td><em> 說明 </em></td><td><em> 表達式實例 </em></td><td><em> 完整匹配的字符串 </em></td></tr>
<tr><td></td><td><em> 字符 </em><td></td></td><td></td></tr>
<tr><td> 一般字符 </td><td> 匹配自身 </td><td> abc </td><td> abc </td></tr>
<tr><td> . </td><td> 匹配任意除換行符"\n"外的字符。在DOTALL模式中也能匹配換行符 </td><td> a.c </td><td> abc </td></tr>
<tr><td> \ </td><td> 轉義字符，使後一個字符改變原來的意思。如果字符串中有字符*需要匹配，可以使用\*或者字符集[*] </td><td> a\.c a\\c </td><td> a.c a\c </td></tr>
<tr><td> [...] </td><td> 字符集(字符類)。對應的位置可以是字符集中任意字符。字符集中的字符可以逐個列出，也可以給出範圍，如[abc]或[a-c]。第一個字符如果是^則表示取反，如[^abc]表示不是abc的其他字符。 所有的特殊字符在字符集中都失去原油的特殊含義。在字符集中如果要使用]、-或^，可以在前面加上反斜槓，或把]、-放在第一個字符，把^放在非第一個字符 </td><td> a[bdc]e </td><td> abe ace ade </td></tr>
<tr><td></td><td><em> 預定義字符集(可以寫在字符集[...]中) </em><td></td></td><td></td></tr>
<tr><td> \d </td><td> 數字:[0-9] </td><td> a\dc </td><td> a1c </td></tr>
<tr><td> \D </td><td> 非數字:[^\d] </td><td> a\Dc </td><td> abc </td></tr>
<tr><td> \s </td><td> 非白字符:[<空格>\t\r\n\f\v] </td><td> a\sc </td><td> a c </td></tr>
<tr><td> \S </td><td> 非空白字符:[^\s] </td><td> a\Sc </td><td> abc </td></tr>
<tr><td> \w </td><td> 單詞字符:[A-Z a-z 0-9] </td><td> a\wc </td><td> abc </td></tr>
<tr><td> \W </td><td> 非單詞字符:[^\W] </td><td> a\Wc </td><td> a c </td></tr>
<tr><td></td><td><em> 數量詞(用在字符或(...)之後) </em><td></td></td><td></td></tr>
<tr><td> * </td><td> 匹配前一個字符0或無限次 </td><td> abc* </td><td> ab abccc </td></tr>
<tr><td> + </td><td> 匹配前一個字符1或無限次 </td><td> abc+ </td><td> abc abccc </td></tr>
<tr><td> ? </td><td> 匹配前一個字符0或1次 </td><td> abc? </td><td> ab abc </td></tr>
<tr><td> {m} </td><td> 匹配前一個字符m次 </td><td> ab{2}c </td><td> abbc </td></tr>
<tr><td> {m,n} </td><td> 匹配前一個字符m至n次。m和n可以省略：若省略m，則匹配0至n次；若省略n，則匹配m至無限次 </td><td> ab{1,2}c </td><td> abc abbc </td></tr>
<tr><td> \*?+? ?? {m,n}? </td><td> 使*+?{m,n}變成非貪婪模式 </td><td> 示例在下文中介紹 </td><td> </td></tr>
<tr><td></td><td><em> 邊界匹配(不消耗待匹配字符串中的字符) </em><td></td></td><td></td></tr>
<tr><td> ^ </td><td> 匹配字符串開頭。在多行模式中匹配每一行的開頭。 </td><td> ^abc </td><td> abc </td></tr>
<tr><td> $ </td><td> 匹配字符串末尾。在多行模式中匹配每一行的末尾。 </td><td> abc$ </td><td> abc </td></tr>
<tr><td> \A </td><td> 儘匹配字符串開頭。 </td><td> \Aabc </td><td> abc </td></tr>
<tr><td> \Z </td><td> 儘匹配字符串末尾。 </td><td> \Zabc </td><td> abc </td></tr>
<tr><td> \b </td><td> 匹配\w和\W之間。 </td><td> a\b!bc </td><td> a!bc </td></tr>
<tr><td> \B </td><td> [^\b] </td><td> a\Bbc </td><td> abc </td></tr>
<tr><td></td><td><em> 邏輯、分組 </em><td></td></td><td></td></tr>
<tr><td> | </td><td> |代表左右表達式任意匹配一個。總是先嘗試匹配左邊的表達式，一旦成功匹配則跳過匹配右邊的表達式。如果|沒有被包括在()中，則它的範圍是整個正則表達式。 </td><td> abc|def </td><td> abc def </td></tr>
<tr><td> (...) </td><td> 被擴起來的表達式將作為分組，從表達式左邊開始每遇到一個分組的左括號'('，編號+1。另外，分組表達式作為一個整體，可以後接數量詞。表達式中的|儘在該組中有效。 </td><td> (abc){2} a(123|456)c </td><td> abcabc a456c </td></tr>
<tr><td> (?P<name>...) </td><td> 分組，除了原有的編號外再指定一個額外的別名。 </td><td> (?P<id>abc){2} </td><td> abcabc </td></tr>
<tr><td> \<number> </td><td> 引用編號為<number>的分組匹配到的字符串 </td><td> (\d)abc\1 </td><td> 1abc1 5abc5 </td></tr>
<tr><td> (?P=name) </td><td> 引用別名為<name>的分組匹配到的字符串。 </td><td> (?P<id>\d)abc(?P=id) </td><td> 1abc 5abc5 </td></tr>
<tr><td></td><td><em> 特殊構造(不作為分組) </em><td></td></td><td></td></tr>
<tr><td> (?:...) </td><td> (...)的不分組版本，用於使用'|'或後接數量詞 </td><td> (?:abc){2} </td><td> abc abc </td></tr>
<tr><td> (?iLmsux) </td><td> iLmsux的每個字符串代表一個匹配模式，只能用在正則表達式的開頭，可選多個。匹配模式將在下文中介紹。 </td><td> (?i)(abc) </td><td> AbC </td></tr>
<tr><td> (?#...) </td><td> #後的內容將作為註釋被忽略 </td><td> abc(?#comment)123 </td><td> abc123 </td></tr>
<tr><td> (?=...) </td><td> 之後的字符串內容需要匹配表達式才能成功匹配。不消耗字符串內容。 </td><td> abc(?=\d) </td><td> 後面是數字的a </td></tr>
<tr><td> (?!...) </td><td> 之後的字符串內容需要不匹配表達式才能成功匹配。不消耗字符串內容。 </td><td> abc(?!\d) </td><td> 後面不是數字的a </td></tr>
<tr><td> (?<=...) </td><td> 之前的字符串內容需要匹配表達式才能成功匹配。不消耗字符串內容。 </td><td> (?<=\d)a </td><td> 前面是數字的a </td></tr>
<tr><td> (?< !...) </td><td> 之前的字符串內容需要不匹配表達式才能成功匹配。不消耗字符串內容。 </td><td> (?<!\d)a </td><td> 前面不是數字的a </td></tr>
<tr><td> (?(id/name)yes-pattern|no-pattern) </td><td> 如果編號為id/別名為name的組匹配到字符，則需要皮皮yes-pattern，否則需要匹配no-pattern。 |np-pattern可以省略。 </td><td> (\d)abc(?(1)\d|abc) </td><td> 1abc2 abcabc </td></tr>
</tbody></table>


<p></p>

<h5>1.2 數量詞的貪婪模式與非貪婪模式</h5>

<p>正則表達式通常用於在文本中查找匹配的字符串。Python裏數量詞默認是貪婪的（在少數語言裏也可能是默認非貪婪），總是嘗試匹配盡可能多的字符；非貪婪的則相反，總是嘗試匹配盡可能少的字符。例如：正則表達式"a*&ldquo;如果用於查找"abbbc"，將找到"abbb"。而如果使用非貪婪的數量詞"ab*?"，將找到"a"。</p>

<h5>1.3. 反斜杠的困擾</h5>

<p>與大多數編程語言相同，正則表達式裏使用"\&ldquo;作為轉義字符，這就可能造成反斜杠困擾。假如你需要匹配文本中的字符&rdquo;\&ldquo;，那麽使用編程語言表示的正則表達式裏將需要4個反斜杠&rdquo;\\\\&ldquo;：前兩個和後兩個分別用於在編程語言裏轉義成反斜杠，轉換成兩個反斜杠後再在正則表達式裏轉義成一個反斜杠。Python裏的原生字符串很好地解決了這個問題，這個例子中的正則表達式可以使用r&rdquo;\\&ldquo;表示。同樣，匹配一個數字的&rdquo;\\d"可以寫成r"\d"。有了原生字符串，你再也不用擔心是不是漏寫了反斜杠，寫出來的表達式也更直觀。</p>

<h5>1.4. 匹配模式</h5>

<p>正則表達式提供了一些可用的匹配模式，比如忽略大小寫、多行匹配等，這部分內容將在Pattern類的工廠方法re.compile(pattern[, flags])中一起介紹。</p>

<h4>2. re模塊</h4>

<h5>2.1 開始使用re</h5>

<p>Python通過re模塊提供對正則表達式的支持。使用re的一般步驟是先將正則表達式的字符串形式編譯為Pattern實例，然後使用Pattern實例處理文本並獲得匹配結果（一個Match實例），最後使用Match實例獲得信息，進行其他的操作。<br/>
``` python</p>

<h1>encoding: UTF-8</h1>

<p>import re</p>

<h1>将正则表达式编译成Pattern对象</h1>

<p>pattern = re.compile(r'hello')</p>

<h1>使用Pattern匹配文本，获得匹配结果，无法匹配时将返回None</h1>

<p>match = pattern.match(&lsquo;hello world!&rsquo;)</p>

<p>if match:</p>

<pre><code># 使用Match获得分组信息
print match.group()
</code></pre>

<h3>输出</h3>

<h1>hello</h1>

<p>```</p>

<p><strong>re.compile(strPattern[, flag]):</strong><br/>
這個方法是Pattern類的工廠方法，用於將字符串形式的正則表達式編譯為Pattern對象。 第二個參數flag是匹配模式，取值可以使用按位或運算符'|&lsquo;表示同時生效，比如re.I | re.M。另外，你也可以在regex字符串中指定模式，比如re.compile('pattern&rsquo;, re.I | re.M)與re.compile(&lsquo;(?im)pattern&rsquo;)是等價的。
可選值有：<br/>
* re.I(re.IGNORECASE): 忽略大小寫（括號內是完整寫法，下同）<br/>
* M(MULTILINE): 多行模式，改變'^&lsquo;和&rsquo;$&lsquo;的行為（參見上圖）<br/>
* S(DOTALL): 點任意匹配模式，改變&rsquo;.&lsquo;的行為<br/>
* L(LOCALE): 使預定字符類 \w \W \b \B \s \S 取決於當前區域設定<br/>
* U(UNICODE): 使預定字符類 \w \W \b \B \s \S \d \D 取決於unicode定義的字符屬性<br/>
* X(VERBOSE): 詳細模式。這個模式下正則表達式可以是多行，忽略空白字符，並可以加入註釋。以下兩個正則表達式是等價的：<br/>
``` python
a = re.compile(r"&ldquo;&rdquo;\d +  # the integral part</p>

<pre><code>               \.    # the decimal point
               \d *  # some fractional digits""", re.X)
</code></pre>

<p>b = re.compile(r"\d+.\d<em>&ldquo;)
<code>  
re提供了眾多模塊方法用於完成正則表達式的功能。這些方法可以使用Pattern實例的相應方法替代，唯一的好處是少寫一行re.compile()代碼，但同時也無法復用編譯後的Pattern對象。這些方法將在Pattern類的實例方法部分一起介紹。如上面這個例子可以簡寫為：  
</code> python
m = re.match(r'hello', &lsquo;hello world!&rsquo;)
print m.group()
```<br/>
re模塊還提供了一個方法escape(string)，用於將string中的正則表達式元字符如</em>/+/?等之前加上轉義符再返回，在需要大量匹配元字符時有那麽一點用。</p>

<h5>2.2 Match</h5>

<p>Match对象是一次匹配的结果，包含了很多关于此次匹配的信息，可以使用Match提供的可读属性或方法来获取这些信息。</p>

<p>属性：<br/>
1) string: 匹配时使用的文本。<br/>
2) re: 匹配时使用的Pattern对象。<br/>
3) pos: 文本中正则表达式开始搜索的索引。值与Pattern.match()和Pattern.seach()方法的同名参数相同。<br/>
4) endpos: 文本中正则表达式结束搜索的索引。值与Pattern.match()和Pattern.seach()方法的同名参数相同。<br/>
5) lastindex: 最后一个被捕获的分组在文本中的索引。如果没有被捕获的分组，将为None。<br/>
6) lastgroup: 最后一个被捕获的分组的别名。如果这个分组没有别名或者没有被捕获的分组，将为None。</p>

<p>方法：<br/>
1) <strong>group([group1, …]):</strong> <br/>
获得一个或多个分组截获的字符串；指定多个参数时将以元组形式返回。group1可以使用编号也可以使用别名；编号0代表整个匹配的子串；不填写参数时，返回group(0)；没有截获字符串的组返回None；截获了多次的组返回最后一次截获的子串。<br/>
2) <strong>groups([default]):</strong><br/>
以元组形式返回全部分组截获的字符串。相当于调用group(1,2,…last)。default表示没有截获字符串的组以这个值替代，默认为None。<br/>
3) <strong>groupdict([default]):</strong><br/>
返回以有别名的组的别名为键、以该组截获的子串为值的字典，没有别名的组不包含在内。default含义同上。<br/>
4) <strong>start([group]):</strong><br/>
返回指定的组截获的子串在string中的起始索引（子串第一个字符的索引）。group默认值为0。<br/>
5) <strong>end([group]):</strong><br/>
返回指定的组截获的子串在string中的结束索引（子串最后一个字符的索引+1）。group默认值为0。<br/>
6) <strong>span([group]):</strong><br/>
返回(start(group), end(group))。<br/>
7) <strong>expand(template):</strong><br/>
将匹配到的分组代入template中然后返回。template中可以使用\id或\g<id>、\g<name>引用分组，但不能使用编号0。\id与\g<id>是等价的；但\10将被认为是第10个分组，如果你想表达\1之后是字符'0'，只能使用\g<1>0。<br/>
``` python
import re
m = re.match(r'(\w+) (\w+)(?P<sign>.*)&lsquo;, 'hello world!&rsquo;)</p>

<p>print &ldquo;m.string:&rdquo;, m.string
print &ldquo;m.re:&rdquo;, m.re
print &ldquo;m.pos:&rdquo;, m.pos
print &ldquo;m.endpos:&rdquo;, m.endpos
print &ldquo;m.lastindex:&rdquo;, m.lastindex
print &ldquo;m.lastgroup:&rdquo;, m.lastgroup</p>

<p>print &ldquo;m.group(1,2):&rdquo;, m.group(1, 2)
print &ldquo;m.groups():&rdquo;, m.groups()
print &ldquo;m.groupdict():&rdquo;, m.groupdict()
print &ldquo;m.start(2):&rdquo;, m.start(2)
print &ldquo;m.end(2):&rdquo;, m.end(2)
print &ldquo;m.span(2):&rdquo;, m.span(2)
print r"m.expand(r'\2 \1\3'):&ldquo;, m.expand(r'\2 \1\3')</p>

<h3>output</h3>

<h1>m.string: hello world!</h1>

<h1>m.re: &lt;_sre.SRE_Pattern object at 0x016E1A38></h1>

<h1>m.pos: 0</h1>

<h1>m.endpos: 12</h1>

<h1>m.lastindex: 3</h1>

<h1>m.lastgroup: sign</h1>

<h1>m.group(1,2): (&lsquo;hello&rsquo;, &lsquo;world&rsquo;)</h1>

<h1>m.groups(): (&lsquo;hello&rsquo;, &lsquo;world&rsquo;, &lsquo;!&rsquo;)</h1>

<h1>m.groupdict(): {&lsquo;sign&rsquo;: &lsquo;!&rsquo;}</h1>

<h1>m.start(2): 6</h1>

<h1>m.end(2): 11</h1>

<h1>m.span(2): (6, 11)</h1>

<h1>m.expand(r'\2 \1\3'): world hello!</h1>

<p>```</p>

<h5>2.3 Pattern</h5>

<p>Pattern對象是一個編譯好的正則表達式，通過Pattern提供的一系列方法可以對文本進行匹配查找。<br/>
Pattern不能直接實例化，必須使用re.compile()進行構造。<br/>
Pattern提供了幾個可讀屬性用於獲取表達式的相關信息：<br/>
1) pattern: 編譯時用的表達式字符串。<br/>
2) flags: 編譯時用的匹配模式。數字形式。<br/>
3) groups: 表達式中分組的數量。<br/>
4) groupindex: 以表達式中有別名的組的別名為鍵、以該組對應的編號為值的字典，沒有別名的組不包含在內。<br/>
``` python
import re
p = re.compile(r'(\w+) (\w+)(?P<sign>.*)&lsquo;, re.DOTALL)</p>

<p>print &ldquo;p.pattern:&rdquo;, p.pattern
print &ldquo;p.flags:&rdquo;, p.flags
print &ldquo;p.groups:&rdquo;, p.groups
print &ldquo;p.groupindex:&rdquo;, p.groupindex</p>

<h3>output</h3>

<h1>p.pattern: (\w+) (\w+)(?P<sign>.*)</h1>

<h1>p.flags: 16</h1>

<h1>p.groups: 3</h1>

<h1>p.groupindex: {&lsquo;sign&rsquo;: 3}</h1>

<p><code>  
实例方法[ | re模块方法]：  
1) **match(string[, pos[, endpos]]) | re.match(pattern, string[, flags]):**  
这个方法将从string的pos下标处起尝试匹配pattern；如果pattern结束时仍可匹配，则返回一个Match对象；如果匹配过程中pattern无法匹配，或者匹配未结束就已到达endpos，则返回None。  
pos和endpos的默认值分别为0和len(string)；re.match()无法指定这两个参数，参数flags用于编译pattern时指定匹配模式。  
注意：这个方法并不是完全匹配。当pattern结束时若string还有剩余字符，仍然视为成功。想要完全匹配，可以在表达式末尾加上边界匹配符'$'。  
示例参见2.1小节。
2) **search(string[, pos[, endpos]]) | re.search(pattern, string[, flags]):**  
这个方法用于查找字符串中可以匹配成功的子串。从string的pos下标处起尝试匹配pattern，如果pattern结束时仍可匹配，则返回一个Match对象；若无法匹配，则将pos加1后重新尝试匹配；直到pos=endpos时仍无法匹配则返回None。  
pos和endpos的默认值分别为0和len(string))；re.search()无法指定这两个参数，参数flags用于编译pattern时指定匹配模式。  
</code> python</p>

<h1>encoding: UTF-8</h1>

<p>import re</p>

<h1>将正则表达式编译成Pattern对象</h1>

<p>pattern = re.compile(r'world')</p>

<h1>使用search()查找匹配的子串，不存在能匹配的子串时将返回None</h1>

<h1>这个例子中使用match()无法成功匹配</h1>

<p>match = pattern.search(&lsquo;hello world!&rsquo;)</p>

<p>if match:</p>

<pre><code># 使用Match获得分组信息 
print match.group() 
</code></pre>

<h3>输出 ###</h3>

<h1>world</h1>

<p><code>  
3) **split(string[, maxsplit]) | re.split(pattern, string[, maxsplit]):**  
按照能夠匹配的子串將string分割後返回列表。maxsplit用於指定最大分割次數，不指定將全部分割。  
</code> python
import re</p>

<p>p = re.compile(r'\d+&lsquo;)
print p.split('one1two2three3four4&rsquo;)</p>

<h3>output</h3>

<h1>[&lsquo;one&rsquo;, &lsquo;two&rsquo;, &lsquo;three&rsquo;, &lsquo;four&rsquo;, &lsquo;&rsquo;]</h1>

<p><code>  
4) **findall(string[, pos[, endpos]]) | re.findall(pattern, string[, flags]):**  
搜索string，以列表形式返回全部能匹配的子串。  
</code> python
import re</p>

<p>p = re.compile(r'\d+&lsquo;)
print p.findall('one1two2three3four4&rsquo;)</p>

<h3>output</h3>

<h1>[&lsquo;1&rsquo;, &lsquo;2&rsquo;, &lsquo;3&rsquo;, &lsquo;4&rsquo;]</h1>

<p><code>  
5) **finditer(string[, pos[, endpos]]) | re.finditer(pattern, string[, flags]):**  
搜索string，返回一個順序訪問每一個匹配結果（Match對象）的叠代器。  
</code> python
import re</p>

<p>p = re.compile(r'\d+&lsquo;)
for m in p.finditer('one1two2three3four4&rsquo;):</p>

<pre><code>print m.group(),
</code></pre>

<h3>output</h3>

<h1>1 2 3 4</h1>

<p><code>  
6) **sub(repl, string[, count]) | re.sub(pattern, repl, string[, count]):**  
使用repl替換string中每一個匹配的子串後返回替換後的字符串。  
當repl是一個字符串時，可以使用\id或\g&lt;id&gt;、\g&lt;name&gt;引用分組，但不能使用編號0。  
當repl是一個方法時，這個方法應當只接受一個參數（Match對象），並返回一個字符串用於替換（返回的字符串中不能再引用分組）。  
count用於指定最多替換次數，不指定時全部替換。  
</code> python
import re</p>

<p>p = re.compile(r'(\w+) (\w+)&lsquo;)
s = 'i say, hello world!&rsquo;</p>

<p>print p.sub(r'\2 \1', s)</p>

<p>def func(m):</p>

<pre><code>return m.group(1).title() + ' ' + m.group(2).title()
</code></pre>

<p>print p.sub(func, s)</p>

<h3>output</h3>

<h1>say i, world hello!</h1>

<h1>I Say, Hello World!</h1>

<p><code>  
7) **subn(repl, string[, count]) |re.sub(pattern, repl, string[, count]):**  
返回 (sub(repl, string[, count]), 替換次數)。  
</code> python
import re</p>

<p>p = re.compile(r'(\w+) (\w+)&lsquo;)
s = 'i say, hello world!&rsquo;</p>

<p>print p.subn(r'\2 \1', s)</p>

<p>def func(m):</p>

<pre><code>return m.group(1).title() + ' ' + m.group(2).title()
</code></pre>

<p>print p.subn(func, s)</p>

<h3>output</h3>

<h1>(&lsquo;say i, world hello!&rsquo;, 2)</h1>

<h1>(&lsquo;I Say, Hello World!&rsquo;, 2)</h1>

<p>```</p>

<p><a href="http://www.cnblogs.com/huxi/archive/2010/07/04/1771073.html">Origin</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Python with語句(轉)]]></title>
    <link href="http://www.aprilzephyr.com/blog/04062014/python-with-yu-ju/"/>
    <updated>2014-04-06T16:37:46+08:00</updated>
    <id>http://www.aprilzephyr.com/blog/04062014/python-with-yu-ju</id>
    <content type="html"><![CDATA[<p><strong>1. With 語句是什麼</strong><br/>
Python’s with statement provides a very convenient way of dealing with the situation where you have to do a setup and teardown to make something happen. A very good example for this is the situation where you want to gain a handler to a file, read data from the file and the close the file handler.<br/>
有一些任務，可能事先需要設置，事後做清理工作。對於這種場景，Python的with語句提供了一種非常方便的處理方式。一個很好的例子是文件處理，你需要獲取一個文件句柄，從文件中讀取數據，然後關閉文件句柄。<!--more--></p>

<p>Without the with statement, one would write something along the lines of:<br/>
如果不用with語句，代碼如下： <br/>
<code>python
file = open("/tmp/foo.txt")
data = file.read()
file.close()
</code><br/>
There are two annoying things here. First, you end up forgetting to close the file handler. The second is how to handle exceptions that may occur once the file handler has been obtained. One could write something like this to get around this:<br/>
這裏有兩個問題。一是可能忘記關閉文件句柄；二是文件讀取數據發生異常，沒有進行任何處理。下面是處理異常的加強版本：<br/>
``` python
file = open(&ldquo;/tmp/foo.txt&rdquo;)
try:</p>

<pre><code>data = file.read()
</code></pre>

<p>finally:</p>

<pre><code>file.close()
</code></pre>

<p><code>  
While this works well, it is unnecessarily verbose. This is where with is useful. The good thing about with apart from the better syntax is that it is very good handling exceptions. The above code would look like this, when using with:  
雖然這段代碼運行良好，但是太冗長了。這時候就是with一展身手的時候了。除了有更優雅的語法，with還可以很好的處理上下文環境產生的異常。下面是with版本的代碼：  
</code> python
with open(&ldquo;/tmp/foo.txt&rdquo;) as file:</p>

<pre><code>data = file.read()
</code></pre>

<p>```</p>

<p><strong>2. with如何工作</strong><br/>
while this might look like magic, the way Python handles with is more clever than magic. The basic idea is that the statement after with has to evaluate an object that responds to an __enter__() as well as an __exit__() function.<br/>
這看起來充滿魔法，但不僅僅是魔法，Python對with的處理還很聰明。基本思想是with所求值的對象必須有一個__enter__()方法，一個__exit__()方法。</p>

<p>After the statement that follows with is evaluated, the __enter__() function on the resulting object is called. The value returned by this function is assigned to the variable following as. After every statement in the block is evaluated, the __exit__() function is called.<br/>
緊跟with後面的語句被求值後，返回對象的__enter__()方法被調用，這個方法的返回值將被賦值給as後面的變量。當with後面的代碼塊全部被執行完之後，將調用前面返回對象的__exit__()方法。</p>

<p>This can be demonstrated with the following example:<br/>
下面例子可以具體說明with如何工作：<br/>
``` python</p>

<h1>!/usr/bin/env python</h1>

<h1>with_example01.py</h1>

<p>class Sample:</p>

<pre><code>def __enter__(self):
    print "In __enter__()"
    return "Foo"

def __exit__(self, type, value, trace):
    print "In __exit__()"
</code></pre>

<p>def get_sample():</p>

<pre><code>return Sample()
</code></pre>

<p>with get_sample() as sample:</p>

<pre><code>print "sample:", sample
</code></pre>

<p><code>  
When executed, this will result in:  
運行代碼，輸出如下  
</code> python
bash-3.2$ ./with_example01.py
In <strong>enter</strong>()
sample: Foo
In <strong>exit</strong>()
<code>  
As you can see,  
The \_\_enter\_\_() function is executed  
The value returned by it - in this case "Foo" is assigned to sample  
The body of the block is executed, thereby printing the value of sample ie. "Foo"  
The \_\_exit\_\_() function is called.  
What makes with really powerful is the fact that it can handle exceptions. You would have noticed that the \_\_exit\_\_() function for Sample takes three arguments - val, type and trace. These are useful in exception handling. Let’s see how this works by modifying the above example.  
正如你看到的，  
1) \_\_enter\_\_()方法被執行  
2) \_\_enter\_\_()方法返回的值 - 這個例子中是"Foo"，賦值給變量'sample'  
3) 執行代碼塊，打印變量"sample"的值為 "Foo"  
4) \_\_exit\_\_()方法被調用  
with真正強大之處是它可以處理異常。可能你已經註意到Sample類的\_\_exit()\_\_方法有三個參數- val, type 和 trace。 這些參數在異常處理中相當有用。我們來改一下代碼，看看具體如何工作的。  
</code> python</p>

<h1>!/usr/bin/env python</h1>

<h1>with_example02.py</h1>

<p>class Sample:</p>

<pre><code>def __enter__(self):
    return self

def __exit__(self, type, value, trace):
    print "type:", type
    print "value:", value
    print "trace:", trace

def do_something(self):
    bar = 1/0
    return bar + 10
</code></pre>

<p>with Sample() as sample:</p>

<pre><code>sample.do_something()
</code></pre>

<p>```<br/>
Notice how in this example, instead of get_sample(), with takes Sample(). It does not matter, as long as the statement that follows with evaluates to an object that has an __enter__() and __exit__() functions. In this case, Sample()’s __enter__() returns the newly created instance of Sample and that is what gets passed to sample.<br/>
這個例子中，with後面的get_sample()變成了Sample()。這沒有任何關系，只要緊跟with後面的語句所返回的對象有__enter__()和__exit__()方法即可。此例中，Sample()的__enter__()方法返回新創建的Sample對象，並賦值給變量sample。</p>

<p>When executed:<br/>
代碼執行後：<br/>
``` python
bash-3.2$ ./with_example02.py
type: <type 'exceptions.ZeroDivisionError'>
value: integer division or modulo by zero
trace: <traceback object at 0x1004a8128>
Traceback (most recent call last):
  File &ldquo;./with_example02.py&rdquo;, line 19, in <module></p>

<pre><code>sample.do_something()
</code></pre>

<p>  File &ldquo;./with_example02.py&rdquo;, line 15, in do_something</p>

<pre><code>bar = 1/0
</code></pre>

<p>ZeroDivisionError: integer division or modulo by zero
```<br/>
Essentially, if there are exceptions being thrown from anywhere inside the block, the __exit__() function for the object is called. As you can see, the type, value and the stack trace associated with the exception thrown is passed to this function. In this case, you can see that there was a ZeroDivisionError exception being thrown. People implementing libraries can write code that clean up resources, close files etc. in their __exit__() functions.<br/>
實際上，在with後面的代碼塊拋出任何異常時，__exit__()方法被執行。正如例子所示，異常拋出時，與之關聯的type，value和stack trace傳給__exit__()方法，因此拋出的ZeroDivisionError異常被打印出來了。開發庫時，清理資源，關閉文件等等操作，都可以放在__exit__方法當中。</p>

<p>Thus, Python’s with is a nifty construct that makes code a little less verbose and makes cleaning up during exceptions a bit easier.<br/>
因此，Python的with語句是提供一個有效的機制，讓代碼更簡練，同時在異常產生時，清理工作更簡單。</p>

<p>I have put the code examples given here on <a href="https://github.com/sdqali/python_dojo/tree/master/with">Github</a>.<br/>
示例代碼可以在<a href="https://github.com/sdqali/python_dojo/tree/master/with">Github</a>上面找到。</p>

<p>譯註：本文原文見<a href="http://blog.sdqali.in/blog/2012/07/09/understanding-pythons-with/">Understanding Python&rsquo;s &ldquo;With&rdquo; Statement</a></p>

<p><a href="http://python.42qu.com/11155501">Origin</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Python 動態類型(轉)]]></title>
    <link href="http://www.aprilzephyr.com/blog/04022014/python-dong-tai-lei-xing/"/>
    <updated>2014-04-02T15:15:39+08:00</updated>
    <id>http://www.aprilzephyr.com/blog/04022014/python-dong-tai-lei-xing</id>
    <content type="html"><![CDATA[<p>Python中只有一個賦值模型</p>

<h4>1. 缺少類型聲明語句的情況</h4>

<p>在Python中，類型是在運行過程中自動決定的，而不是通過代碼聲明。這意味著沒有必要事聲明變量。只要記住，這個概念實質上對變量，對象和它們之間的關系都適用。那麽這個概念也容易理解並掌握。</p>

<p><strong>A 變量，對象和引用</strong><br/>
變量創建：一個變量，當代碼第一次給它賦值時它就被創建了。之後的賦值將會改變已創建的變量名的值。Python在代碼運行之前先檢測變量名，可以當成是最初的賦值創建變量。<!--more--><br/>
變量類型：變量永遠不會有任何的它關聯的類型信息或約束。類型的概念是存在於對象中而不是變量中。變量原本是通用的。它只是在一個特定的時間點，簡單地引用了一個特定的對像而已。<br/>
變量的使用：當變量出現在表達式中時，它會馬上被當前引用的對像所代替，無論這個對象是什麽類型。<br/>
此外，所有的變量都必須在其使用前明確地賦值。使用未賦值的變量會產生錯誤。<br/>
<code>&gt;&gt;&gt;a=3</code></p>

<p>在概念上說，Python將執行三個不同的步驟去完成這個請求。<br/>
1) 創建一個對象來代表值3<br/>
2) 創建一個變量a，如果它還沒有創建的話<br/>
3) 將變量與新的對象3連接</p>

<p>在python中從變量到對象的連接稱作引用。引用是一種關系，以內存中的指針形式實現。<br/>
* 變量 是一個系統表的元素，擁有指向對象的連接空間。<br/>
* 對象 是被分配的一塊內存，有足夠的空間去表現它們所代表的值。<br/>
* 引用 是自動形成的從變量到對象的指針。</p>

<p>每一個對象都用兩個標準的頭部信息：一個類型標誌符去標識這個對象的類型，以及一個引用的計數器，用來決定是不是可以回收這個對象。</p>

<p><strong>B 類型屬於對象，而不是變量</strong><br/>
Python中的類型是與對象相關聯的，而不是和變量關聯。<br/>
變量沒有類型，變量指向對象。對象有類型，知道自己的類型，每個對象都包含了一個頭部信息，其中標記了這個對象的類型。</p>

<p><strong>C 對象的垃圾收集</strong><br/>
對象生命結束時發生了什麽變化？<br/>
每當一個變量名被賦與了一個新的對象，之前的那個對象占用的空間就會被收回（如果它沒有被其他變量名和對象所引用).這種自動回收對象空間的技術稱作垃圾收集。<br/>
在內部，Python是通過保持用每個對象中的計數器記錄引用指到這個對象上的次數來完成這一功能。一旦（並精確在同一時間）這個計數器被設置為零，這個對象的內存空間就會自動收回。垃圾收集最直接的，可感受到的好處就是這意味著可以在腳本中任意使用對象而不需要考慮釋放內存空間。<br/>
```</p>

<blockquote><blockquote><blockquote><p>x=42
id(x)
674748828
x=&ldquo;cli&rdquo;
id(x)  <br/>
676367648
```</p></blockquote></blockquote></blockquote>

<h4>2. 共享引用</h4>

<p>上面所講都是單個變量被賦值引用了多個對象的情況。現在，在交互模式下，引入另一個變量，並看一下變量名和對象的變化。<br/>
```</p>

<blockquote><blockquote><blockquote><p>a=10
b=a
id(a)
674749212
id(b)
674749212
```<br/>
第二行會使用python創建變量b。使用的是變量a,並且它在這裏沒有被賦值，所以它被替換成其應用的對象10，從而b也成為這個對象的一個引用。實際效果就是變量a和b都引用相同的對象（也就是說指向了相同的內存空間。在Python中稱作是共享引用&mdash;多個變量名應用了同一個對象。)</p></blockquote></blockquote></blockquote>

<p>```</p>

<blockquote><blockquote><blockquote><p>a=10
b=a<br/>
a=&lsquo;cli&rsquo;
id(a)
676367648
id(b)
674749212
```<br/>
變量a改變了，但是不影響變量b.這完全可以說明變量b是指向對象10內存空間的。</p></blockquote></blockquote></blockquote>

<p>在ptyhon中，變量總是一個指向對象的指針，而不是可以改變的內存區域的標簽。給一變量賦一個新的值，並不是替換了原始的對象，而是讓這個變量去引用完全不同的一個對象。實際的效果就是對一個變量賦值，僅僅會影響那個被賦值的變量。</p>

<p><strong>A 共享引用和在原處修改</strong><br/>
有一些對象和類型確實會在實地改變對象。例如，在一個列表中對一個偏移進行賦值確實會改變這個列表對象，而不是生成一個新的列表對象。<br/>
```</p>

<blockquote><blockquote><blockquote><p>T1=[11,12,13]
T2=T1
T1
[11, 12, 13]
T2
[11, 12, 13]
T1=22
T1
22
T2
[11, 12, 13]
```</p></blockquote></blockquote></blockquote>

<p>這個和先前一樣T1改變了T2沒有改變，T2改變也不影響T1<br/>
```</p>

<blockquote><blockquote><blockquote><p>T1=[11,12,13]
T2=T1
T1
[11, 12, 13]
T2
[11, 12, 13]
T2[1]=33   <br/>
T1
[33, 12, 13]
T2
[33, 12, 13]
<code>  
發現T2改變了，T1也跟這改變了  
同樣T1改變了，T2也改變了  
</code>
T1[1]=99<br/>
T2
[33, 99, 13]
T1
[33, 99, 13]
```<br/>
這裏T1沒有改變，改變了T1所引用對象的一個元素。這類修改會覆蓋列表對象中的某部分。因為這個列表對象是與其他對象共享的（被其他對象引用），那麽一個像這樣在原處的改變不僅僅會對T1有影響。必須意識到當做了這樣的修改，它會影響程序的其他部分。</p></blockquote></blockquote></blockquote>

<p>如果不想要這樣的現象發生，需要Python拷貝對象，而不是創建引用。方法包括內置列表函數以及標準庫的copy模塊，最常用的辦法就是從頭到尾的分片T1[:]<br/>
```</p>

<blockquote><blockquote><blockquote><p>T1=[11,12,13]
T2=T1[:]
T1
[11, 12, 13]
T2
[11, 12, 13]
T1[0]=99
T1
[99, 12, 13]
T2
[11, 12, 13]
id(T1)
676366604
id(T2)
675542060
<code>  
T1和T2指向不同的對象，所以不會相互影響。  
註意：這種分片技術不會引用在其他的可變的核心類型上（字典，因為它們不是序列），對字典應該使用D.copy（）方法.而且，註意標準庫中的copy模塊有一個通用的拷貝任意對象的調用，也有一個拷貝嵌套對象的結構的調用.  
</code>
X={&lsquo;name&rsquo;:&lsquo;cli&rsquo;,&lsquo;age&rsquo;:27}<br/>
import copy
Y=copy.copy(X)
X
{&lsquo;age&rsquo;: 27, &lsquo;name&rsquo;: &lsquo;cli&rsquo;}
Y
{&lsquo;age&rsquo;: 27, &lsquo;name&rsquo;: &lsquo;cli&rsquo;}
id(X)
676370468
id(Y)
676414436
X={&lsquo;name&rsquo;:{&lsquo;FirstName&rsquo;:&lsquo;cli&rsquo;,&lsquo;LastName&rsquo;:&lsquo;cli&rsquo;},&lsquo;age&rsquo;:27}  <br/>
X
{&lsquo;age&rsquo;: 27, &lsquo;name&rsquo;: {&lsquo;LastName&rsquo;: &lsquo;cli&rsquo;, &lsquo;FirstName&rsquo;: &lsquo;cli&rsquo;}}
Y=copy.copy(X)
Y
{&lsquo;age&rsquo;: 27, &lsquo;name&rsquo;: {&lsquo;LastName&rsquo;: &lsquo;cli&rsquo;, &lsquo;FirstName&rsquo;: &lsquo;cli&rsquo;}}
Z=copy.deepcopy(X)
Z
{&lsquo;age&rsquo;: 27, &lsquo;name&rsquo;: {&lsquo;LastName&rsquo;: &lsquo;cli&rsquo;, &lsquo;FirstName&rsquo;: &lsquo;cli&rsquo;}}
```</p></blockquote></blockquote></blockquote>

<p><strong>B 共享引用和相等</strong>
```</p>

<blockquote><blockquote><blockquote><p>x=33
x=&lsquo;cli&rsquo;
```<br/>
因為Python緩存並復用了小的整數和小的字符串，就像前文提到的那樣，這裏對象33也許不像前期所說的被收回，相反，它將可能仍保持在一個系統表中，等待下一次你的代碼生成另一個33來利用。盡快如此，大多數種類的對象都會在不再引用時馬上回收。對於那些不會被回收的，緩沖機制與代碼並沒有什麽關系。</p></blockquote></blockquote></blockquote>

<p>判斷是否相等<br/>
```</p>

<blockquote><blockquote><blockquote><p>L=[1,2,3]
M=L
L==M
True
L is M
True
<code>  
==檢查對象是否有相同的值。 is操作符，檢查對象的同一性。如果兩個變量名精準地指向同一個對象，它會返回True。所以這是一種更嚴格的相等測試。  
實際上,is只是比較現實引用的指針。所以如果必要的話是代碼中檢測共享引用的一種方法。如果變量名引用值相等。但是為不同的對象，它的返回值將是False.  
</code>
L=[1,2,3]
M=[1,2,3]
L==M
True
L is M
False
id(L)
676367788
id(M)
676367724
```<br/>
通過id()函數可以看到兩個變量指向不同的對象。</p></blockquote></blockquote></blockquote>

<p>```</p>

<blockquote><blockquote><blockquote><p>X=33
Y=33
X==Y
True
X is Y
True
id(X)
674748936
id(Y)
674748936
<code>  
這個is測試返回True因為小的整數和字符串被緩存被復用了。
如果想更進一步了解，可以向Python查詢一個對象應用的次數：在sys模塊中的getrefcount函數返回對象應用的次數。  
</code>
import sys
sys.getrefcount(33)
13
sys.getrefcount(1)
427
sys.getrefcount(00)
296
sys.getrefcount(99)
6
```</p></blockquote></blockquote></blockquote>

<p><a href="http://ipseek.blog.51cto.com/1041109/786518">Origin</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Python 文件處理]]></title>
    <link href="http://www.aprilzephyr.com/blog/03312014/python-wen-jian-chu-li/"/>
    <updated>2014-03-31T17:48:17+08:00</updated>
    <id>http://www.aprilzephyr.com/blog/03312014/python-wen-jian-chu-li</id>
    <content type="html"><![CDATA[<p>python對文件的處理的兩個內建函數：<br/>
open()、file()，這個兩函數提供了初始化輸入\輸出（I\O）操作的通用接口。兩函數的功能相同。<br/>
基本用法：<br/>
file_object=open(filename, access_mode=&lsquo;r&rsquo;, buffering=-1）
file_object 是定義一個打開文件的對象<br/>
access_mode 是打開文件的模式；通常，文件使用模式  &lsquo;r&rsquo;,&lsquo;w&rsquo;,&lsquo;a&rsquo; 來打開，分別代表，讀取，寫入，追加。<br/>
&lsquo;r&rsquo; 模式打開已經存在的文件<br/>
&lsquo;w&rsquo; 模式打開的文件若存在則首先清空，再加入內容。<br/>
&lsquo;a&rsquo; 這個模式是追加內容到文件中<!--more--><br/>
註. &lsquo;b&rsquo; 模式這個是打開二進制文件，對於unix-like/unix類型的系統'b'模式是可有可無的。<br/>
buffering 訪問文件所采用的緩沖方式。其中0表示不緩沖，1表示只緩沖一行數據，任何其它大於1的值代表使用給定的值作為緩沖區大小。不給定此參數或者參數為負數都表示使用系統默認的緩沖機制。<br/>
使用open打開文件之後一定記得調用close()關閉文件。</p>

<p>常用的文件訪問方式如下：<br/>
r        以讀方式打開<br/>
rU或Ua   以讀方式打開同時提供通用換行符支持<br/>
w        以寫方式打開<br/>
a        以追加方式打開<br/>
r+       以讀寫方式打開<br/>
w+       以讀寫方式打開<br/>
a+       以讀寫方式打開</p>

<p>文件的輸入：<br/>
python中有三個方法來處理文件內容的輸入：<br/>
read() 一次讀取全部的文件內容。<br/>
readline() 每次讀取文件的一行。<br/>
readlines() 讀取文件的所有行，返回一個字符串列表。</p>

<p>寫數據：<br/>
<code>python
file_object = open('thefile.txt', 'w')
file_object.write(all_the_text)
file_object.close( )
</code></p>

<p>寫入多行：<br/>
<code>file_object.writelines(list_of_text_strings)</code></p>

<p>seek(offset,where):  默認值where=0表示從起始位置移動"offset"個字節，where=1表示從當前位置移動"offset"個字節，where=2表示從結束位置移動"offset"個字節。當有換行時，會被換行截斷。seek()無返回值，故值為None。</p>

<p>tell():  文件的當前位置,即tell是獲得文件指針位置，受seek、readline、read、readlines影響，不受truncate影響。</p>

<p>truncate(n):  從文件的首行首字符開始截斷，截斷文件為n個字符；無n表示從當前位置起截斷；截斷之後n後面的所有字符被刪除。其中win下的換行代表2個字符大小。<br/>
``` python</p>

<pre><code>  fso = open("f:\\a.txt",'w+')    #以w+方式，並非a方式打開文件，故文件原內容被清空
  print fso.tell()    #文件原內容被清空，故此時tell()=0

  fso.write("abcde\n")  #寫入文件abcde\n，因為換行\n占兩個字符，故共寫入7個字符
  print fso.tell()  #此時tell()=7

  fso.write("fghwm")  #又寫入文件fghwm，故此時文件共寫入7+5 =142個字符
  print fso.tell()  #此時tell()=12 

  fso.seek(1, 0)  #從起始位置即文件首行首字符開始移動1個字符
  print fso.tell()   #此時tell() =1

  print  fso.readline()  #讀取當前行，即文件的第1行，但是從第二個字符(tell()+1)開始讀，結果為:bcde。'若換成for讀取整個文件或read讀取整個文件則結果為bcdefghwm     

  print fso.tell()   #因為readline此時tell() =7,

  fso.truncate(8)  #從寫入後文件的首行首字符開始階段，截斷為8個字符，即abcde\nf，即文件的內容為：abcde\nf

  print fso.tell()   #tell() 依舊為7,並為受truncate(8)影響，但是此時文件內容為abcde\nf

  print  fso.readline()  #從tell()+1=8開始讀取，讀取當前行內容：f

  fso.close()
</code></pre>

<p>```</p>
]]></content>
  </entry>
  
</feed>
