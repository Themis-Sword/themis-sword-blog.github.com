<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Python | Themis_Sword's Blog]]></title>
  <link href="http://www.aprilzephyr.com/blog/categories/python/atom.xml" rel="self"/>
  <link href="http://www.aprilzephyr.com/"/>
  <updated>2014-03-26T16:28:30+08:00</updated>
  <id>http://www.aprilzephyr.com/</id>
  <author>
    <name><![CDATA[Themis_Sword]]></name>
    <email><![CDATA[licong0419@outlook.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Python 常用函數之Join, Split, Zip, Map, Reduce, Filter]]></title>
    <link href="http://www.aprilzephyr.com/blog/2014/03/26/python-chang-yong-han-shu-zhi-join/"/>
    <updated>2014-03-26T15:34:48+08:00</updated>
    <id>http://www.aprilzephyr.com/blog/2014/03/26/python-chang-yong-han-shu-zhi-join</id>
    <content type="html"><![CDATA[<p><strong><em>1. Join, Split</em></strong><br/>
<em>A 關於Join和Split方法</em><br/>
1) 只針對字符串進行處理。split:拆分字符串、join連接字符串<br/>
2) string.join(sep): 以string作為分割符，将sep中所有的元素(字符串表示)合併成一個新的字符串<br/>
3) string.split(str=&lsquo; &rsquo;,num=string.count(str)): 以str為分隔符，切片string，如果num有指定值，則僅分隔num個子字符串<br/>
4) 對導入os模塊進行os.path.splie()/os.path.join() 貌似是處理機制不一樣，但是功能上一樣<!--more--></p>

<p><em>B Join</em><br/>
<code>python
a='abcd'
print '.'.join(a)   
print '|'.join(['a','b','c'])　　#可以把['a','b','c']看做是 a='abcd';下面同理
print '.'.join({'a':1,'b':2,'c':3,'d':4})
</code><br/>
注意：'.&lsquo;等做分隔符，將join裏的所有元素(字符串)通過分隔符連接成一個新的字符串。</p>

<p><strong>os.path.join(path1[,path2[,&hellip;&hellip;]])</strong><br/>
``` python
\将多个路径组合后返回，第一个绝对路径之前的参数将被忽略。</p>

<blockquote><blockquote><blockquote><p>os.path.join(&lsquo;c:\&rsquo;, &lsquo;csv&rsquo;, &lsquo;test.csv&rsquo;)
&lsquo;c:\csv\test.csv&rsquo;
os.path.join(&lsquo;windows\temp&rsquo;, &lsquo;c:\&rsquo;, &lsquo;csv&rsquo;, &lsquo;test.csv&rsquo;)
&lsquo;c:\csv\test.csv&rsquo;
os.path.join(&lsquo;/home/aa&rsquo;,&lsquo;/home/aa/bb&rsquo;,&lsquo;/home/aa/bb/c&rsquo;)
&lsquo;/home/aa/bb/c&rsquo;
```</p></blockquote></blockquote></blockquote>

<p><em>C Split</em><br/>
<code>python
s='a b c'
print s.split(' ')
st='hello world'
print st.split('o')
print st.split('o',1)
--------output---------
['a', 'b', 'c']
['hell', ' w', 'rld']
['hell', ' world']
</code><br/>
注意：分隔符不能為空，否則會報錯，但是可以有不含其中的分隔符：<br/>
``` python</p>

<blockquote><blockquote><blockquote><p>s.split(&lsquo;x&rsquo;)
[&lsquo;a b c&rsquo;]
s.split(&lsquo;xsdfadsf&rsquo;)
[&lsquo;a b c&rsquo;]
```</p></blockquote></blockquote></blockquote>

<p><strong>os.path.split()</strong><br/>
os.path.split()是按照路徑將文件名和路徑分隔開，比如d:\python\python.ext，可分割為[&rsquo;d:\python', &lsquo;python.exe&rsquo;]<br/>
<code>python
import os
print os.path.split('c:\\Program File\\123.doc')
print os.path.split('c:\\Program File\\')
-----------------output---------------------
('c:\\Program File', '123.doc')
('c:\\Program File', '')
</code><br/>
<a href="http://www.cnblogs.com/BeginMan/archive/2013/03/21/2972857.html">Origin</a></p>

<p><strong><em>2. Zip</em></strong><br/>
zip()是Python的内建函數，(與序列有關的内建函數有：sorted()、reversed()、enumerate()、zip()),其中sorted()和zip()返回一個序列(列表)對象，reversed()、enumerate()返回一個迭代器(類似序列)。<br/>
定義：zip([seql, &hellip;])接受一系列可迭代對象作為參數，將對象中對應的元素打包成一個個tuple（元组），然後返回由這些tuples組成的list（列表）。若傳入參數的長度不等，则返回list的長度和參數中長度最短的對象相同。<br/>
``` python</p>

<blockquote><blockquote><blockquote><p>z1=[1,2,3]
z2=[4,5,6]
result=zip(z1,z2)
result
[(1, 4), (2, 5), (3, 6)]
z3=[4,5,6,7]
result=zip(z1,z3)
result
[(1, 4), (2, 5), (3, 6)]
<code>  
zip()配合*號操作符，可以將已經zip過的列表對象解壓  
</code> python
zip(<em>result)
[(1, 2, 3), (4, 5, 6)]
<code>  
更近一層了解  
</code> python
* 二維矩陣變換（矩陣的行列互換）
比如我们有一個由列表描述的二維矩陣
a = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]
通过python列表推导的方法，我们也能轻易完成这个任务
print [ [row[col] for row in a] for col in range(len(a[0]))]
[[1, 4, 7], [2, 5, 8], [3, 6, 9]]
另外一種讓人困惑的方法就是利用zip函數：
a = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]
zip(</em>a)
[(1, 4, 7), (2, 5, 8), (3, 6, 9)]
map(list,zip(<em>a))
[[1, 4, 7], [2, 5, 8], [3, 6, 9]]
zip函數接受任意多個序列作為參數，將所有序列按相同的索引組合成一個元素是各個序列合併成的tuple的新序列，新的序列的長度以參數中最短的序列為準。另外(</em>)操作符与zip函數配合可以實現與zip相反的功能，即將合併的序列拆成多個tuple。
①tuple的新序列</p>

<blockquote><p>x=[1,2,3],y=[&lsquo;a&rsquo;,&lsquo;b&rsquo;,&lsquo;c&rsquo;]
zip(x,y)
[(1,&lsquo;a&rsquo;),(2,&lsquo;b&rsquo;),(3,&lsquo;c&rsquo;)]
②新的序列的長度以參數中最短的序列為準.
x=[1,2],y=[&lsquo;a&rsquo;,&lsquo;b&rsquo;,&lsquo;c&rsquo;]
zip(x,y)
[(1,&lsquo;a&rsquo;),(2,&lsquo;b&rsquo;)]
③(<em>)操作符与zip函數配合可以實現與zip相反的功能,即將合併的序列拆成多個tuple。
x=[1,2,3],y=[&lsquo;a&rsquo;,&lsquo;b&rsquo;,&lsquo;c&rsquo;]
zip(</em>zip(x,y))
[(1,2,3),(&lsquo;a&rsquo;,&lsquo;b&rsquo;,&lsquo;c&rsquo;)]
```<br/>
<a href="http://www.cnblogs.com/BeginMan/archive/2013/03/14/2959447.html">Origin</a></p></blockquote></blockquote></blockquote></blockquote>

<p><strong><em>3. Map</em></strong><br/>
對sequence中的item依次執行function(item)，執行結果輸出為list。<br/>
``` python</p>

<blockquote><blockquote><blockquote><p>map(str, range(5))           #對range(5)各項進行str操作
[&lsquo;0&rsquo;, &lsquo;1&rsquo;, &lsquo;2&rsquo;, &lsquo;3&rsquo;, &lsquo;4&rsquo;]        #返回列表
def add(n):return n+n
&hellip;
map(add, range(5))           #對range(5)各項進行add操作
[0, 2, 4, 6, 8]
map(lambda x:x+x,range(5))   #lambda 函數，各項+本身
[0, 2, 4, 6, 8]
map(lambda x:x+1,range(10))  #lambda 函數，各項+1
[1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
map(add,&lsquo;zhoujy&rsquo;)          <br/>
[&lsquo;zz&rsquo;, &lsquo;hh&rsquo;, &lsquo;oo&rsquo;, &lsquo;uu&rsquo;, &lsquo;jj&rsquo;, &lsquo;yy&rsquo;]
<code>  
想要輸入多個序列，需要支持多個參數的函數，注意的是各序列的長度必須一樣，否則報錯：  
</code> python
def add(x,y):return x+y
&hellip;
map(add,&lsquo;zhoujy&rsquo;,&lsquo;Python&rsquo;)
[&lsquo;zP&rsquo;, &lsquo;hy&rsquo;, &lsquo;ot&rsquo;, &lsquo;uh&rsquo;, &lsquo;jo&rsquo;, &lsquo;yn&rsquo;]
def add(x,y,z):return x+y+z
&hellip;
map(add,&lsquo;zhoujy&rsquo;,&lsquo;Python&rsquo;,&lsquo;test&rsquo;)     #&lsquo;test'的長度比其他2個小
Traceback (most recent call last):
  File &ldquo;<stdin>&rdquo;, line 1, in <module>
TypeError: add() takes exactly 2 arguments (3 given)
map(add,'zhoujy&rsquo;,&lsquo;Python&rsquo;,&lsquo;testop&rsquo;)
[&lsquo;zPt&rsquo;, &lsquo;hye&rsquo;, &lsquo;ots&rsquo;, &lsquo;uht&rsquo;, &lsquo;joo&rsquo;, &lsquo;ynp&rsquo;]
```</p></blockquote></blockquote></blockquote>

<p><strong><em>4. Reduce</em></strong><br/>
對sequence中的item顺序迭代調用function，函數必須要有2個參數。要是有第3個參數，則表示初始值，可以繼續调用初始值，返回一個值。<br/>
``` python</p>

<blockquote><blockquote><blockquote><p>def add(x,y):return x+y
&hellip;
reduce(add,range(10))        #1+2+3+&hellip;+9
45
reduce(add,range(11))        #1+2+3+&hellip;+10
55
reduce(lambda x,y:x<em>y,range(1,3),5)           #lambda 函數，5是初始值， 1</em>2<em>5
10
reduce(lambda x,y:x</em>y,range(1,6))             #阶乘，1<em>2</em>3<em>4</em>5
120
reduce(lambda x,y:x<em>y,range(1,6),3)           #初始值3，结果再</em>3
360
reduce(lambda x,y:x+y,[1,2,3,4,5,6])          #1+2+3+4+5+6
21
```</p></blockquote></blockquote></blockquote>

<p><strong><em>5. Filter</em></strong><br/>
對sequence中的item依次執行function(item)，將執行結果為True（！=0）的item組成一個List/String/Tuple（取決于sequence的類型）返回，False則退出（0），進行過濾。<br/>
``` python</p>

<blockquote><blockquote><blockquote><p>def div(n):return n%2
&hellip;
filter(div,range(5))                    #返回div輸出的不等於0的真值
[1, 3]
filter(div,range(10))
[1, 3, 5, 7, 9]
filter(lambda x : x%2,range(10))        #lambda 函數返回奇數，返回列表
[1, 3, 5, 7, 9]
filter(lambda x : not x%2,range(10))
[0, 2, 4, 6, 8]
def fin(n):return n!=&lsquo;z&rsquo;                #過濾'z' 函數，出现z则返回False
&hellip;
filter(fin,&lsquo;zhoujy&rsquo;)                    #&lsquo;z'被過濾
'houjy&rsquo;
filter(lambda x : x !=&lsquo;z&rsquo;,&lsquo;zhoujy&rsquo;)     #labmda返回True值
&lsquo;houjy&rsquo;
filter(lambda x : not x==&lsquo;z&rsquo;,&lsquo;zhoujy&rsquo;)  #返回：字符串
&lsquo;houjy&rsquo;
```</p></blockquote></blockquote></blockquote>

<p><strong><em>6. Map, Reduce, Filter應用</em></strong><br/>
<em>A 實現5!+4!+3!+2!+1</em>
``` python</p>

<h1>!/usr/bin/env python</h1>

<h1>&ndash;<em>&ndash; coding:utf-8 &ndash;</em>&ndash;</h1>

<p>def add_factorial(n):</p>

<pre><code>empty_list=[]           #聲明一個空列表，存各個階乘的結果，方便這些結果相加
for i in map(lambda x:x+1,range(n)):    #用傳進來的變量(n)來生成一个列表，用map讓列表都+1，eg：range(5) =&gt; [1,2,3,4,5]
    a=reduce(lambda x,y:x*y,map(lambda x:x+1,range(i)))   #生成階乘，用map去掉列表中的0
    empty_list.append(a)            #把階乘結果append到空的列表中
return empty_list
</code></pre>

<p>if <strong>name</strong> == &lsquo;<strong>main</strong>&rsquo;:</p>

<pre><code>import sys
</code></pre>

<h1>2選1</h1>

<h1>(一)</h1>

<pre><code>try:
    n = input("Enter a Number(int) : ")
    result=add_factorial(n)   #傳入變量
    print reduce(lambda x,y:x+y,result)      #階乘結果相加
except (NameError,TypeError):
    print "That's not a Number!"
</code></pre>

<h1>(二)</h1>

<h1>result = add_factorial(int(sys.argv[1]))   #傳入變量</h1>

<h1>print reduce(lambda x,y:x+y,result)      #階乘結果相加</h1>

<p>```</p>

<p><em>B 將100-200以內的質數挑選出來</em><br/>
``` python</p>

<h1>!/usr/bin/env python</h1>

<h1>&ndash;<em>&ndash; coding:utf-8 &ndash;</em>&ndash;</h1>

<p>def is_prime(start,stop):</p>

<pre><code>stop  = stop+1     #包含列表右边的值
prime = filter(lambda x : not [x%i for i in range(2,x) if x%i == 0],range(start,stop))   #取出質數,x从range(start,stop) 取的數
print prime
</code></pre>

<p>if <strong>name</strong> == &lsquo;<strong>main</strong>&rsquo;:</p>

<pre><code>try :
    start = input("Enter a start Number :")
except :
    start = 2   #开始值默认2
try :
    stop  = input("Enter a stop  Number :")
except :
    stop  = 0   #停止數，默认0，即不返回任何值
is_prime(start,stop)
</code></pre>

<p>```<br/>
<a href="http://www.cnblogs.com/zhoujinyi/archive/2013/06/07/3121976.html">Origin</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Notes of Python 02]]></title>
    <link href="http://www.aprilzephyr.com/blog/2014/03/06/notes-of-python-02/"/>
    <updated>2014-03-06T17:07:25+08:00</updated>
    <id>http://www.aprilzephyr.com/blog/2014/03/06/notes-of-python-02</id>
    <content type="html"><![CDATA[<ol>
<li><p>不同算法實現Fibonacci數列<br/>
1) 遞歸：<br/>
<code>python
fib=lambda n:1 if n&lt;=2 else fib(n-1)+fib(n-2)
</code><br/>
2) 迭代：<br/>
<code>python
def fib(n):
x,y=0,1
while(n):
x,y,n=y,x+y,n-1
return x
</code><br/>
3) 尾遞歸(SICP)：<br/>
<code>python
def fib(n):
def fib_iter(n,x,y):
if n==0 : return x
else : return fib_iter(n-1,y,x+y)
return fib_iter(n,0,1)
</code><br/>
<a href="http://www.cnblogs.com/figure9/archive/2010/08/30/1812927.html">Origin</a><!--more--></p></li>
<li><p>九九乘法表<br/>
<code>python
for i in range(1,10):
　　for j in range(1,i+1):
　　　　print(" %d*%d=%d" % (j,i,i*j)),
　　print '\n'
</code></p></li>
<li><p>求素數<br/>
<code>python
lis = []
for obj in range(1,10):
 if obj&gt;2:
     for x in range(2,obj):
         if obj % x == 0:
             lis.append(obj)
lis = list(set(lis))
sushu = [obj for obj in range(1,10) if obj not in lis]
print sushu
</code></p></li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Python實現排序算法]]></title>
    <link href="http://www.aprilzephyr.com/blog/2014/03/06/pythonshi-xian-pai-xu-suan-fa/"/>
    <updated>2014-03-06T15:53:21+08:00</updated>
    <id>http://www.aprilzephyr.com/blog/2014/03/06/pythonshi-xian-pai-xu-suan-fa</id>
    <content type="html"><![CDATA[<ol>
<li>冒泡排序<br/>
<code>python   
def bubble(x,n):  
\冒泡排序，x是列表，n是列表長度  
for i in range(n):  
for j in range(n-1):  
if x[j]&gt;x[j+1]:  
t = x[j]  
x[j] = x[j+1]  
x[j+1] = t  
return x                  
print bubble([1,10,2,5,41,25,3,48], 8)    
</code><br/>
</br><!--more--></li>
<li>插入排序<br/>
<code>python  
def insert(x,n):
  i = 1
  while i&lt;n-1:
      key = x[i]
      j = i-1
      while j&gt;=0 and key&lt;x[j]:
          x[j+1]= x[j]
          j -= 1
      x[j+1] = key
      i += 1
  return x
print insert([1,10,2,5,41,25,3,48],8)
</code><br/>
</br></li>
<li>選擇排序<br/>
<code>python
def select(x,n):
 for i in range(n-1):
     key = i
     for j in range(i+1,n):
         if x[j] &lt; x[key]:
              key = j
     if key!=i:
         t = x[i]
         x[i] = x[key]
         x[key] = t
 return x
print select([1,10,2,5,41,25,3,48],8)
</code><br/>
</br></li>
<li>快速排序
<code>python
def partition(x,low,high):
 key = x[low]
 while low&lt;high:
     while low&lt;high and x[high]&gt;=key:
         high -= 1
     if low &lt; high:
         x[low]= x[high]
         low += 1
     while low &lt;high and x[low]&lt;=key:
         low += 1
     if low &lt; high:
         x[high] = x[low]
         high -= 1
 x[low] = key
 return low
def quick(x,low,high):
 if low &lt; high:
    p = partition(x,low,high)
    quick(x,low,p-1)
    quick(x,p+1,high)
 return x
</code><br/>
</br></li>
<li>利用函數排序<br/>
1) cmp()<br/>
Compare the two objects x and y and return an integer according to the outcome. The return value is negative if x &lt; y, zero if x == y and strictly positive if x > y.<br/>
2) reversed()<br/>
3) sort()<br/>
4) sorted()</li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[平衡點問題和支配點問題之Python求解(轉)]]></title>
    <link href="http://www.aprilzephyr.com/blog/2014/02/18/ping-heng-dian-wen-ti-he-zhi-pei-dian-wen-ti-zhi-pythonqiu-jie-zhuan/"/>
    <updated>2014-02-18T21:46:13+08:00</updated>
    <id>http://www.aprilzephyr.com/blog/2014/02/18/ping-heng-dian-wen-ti-he-zhi-pei-dian-wen-ti-zhi-pythonqiu-jie-zhuan</id>
    <content type="html"><![CDATA[<ol>
<li><p>平衡點問題<br/>
平衡點：比如int[] numbers = {1,3,5,7,8,25,4,20}; 25前面的總和爲24，25後面的總和也是24，25這個點就是平衡點；假如一個數組中的元素，其前面的部分等於後面的部分，那麼這個點的位序就是平衡點。 <br/>
要求：返回任何一個平衡點<br/>
使用sum函数累加所有的数。
使用一个变量fore来累加序列的前部。直到满足条件fore&lt;(total-number)/2;
``` python<br/>
numbers = [1,3,5,7,8,2,4,20]</p>

<h1>find total</h1>

total=sum(numbers)

<h1>find num</h1>

fore=0<br/>
for number in numbers:<br/>
if fore&lt;(total-number)/2 :<br/>
   fore+=number<br/>
else:<br/>
   break

<h1>print answer</h1>

<p>if fore == (total-number)/2 :<br/>
print number<br/>
else :<br/>
print r'not found'<br/>
```<br/>
算法簡單，而且是O(n)的。<br/>
<strong>PS</strong> 上述解題思路爲題目只考慮序列只包括正數的情況(有唯一平衡點)，當序列中有負數的時候，平衡點不一定唯一。<!--more--></p></li>
<li><p>支配點問題<br/>
支配數：數組中某個元素出現的次數大於數組總數的一半時就成爲支配數，其所在位序成為支配點；比如int[] a = {3,3,1,2,3};3爲支配數，0，1，4分别爲支配點。<br/>
要求：返回任何一個支配點<br/>
《編程之美》中有答案，就是尋找水王那篇。<br/>
具體方法是：將序列排序，取中位數——注意，如果一個數出現次數大於整體的一半，那麼排序之後支配數一定在中間，然後驗證是否正確。<br/>
``` python<br/>
numbers = [1,3,4,3,3]</p>

<h1>calculate</h1>

numbers.sort()<br/>
lens=len(numbers)<br/>
candidate=numbers[lens/2]

<h1>validate</h1>

N=0<br/>
for number in numbers:<br/>
 if number==candidate:<br/>
    N+=1

<h1>print answer</h1>

<p>if (N>=lens/2):<br/>
  print numbers[lens/2]<br/>
else :<br/>
print &lsquo;not found'<br/>
```<br/>
<a href="http://hi.baidu.com/ruclin/item/f2706f26b1d2db140975086b">Origin</a>
<a href="http://www.iteye.com/topic/600079">Reference</a></p></li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Notes of Python 01]]></title>
    <link href="http://www.aprilzephyr.com/blog/2014/02/18/notes-of-python/"/>
    <updated>2014-02-18T14:09:05+08:00</updated>
    <id>http://www.aprilzephyr.com/blog/2014/02/18/notes-of-python</id>
    <content type="html"><![CDATA[<ol>
<li><p>Python 是怎樣進行類型轉換的？<br/>
1) Python是動態類型，是强類型的編程語言。<br/>
2) Python內建函數的實現類型轉換：<br/>
     <table>
<tbody>
<tr><td><em> 函數 </em></td><td><em> 描述 </em></td></tr><br/>
<tr><td>int(x [,base ]) </td><td>將x轉換為一個整數</td></tr>
<tr><td>long(x [,base ]) </td><td>將x轉換為一個長整數</td></tr>
<tr><td>float(x) </td><td>將x轉換為一個浮點數</td></tr>
<tr><td>complax(real [, img ]) </td><td>創建一個複數</td></tr>
<tr><td>str(x) </td><td>將對象x轉換為字符串</td></tr>
<tr><td>repr(x) </td><td>將對象x轉換為表達式字符串</td></tr>
<tr><td>eval(str) </td><td>計算在字符串中的有效python表達式，並返回一個對象</td></tr>
<tr><td>tuple(s) </td><td>將序列s轉換為一個元組</td></tr>
<tr><td>list(s) </td><td>將序列s轉換為一個列表</td></tr>
<tr><td>chr(x) </td><td>將一個整數轉換為一個字符</td></tr>
<tr><td>unichr(x) </td><td>將一個整數轉換為一個Unicode字符</td></tr>
<tr><td>ord(x) </td><td>將一個字符轉換為它的整數值</td></tr>
<tr><td>hex(x) </td><td>將一個整數轉換為一個十六進制字符串</td></tr>
<tr><td>oct(x) </td><td>將一個整數轉換為一個八進制字符串</td></tr>
<tbody>
</table> <!--more--></p></li>
<li><p>range()函數的用法<br/>
<strong>range(start, stop[, step])</strong><br/>
Example:<br/>
``` python</p>

<blockquote><blockquote><blockquote><p>range(10)<br/>
[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]<br/>
range(1, 11)<br/>
[1, 2, 3, 4, 5, 6, 7, 8, 9, 10]<br/>
range(0, 30, 5)<br/>
[0, 5, 10, 15, 20, 25]<br/>
range(0, 10, 3)<br/>
[0, 3, 6, 9]<br/>
range(0, -10, -1)<br/>
[0, -1, -2, -3, -4, -5, -6, -7, -8, -9]<br/>
range(0)<br/>
[]<br/>
range(1, 0)<br/>
[]<br/>
```</p></blockquote></blockquote></blockquote></li>
<li><p>生成隨機數<br/>
1) <strong>random.random</strong><br/>
用於生成一個0到1的隨機浮點數：0&lt;=n&lt;1.0。<br/>
2) <strong>random.uniform</strong><br/>
原型爲randon.uniform(a,b)，用於生成一個制定範圍內的隨機浮點數，兩個參數分別爲上下限：如果a>b，生成的浮點數：b&lt;=n&lt;a；如果a&lt;b，生成的浮點數：a&lt;=n&lt;b。<br/>
3) <strong>random.randint</strong><br/>
原型爲random.randint(a,b)，用於生成一個制定範圍內的整數。參數a爲下限，b爲上限，生成的隨機數：a&lt;=n&lt;=b。<br/>
4) <strong>random.randrange</strong><br/>
原型爲random.randrange([start], stop[, step])，從指定範圍內，按指定基數递增的集合中獲取一個隨機數。如：random.randrange(10, 100, 2)，结果相當於從[10, 12, 14, 16, &hellip; 96, 98]序列中獲取一個隨機數。random.randrange(10, 100, 2)在結果上於 random.choice(range(10, 100, 2)等效。<br/>
5) <strong>random.choice</strong><br/>
原型爲random.choice(sequence)。參數sequence表示一個有序類型，其不是一種特定的類型，而是泛指一系列的類型，如list，tuple，string等。<br/>
6) <strong>random.shuffle</strong><br/>
原型爲random.shufle(x[, random])，用於將一個列表中的元素打亂後輸出。<br/>
7) <strong>random.sample</strong><br/>
原型爲random.sample(sequence, k)，從指定序列中隨機獲取制定長度的片段，sample函數不會修改原有序列。</p></li>
<li><p>如何查詢和替換一個文本字符串。<br/>
1) sub()<br/>
格式為sub(replacement, string[,count=0])<br/>
replacement是被替換成的文本；<br/>
string是需要被替換的文本；<br/>
count是一個可選參數，指最大被替換的數量。<br/>
2) subn()
執行的效果跟sub()一样，不過它會返回一個二維數組，包括替換後的新的字符串和總共替換的數量。</p></li>
<li><p>兩個序列的和的差最小<br/>
有两個序列a,b，大小都爲n,序列元素的值任意整数，無序；<br/>
要求：通過交換a,b 中的元素，使[序列a 元素的和]与[序列b 元素的和]之間的差最小。<br/>
例如:<br/>
var a=[100,99,98,1,2,3];<br/>
var b=[1,2,3,4,5,40];<br/>
<strong>分析：</strong><br/>
當數組a和b的和之差爲A = sum(a) &ndash; sum(b)，a的第i個元素和b的第j個元素交換後，a和b的和之差爲：<br/>
A' = sum(a) &ndash; a[i] + b[j] &ndash; (sum(b) &ndash; b[j] + a[i])<br/>
= sum(a) &ndash; sum(b) &ndash; 2 (a[i] &ndash; b[j])<br/>
= A &ndash; 2 (a[i] &ndash; b[j])<br/>
設 x = a[i] &ndash; b[j]<br/>
|A| &ndash; |A'| = |A| &ndash; |A &ndash; 2x|<br/>
假設A > 0，<br/>
當x在(0, A)之間時，做這樣的交換才能使得交換後的a和b的和之差變小，x越接近A/2效果越好，如果找不到在(0, A)之间的x，則當前的a和b就是答案。<br/>
所以大概算法如下：在a和b中尋找使得x在(0, A)之間，並且最接近A/2的i和j，交換相應的i和j元素，重新計算A後，重複前面的步骤直到找不到(0, A)之間的x為止。<br/>
<code>python
def mean(a, b):  
 if sum(a) &lt; sum(b):  
     array = a  
     a = b  
     b = array  
 diff_sum = sum(a) - sum(b)  
 loop = True  
 while loop:  
     loop = False  
     md = diff_sum / 2  
     for i in range(0, len(a)):  
         for j in range(0, len(b)):  
             x = a[i] - b[j]  
             if x &lt; diff_sum and x &gt; 0:  
                 loop = True  
                 if abs(x - diff_sum / 2) &lt; md:  
                     md = abs (x - diff_sum / 2)  
                     mi = i  
                     mj = j  
     if loop:  
         tmp = a[mi]  
         a[mi] = b[mj]  
         b[mj] = tmp  
         diff_sum = diff_sum - 2 * (b[mj] - a[mi])  
         if diff_sum &lt; 0:  
             array = a  
             a = b  
             b = array  
             diff_sum = - diff_sum  
def main():  
 a = [7, 9, 10]  
 b = [6, 2, 8]  
 mean(a, b)  
 print (a)  
 print (b)  
if __name__ == '__main__':  
 main()  
</code>
<a href="http://www.smallqiao.com/31.html">Origin</a></p></li>
</ol>

]]></content>
  </entry>
  
</feed>
