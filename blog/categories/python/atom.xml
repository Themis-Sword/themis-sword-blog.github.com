<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: python | Themis_Sword's Blog]]></title>
  <link href="http://www.aprilzephyr.com/blog/categories/python/atom.xml" rel="self"/>
  <link href="http://www.aprilzephyr.com/"/>
  <updated>2014-04-02T15:49:49+08:00</updated>
  <id>http://www.aprilzephyr.com/</id>
  <author>
    <name><![CDATA[Themis_Sword]]></name>
    <email><![CDATA[licong0419@outlook.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Python 動態類型(轉)]]></title>
    <link href="http://www.aprilzephyr.com/blog/04022014/python-dong-tai-lei-xing/"/>
    <updated>2014-04-02T15:15:39+08:00</updated>
    <id>http://www.aprilzephyr.com/blog/04022014/python-dong-tai-lei-xing</id>
    <content type="html"><![CDATA[<p>Python中只有一個賦值模型</p>

<h4>1. 缺少類型聲明語句的情況</h4>

<p>在Python中，類型是在運行過程中自動決定的，而不是通過代碼聲明。這意味著沒有必要事聲明變量。只要記住，這個概念實質上對變量，對象和它們之間的關系都適用。那麽這個概念也容易理解並掌握。</p>

<p><strong>A 變量，對象和引用</strong><br/>
變量創建：一個變量，當代碼第一次給它賦值時它就被創建了。之後的賦值將會改變已創建的變量名的值。Python在代碼運行之前先檢測變量名，可以當成是最初的賦值創建變量。<!--more--><br/>
變量類型：變量永遠不會有任何的它關聯的類型信息或約束。類型的概念是存在於對象中而不是變量中。變量原本是通用的。它只是在一個特定的時間點，簡單地引用了一個特定的對像而已。<br/>
變量的使用：當變量出現在表達式中時，它會馬上被當前引用的對像所代替，無論這個對象是什麽類型。<br/>
此外，所有的變量都必須在其使用前明確地賦值。使用未賦值的變量會產生錯誤。<br/>
<code>&gt;&gt;&gt;a=3</code></p>

<p>在概念上說，Python將執行三個不同的步驟去完成這個請求。<br/>
1) 創建一個對象來代表值3<br/>
2) 創建一個變量a，如果它還沒有創建的話<br/>
3) 將變量與新的對象3連接</p>

<p>在python中從變量到對象的連接稱作引用。引用是一種關系，以內存中的指針形式實現。<br/>
* 變量 是一個系統表的元素，擁有指向對象的連接空間。<br/>
* 對象 是被分配的一塊內存，有足夠的空間去表現它們所代表的值。<br/>
* 引用 是自動形成的從變量到對象的指針。</p>

<p>每一個對象都用兩個標準的頭部信息：一個類型標誌符去標識這個對象的類型，以及一個引用的計數器，用來決定是不是可以回收這個對象。</p>

<p><strong>B 類型屬於對象，而不是變量</strong><br/>
Python中的類型是與對象相關聯的，而不是和變量關聯。<br/>
變量沒有類型，變量指向對象。對象有類型，知道自己的類型，每個對象都包含了一個頭部信息，其中標記了這個對象的類型。</p>

<p><strong>C 對象的垃圾收集</strong><br/>
對象生命結束時發生了什麽變化？<br/>
每當一個變量名被賦與了一個新的對象，之前的那個對象占用的空間就會被收回（如果它沒有被其他變量名和對象所引用).這種自動回收對象空間的技術稱作垃圾收集。<br/>
在內部，Python是通過保持用每個對象中的計數器記錄引用指到這個對象上的次數來完成這一功能。一旦（並精確在同一時間）這個計數器被設置為零，這個對象的內存空間就會自動收回。垃圾收集最直接的，可感受到的好處就是這意味著可以在腳本中任意使用對象而不需要考慮釋放內存空間。<br/>
```</p>

<blockquote><blockquote><blockquote><p>x=42
id(x)
674748828
x=&ldquo;cli&rdquo;
id(x)  <br/>
676367648
```</p></blockquote></blockquote></blockquote>

<h4>2. 共享引用</h4>

<p>上面所講都是單個變量被賦值引用了多個對象的情況。現在，在交互模式下，引入另一個變量，並看一下變量名和對象的變化。<br/>
```</p>

<blockquote><blockquote><blockquote><p>a=10
b=a
id(a)
674749212
id(b)
674749212
```<br/>
第二行會使用python創建變量b。使用的是變量a,並且它在這裏沒有被賦值，所以它被替換成其應用的對象10，從而b也成為這個對象的一個引用。實際效果就是變量a和b都引用相同的對象（也就是說指向了相同的內存空間。在Python中稱作是共享引用&mdash;多個變量名應用了同一個對象。)</p></blockquote></blockquote></blockquote>

<p>```</p>

<blockquote><blockquote><blockquote><p>a=10
b=a<br/>
a=&lsquo;cli&rsquo;
id(a)
676367648
id(b)
674749212
```<br/>
變量a改變了，但是不影響變量b.這完全可以說明變量b是指向對象10內存空間的。</p></blockquote></blockquote></blockquote>

<p>在ptyhon中，變量總是一個指向對象的指針，而不是可以改變的內存區域的標簽。給一變量賦一個新的值，並不是替換了原始的對象，而是讓這個變量去引用完全不同的一個對象。實際的效果就是對一個變量賦值，僅僅會影響那個被賦值的變量。</p>

<p><strong>A 共享引用和在原處修改</strong><br/>
有一些對象和類型確實會在實地改變對象。例如，在一個列表中對一個偏移進行賦值確實會改變這個列表對象，而不是生成一個新的列表對象。<br/>
```</p>

<blockquote><blockquote><blockquote><p>T1=[11,12,13]
T2=T1
T1
[11, 12, 13]
T2
[11, 12, 13]
T1=22
T1
22
T2
[11, 12, 13]
```</p></blockquote></blockquote></blockquote>

<p>這個和先前一樣T1改變了T2沒有改變，T2改變也不影響T1<br/>
```</p>

<blockquote><blockquote><blockquote><p>T1=[11,12,13]
T2=T1
T1
[11, 12, 13]
T2
[11, 12, 13]
T2[1]=33   <br/>
T1
[33, 12, 13]
T2
[33, 12, 13]
<code>  
發現T2改變了，T1也跟這改變了  
同樣T1改變了，T2也改變了  
</code>
T1[1]=99<br/>
T2
[33, 99, 13]
T1
[33, 99, 13]
```<br/>
這裏T1沒有改變，改變了T1所引用對象的一個元素。這類修改會覆蓋列表對象中的某部分。因為這個列表對象是與其他對象共享的（被其他對象引用），那麽一個像這樣在原處的改變不僅僅會對T1有影響。必須意識到當做了這樣的修改，它會影響程序的其他部分。</p></blockquote></blockquote></blockquote>

<p>如果不想要這樣的現象發生，需要Python拷貝對象，而不是創建引用。方法包括內置列表函數以及標準庫的copy模塊，最常用的辦法就是從頭到尾的分片T1[:]<br/>
```</p>

<blockquote><blockquote><blockquote><p>T1=[11,12,13]
T2=T1[:]
T1
[11, 12, 13]
T2
[11, 12, 13]
T1[0]=99
T1
[99, 12, 13]
T2
[11, 12, 13]
id(T1)
676366604
id(T2)
675542060
<code>  
T1和T2指向不同的對象，所以不會相互影響。  
註意：這種分片技術不會引用在其他的可變的核心類型上（字典，因為它們不是序列），對字典應該使用D.copy（）方法.而且，註意標準庫中的copy模塊有一個通用的拷貝任意對象的調用，也有一個拷貝嵌套對象的結構的調用.  
</code>
X={&lsquo;name&rsquo;:&lsquo;cli&rsquo;,&lsquo;age&rsquo;:27}<br/>
import copy
Y=copy.copy(X)
X
{&lsquo;age&rsquo;: 27, &lsquo;name&rsquo;: &lsquo;cli&rsquo;}
Y
{&lsquo;age&rsquo;: 27, &lsquo;name&rsquo;: &lsquo;cli&rsquo;}
id(X)
676370468
id(Y)
676414436
X={&lsquo;name&rsquo;:{&lsquo;FirstName&rsquo;:&lsquo;cli&rsquo;,&lsquo;LastName&rsquo;:&lsquo;cli&rsquo;},&lsquo;age&rsquo;:27}  <br/>
X
{&lsquo;age&rsquo;: 27, &lsquo;name&rsquo;: {&lsquo;LastName&rsquo;: &lsquo;cli&rsquo;, &lsquo;FirstName&rsquo;: &lsquo;cli&rsquo;}}
Y=copy.copy(X)
Y
{&lsquo;age&rsquo;: 27, &lsquo;name&rsquo;: {&lsquo;LastName&rsquo;: &lsquo;cli&rsquo;, &lsquo;FirstName&rsquo;: &lsquo;cli&rsquo;}}
Z=copy.deepcopy(X)
Z
{&lsquo;age&rsquo;: 27, &lsquo;name&rsquo;: {&lsquo;LastName&rsquo;: &lsquo;cli&rsquo;, &lsquo;FirstName&rsquo;: &lsquo;cli&rsquo;}}
```</p></blockquote></blockquote></blockquote>

<p><strong>B 共享引用和相等</strong>
```</p>

<blockquote><blockquote><blockquote><p>x=33
x=&lsquo;cli&rsquo;
```<br/>
因為Python緩存並復用了小的整數和小的字符串，就像前文提到的那樣，這裏對象33也許不像前期所說的被收回，相反，它將可能仍保持在一個系統表中，等待下一次你的代碼生成另一個33來利用。盡快如此，大多數種類的對象都會在不再引用時馬上回收。對於那些不會被回收的，緩沖機制與代碼並沒有什麽關系。</p></blockquote></blockquote></blockquote>

<p>判斷是否相等<br/>
```</p>

<blockquote><blockquote><blockquote><p>L=[1,2,3]
M=L
L==M
True
L is M
True
<code>  
==檢查對象是否有相同的值。 is操作符，檢查對象的同一性。如果兩個變量名精準地指向同一個對象，它會返回True。所以這是一種更嚴格的相等測試。  
實際上,is只是比較現實引用的指針。所以如果必要的話是代碼中檢測共享引用的一種方法。如果變量名引用值相等。但是為不同的對象，它的返回值將是False.  
</code>
L=[1,2,3]
M=[1,2,3]
L==M
True
L is M
False
id(L)
676367788
id(M)
676367724
```<br/>
通過id()函數可以看到兩個變量指向不同的對象。</p></blockquote></blockquote></blockquote>

<p>```</p>

<blockquote><blockquote><blockquote><p>X=33
Y=33
X==Y
True
X is Y
True
id(X)
674748936
id(Y)
674748936
<code>  
這個is測試返回True因為小的整數和字符串被緩存被復用了。
如果想更進一步了解，可以向Python查詢一個對象應用的次數：在sys模塊中的getrefcount函數返回對象應用的次數。  
</code>
import sys
sys.getrefcount(33)
13
sys.getrefcount(1)
427
sys.getrefcount(00)
296
sys.getrefcount(99)
6
```</p></blockquote></blockquote></blockquote>

<p><a href="http://ipseek.blog.51cto.com/1041109/786518">Origin</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Python 文件處理]]></title>
    <link href="http://www.aprilzephyr.com/blog/03312014/python-wen-jian-chu-li/"/>
    <updated>2014-03-31T17:48:17+08:00</updated>
    <id>http://www.aprilzephyr.com/blog/03312014/python-wen-jian-chu-li</id>
    <content type="html"><![CDATA[<p>python對文件的處理的兩個內建函數：<br/>
open()、file()，這個兩函數提供了初始化輸入\輸出（I\O）操作的通用接口。兩函數的功能相同。<br/>
基本用法：<br/>
file_object=open(filename, access_mode=&lsquo;r&rsquo;, buffering=-1）
file_object 是定義一個打開文件的對象<br/>
access_mode 是打開文件的模式；通常，文件使用模式  &lsquo;r&rsquo;,&lsquo;w&rsquo;,&lsquo;a&rsquo; 來打開，分別代表，讀取，寫入，追加。<br/>
&lsquo;r&rsquo; 模式打開已經存在的文件<br/>
&lsquo;w&rsquo; 模式打開的文件若存在則首先清空，再加入內容。<br/>
&lsquo;a&rsquo; 這個模式是追加內容到文件中<!--more--><br/>
註. &lsquo;b&rsquo; 模式這個是打開二進制文件，對於unix-like/unix類型的系統'b'模式是可有可無的。<br/>
buffering 訪問文件所采用的緩沖方式。其中0表示不緩沖，1表示只緩沖一行數據，任何其它大於1的值代表使用給定的值作為緩沖區大小。不給定此參數或者參數為負數都表示使用系統默認的緩沖機制。<br/>
使用open打開文件之後一定記得調用close()關閉文件。</p>

<p>常用的文件訪問方式如下：<br/>
r        以讀方式打開<br/>
rU或Ua   以讀方式打開同時提供通用換行符支持<br/>
w        以寫方式打開<br/>
a        以追加方式打開<br/>
r+       以讀寫方式打開<br/>
w+       以讀寫方式打開<br/>
a+       以讀寫方式打開</p>

<p>文件的輸入：<br/>
python中有三個方法來處理文件內容的輸入：<br/>
read() 一次讀取全部的文件內容。<br/>
readline() 每次讀取文件的一行。<br/>
readlines() 讀取文件的所有行，返回一個字符串列表。</p>

<p>寫數據：<br/>
<code>python
file_object = open('thefile.txt', 'w')
file_object.write(all_the_text)
file_object.close( )
</code></p>

<p>寫入多行：<br/>
<code>file_object.writelines(list_of_text_strings)</code></p>

<p>seek(offset,where):  默認值where=0表示從起始位置移動"offset"個字節，where=1表示從當前位置移動"offset"個字節，where=2表示從結束位置移動"offset"個字節。當有換行時，會被換行截斷。seek()無返回值，故值為None。</p>

<p>tell():  文件的當前位置,即tell是獲得文件指針位置，受seek、readline、read、readlines影響，不受truncate影響。</p>

<p>truncate(n):  從文件的首行首字符開始截斷，截斷文件為n個字符；無n表示從當前位置起截斷；截斷之後n後面的所有字符被刪除。其中win下的換行代表2個字符大小。<br/>
``` python</p>

<pre><code>  fso = open("f:\\a.txt",'w+')    #以w+方式，並非a方式打開文件，故文件原內容被清空
  print fso.tell()    #文件原內容被清空，故此時tell()=0

  fso.write("abcde\n")  #寫入文件abcde\n，因為換行\n占兩個字符，故共寫入7個字符
  print fso.tell()  #此時tell()=7

  fso.write("fghwm")  #又寫入文件fghwm，故此時文件共寫入7+5 =142個字符
  print fso.tell()  #此時tell()=12 

  fso.seek(1, 0)  #從起始位置即文件首行首字符開始移動1個字符
  print fso.tell()   #此時tell() =1

  print  fso.readline()  #讀取當前行，即文件的第1行，但是從第二個字符(tell()+1)開始讀，結果為:bcde。'若換成for讀取整個文件或read讀取整個文件則結果為bcdefghwm     

  print fso.tell()   #因為readline此時tell() =7,

  fso.truncate(8)  #從寫入後文件的首行首字符開始階段，截斷為8個字符，即abcde\nf，即文件的內容為：abcde\nf

  print fso.tell()   #tell() 依舊為7,並為受truncate(8)影響，但是此時文件內容為abcde\nf

  print  fso.readline()  #從tell()+1=8開始讀取，讀取當前行內容：f

  fso.close()
</code></pre>

<p>```</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Python os模塊 &amp; sys模塊]]></title>
    <link href="http://www.aprilzephyr.com/blog/03312014/python-osmo-kuai-and-sysmo-kuai/"/>
    <updated>2014-03-31T16:06:01+08:00</updated>
    <id>http://www.aprilzephyr.com/blog/03312014/python-osmo-kuai-and-sysmo-kuai</id>
    <content type="html"><![CDATA[<p><strong>1. os模塊</strong><br/>
Python os模塊包含普遍的操作系統功能。如果你希望你的程序能夠與平臺無關的話，這個模塊是尤為重要的。</p>

<p>1) os.name<br/>
輸出字符串指示正在使用的平臺。如果是window 則用'nt'表示，對於Linux/Unix用戶，它是'posix'。<br/>
2) os.mkdir(path [,mode=0777])<br/>
創建目錄<br/>
3) os.rmdir()<br/>
刪除目錄<br/>
4) os.mkdirs()<br/>
創建多層目錄，類似系統makedir -p<br/>
5) os.removedirs()<br/>
刪除多層目錄，每層都是空的，除了要刪除的目錄外。<br/>
6) os.getcwd()<br/>
函數得到當前工作目錄，即當前Python腳本工作的目錄路徑。<br/>
7) os.listdir()<br/>
返回指定目錄下的所有文件和目錄名。
``` python</p>

<blockquote><blockquote><blockquote><p>import os
os.listdir(os.getcwd())
[&lsquo;.bash_history&rsquo;, &lsquo;.bundler&rsquo;, &lsquo;.CFUserTextEncoding&rsquo;, &lsquo;.config&rsquo;, &lsquo;.DS_Store&rsquo;, &lsquo;.gem&rsquo;, &lsquo;.gitconfig&rsquo;, &lsquo;.matplotlib&rsquo;, &lsquo;.ssh&rsquo;, &lsquo;.Trash&rsquo;, &lsquo;.Trash-500&rsquo;, &lsquo;.vim&rsquo;, &lsquo;.viminfo&rsquo;, &lsquo;Applications&rsquo;, &lsquo;Applications (Parallels)&rsquo;, &lsquo;Desktop&rsquo;, &lsquo;Documents&rsquo;, &lsquo;Downloads&rsquo;, &lsquo;Library&rsquo;, &lsquo;Movies&rsquo;, &lsquo;Music&rsquo;, &lsquo;octopress&rsquo;, &lsquo;Pictures&rsquo;, &lsquo;Public&rsquo;, &lsquo;PycharmProjects&rsquo;, &lsquo;\xe7\x99\xbe\xe5\xba\xa6\xe4\xba\x91\xe5\x90\x8c\xe6\xad\xa5\xe7\x9b\x98&rsquo;]</p>

<p>```  <!--more-->
8) os.remove()<br/>
刪除一個文件。<br/>
9) os.system()<br/>
運行shell命令。<br/>
10) os.sep<br/>
可以取代操作系統特定的路徑分隔符。<br/>
11) os.linesep<br/>
給出當前平台使用的行終止符。<br/>
12) os.path.split()<br/>
函數返回一個路徑的目錄名和文件名<br/>
13) os.path.isfile()和os.path.isdir()函數<br/>
分別檢驗給出的路徑是一個文件還是目錄，給出True或者False。<br/>
14) os.path.exists()<br/>
檢驗給出的路徑是否真實的存在，給出True或者False。<br/>
15) os.path.abspath(name)<br/>
獲得絕對路徑。<br/>
16) os.path.normpath(path)<br/>
規範path的字符串形式。<br/>
17) os.path.getsize(name)<br/>
獲得文件大小，如果name是目錄返回0L。<br/>
18) os.path.splitext()<br/>
分離文件名與擴展名。<br/>
19) os.path.join(path,name)<br/>
連接目錄與文件名或目錄。<br/>
20) os.path.basename(path)<br/>
返回文件名。<br/>
21) os.path.dirname(path)<br/>
返回文件路徑。</p></blockquote></blockquote></blockquote>

<p><strong>2. sys模塊</strong><br/>
1) sys.argv<br/>
命令行參數List，第一個元素是程序本身路徑。<br/>
2) sys.modules.keys()<br/>
返回所有已經導入的模塊列表。<br/>
3) sys.exc_info()<br/>
獲取當前正在處理的異常類,exc_type、4) exc_value、exc_traceback當前處理的異常詳細信息。<br/>
5) sys.exit(n)<br/>
退出程序，正常退出時exit(0)。<br/>
6) sys.hexversion<br/>
獲取Python解釋程序的版本值，16進制格式如：0x020403F0。<br/>
7) sys.version<br/>
獲取Python解釋程序的版本信息。<br/>
8) sys.maxint<br/>
最大的Int值。<br/>
9) sys.maxunicode<br/>
最大的Unicode值。<br/>
10) sys.modules<br/>
返回系統導入的模塊字段，key是模塊名，value是模塊。<br/>
11) sys.path<br/>
返回模塊的搜索路徑，初始化時使用PYTHONPATH環境變量的值。<br/>
12) sys.platform<br/>
返回操作系統平臺名稱。<br/>
13) sys.stdout<br/>
標準輸出。<br/>
14) sys.stdin<br/>
標準輸入。<br/>
15) sys.stderr<br/>
錯誤輸出。<br/>
16) sys.exc_clear()<br/>
用來清除當前線程所出現的當前的或最近的錯誤信息。<br/>
17) sys.exec_prefix<br/>
返回平臺獨立的python文件安裝的位置。<br/>
18) sys.byteorder<br/>
本地字節規則的指示器，big-endian平臺的值是'big',little-endian平臺的值是'little'。<br/>
19) sys.copyright<br/>
記錄python版權相關的東西。<br/>
20) sys.api_version<br/>
解釋器的C的API版本。<br/>
21) sys.version_info<br/>
<code>&gt;&gt;&gt; sys.version_info(major=2, minor=7, micro=5, releaselevel='final', serial=0)</code><br/>
22) sys.displayhook(value)<br/>
如果value非空，這個函數會把他輸出到sys.stdout，並且將他保存進__builtin__._.指在python的交互式解釋器裏，'_&lsquo;代表上次你輸入得到的結果，hook是鉤子的意思，將上次的結果鉤過來。<br/>
23) sys.getdefaultencoding()<br/>
返回當前你所用的默認的字符編碼格式。<br/>
24) sys.getfilesystemencoding()<br/>
返回將Unicode文件名轉換成系統文件名的編碼的名字。<br/>
25) sys.setdefaultencoding(name)<br/>
用來設置當前默認的字符編碼，如果name和任何一個可用的編碼都不匹配，拋出LookupError，這個函數只會被site模塊的sitecustomize使用，一旦別site模塊使用了，他會從sys模塊移除。<br/>
26) sys.builtin_module_names<br/>
Python解釋器導入的模塊列表。<br/>
27) sys.executable<br/>
Python解釋程序路徑。<br/>
28) sys.getwindowsversion()<br/>
獲取Windows的版本。<br/>
29) sys.stdin.readline()<br/>
從標準輸入讀一行。<br/>
30) sys.stdout.write(&ldquo;a&rdquo;)<br/>
屏幕輸出a。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Python 字符串]]></title>
    <link href="http://www.aprilzephyr.com/blog/03282014/python-zi-fu-chuan/"/>
    <updated>2014-03-28T01:15:00+08:00</updated>
    <id>http://www.aprilzephyr.com/blog/03282014/python-zi-fu-chuan</id>
    <content type="html"><![CDATA[<p><strong>1. 轉義字符</strong></p>

<table>
<tbody>
<tr><td><em>轉義字符</em></td><td><em>描述</em></td></tr>  
<tr><td>\\(在行尾)</td><td>續行符</td></tr>  
<tr><td>\\\ </td><td>反斜槓</td></tr>  
<tr><td>\\' </td><td>單引號</td></tr>  
<tr><td>\\" </td><td>雙引號</td></tr>  
<tr><td>\a</td><td>響鈴</td></tr>  
<tr><td>\b</td><td>退格(Backspace)</td></tr>  
<tr><td>\e</td><td>轉義</td></tr>  
<tr><td>\000</td><td>空</td></tr>  
<tr><td>\n</td><td>換行</td></tr>  
<tr><td>\v</td><td>縱向製表符</td></tr>  
<tr><td>\t</td><td>橫向製表符</td></tr>  
<tr><td>\r</td><td>回車</td></tr>  
<tr><td>\f</td><td>換頁</td></tr>  
<tr><td>\oyy</td><td>八進制數yy代表的字符，例如:\o12代表換行</td></tr>  
<tr><td>\xyy</td><td>十進制數yy代表的字符，例如:\x0a代表換行</td></tr>  
<tr><td>\uhhhh</td><td>Unicode 16位的十六進製值</td></tr>  
<tr><td>\uhhhhhhhh</td><td>Unicode 32位的十六進製值</td></tr>  
<tr><td>\other</td><td>其它的字符以普通格式輸出</td></tr>  
</tbody></table>


<!--more-->


<p><strong>2. 格式化表達</strong></p>

<table><tbody>  
<tr><td><em>格式化表達</em></td><td><em>描述</em></td></tr>  
<tr><td>%s</td><td>字符串</td></tr>  
<tr><td>%r</td><td>repr輸出的字符串</td></tr>  
<tr><td>%d</td><td>十進制整數</td></tr>  
<tr><td>%i</td><td>整數</td></tr>  
<tr><td>%u</td><td>無符號整數</td></tr>  
<tr><td>%o</td><td>八進制</td></tr>  
<tr><td>%x</td><td>十六進制</td></tr>  
<tr><td>%X</td><td>十六進制(大寫)</td></tr>  
<tr><td>%e</td><td>指數</td></tr>  
<tr><td>%E</td><td>指數(大寫)</td></tr>  
<tr><td>%f</td><td>十進制浮點數</td></tr>  
<tr><td>%F</td><td>十進制浮點數(大寫)</td></tr>  
<tr><td>%g</td><td>浮點e或f</td></tr>  
<tr><td>%G</td><td>浮點E或F</td></tr>  
</tbody></table>


<p></p>

<p><strong>3. 索引和切片</strong><br/>
Python中的字符串是有序的字符集合，所以可以通過位置（索引）獲取對應的元素。和c語言中一樣，python的索引也是從0開始的，而且支持使用負索引的方法來獲取元素，一個負的索引可以看做是從字符串結尾處反向計數，-1就表示字符串的最後一個字符。當然也可以理解為負索引與字符串長度相加得到的正索引，即s[-n]等於s[-n+len(s)]。<br/>
``` python</p>

<blockquote><blockquote><blockquote><p>s = &ldquo;hello"<br/>
s[0]<br/>
&lsquo;1'<br/>
s = "hello"<br/>
s[0]<br/>
'h'<br/>
s[-1]<br/>
'o'<br/>
s[0:3]<br/>
'hel'<br/>
s[1:]<br/>
'ello'<br/>
s[:-1]<br/>
'hell&rsquo;
<code>  
其實分片的完整格式為s[start:end:side]，意思就是從start開始到end-1，每隔side個元素取一個元素，返回值為所有取到的元素組成的字符串，side默認值為1。  
side可以取負值，例如s[::-1]會返回”olleh”，實際效果就是對字符串進行了反轉。這裏需要註意的是，如果side為負值，兩個邊界也要進行反轉，s[4:1:-1]就是從4開始反向取到2得到的字符串，如果在sride為負的情況下還是第一個邊界大於第二個邊界那樣的使用的話將返回一個空的字符串。  
</code> python
s[::2]<br/>
&lsquo;hlo'<br/>
s[::-1]<br/>
'olleh'<br/>
s[4:1:-1]<br/>
'oll'<br/>
s[0:4:-1]<br/>
&rsquo;&lsquo;<br/>
```</p></blockquote></blockquote></blockquote>

<p><strong>4. 字符串方法</strong><br/>
<em>A 大小寫</em><br/>
S.upper() 全部大寫<br/>
S.lower() 全部小寫<br/>
S.swapcase() 大小寫互換<br/>
S.capitalize() 首字母大寫，其余都小寫<br/>
S.title() 每個單詞的首字母大寫，其余不變</p>

<p><em>B 對齊</em><br/>
S.ljust(width[, fill]) 獲取固定長度width，左對齊，多余位用fill填充，默認空格<br/>
S.rjust(width[, fill]) 右對齊<br/>
S.center(width[, fill]) 居中<br/>
S.zfill(width) 右對齊，左邊不足的位置用0補齊，相當於S.rjust(width,&ldquo;0&rdquo;)<br/>
如果width&lt;=len(S)，返回於原字符串相同的字符串。</p>

<p><em>C 查找替換</em><br/>
S.find(sub[, start[, end]]) 返回在範圍start到end(不含end)中第一個sub的索引。<br/>
S.rfind(sub[, start[, end]]) 從右邊開始查找，也就是返回在範圍start到end(不含end)中最後一個sub的索引。<br/>
S.index(sub[, start[, end]])功能與find()相同，不同之處在於find()未找到的時候會返回-1，而index()會拋出異常。<br/>
S.rindex(sub[, start[, end]])功能與rfind()相同，不同之處在於find()未找到的時候會返回-1，而index()會拋出異常。<br/>
S.count(sub[, start[, end]]) 返回在範圍start到end(不含end)中sub的個數。<br/>
start默認為0，end默認為len(S)。<br/>
S.replace(old, new[, count])將字符串中的old替換為new，count為替換的次數，未指定的話就是替換所有。<br/>
S.translate(table [,deletechars]) 刪除S中deletechars包含的字符，然後將剩下的字符用table定義的關系進行映射。table是string.maketrans()生成的。</p>

<p><em>D 去空白或指定字符</em><br/>
S.strip([chars]) 去除字符串S兩邊的chars,若chars未指定，則去除兩邊的空白，包括空格、\n、\f、\r、\t和\v。<br/>
S.lstrip([chars]) 去除左邊的chars，未指定同上。<br/>
S.rstrip([chars]) 去除右邊的chars，未指定同上。</p>

<p><em>E 分割和組合</em><br/>
S.split([sep [,maxsplit]]) 以sep為分隔符切割字符串S，不指定sep默認為默認為空白，maxsplit為最大分割次數，未指定則全部分割，返回列表。<br/>
S.rsplit([sep [,maxsplit]]) 只是和split反向相反，split從頭到尾，rsplit從尾到頭。<br/>
S.splitlines([keepends]) 按行分割字符串，若keepends指定並且為True，則保留換行符，反之不保留。<br/>
S.partiton(sep)以sep作為分隔符將S分割為兩個start和end部分，並返回(start,sep, end)這樣格式的元組，若sep沒有找到，則返回S和兩個空串組成的元組(S, &lsquo;&rsquo;, &lsquo;&rsquo;)。<br/>
S.rpartition(sep)從右邊開始，以sep作為分隔符將S分割為兩個start和end部分，並返回(start,sep, end)，若sep沒有找到，則返回兩個空串和S組成的元組(&lsquo;&rsquo;, &lsquo;&rsquo;, S)。<br/>
S.join(iterable) 將叠代器iterable的字符串連接在一起，並用分隔符S隔開，一般來說在連接列表的時候都使用空字符串或者空格作為分隔符，返回字符串。</p>

<p><em>F 判斷</em><br/>
S.startswith(prefix[, start[, end]])判斷字符串start到end(不含end)是否是以prefix開頭，默認start為0，end為len(S)，返回布爾值。<br/>
S.endswith(suffix[, start[, end]]) 判斷字符串start到end(不含end)是否是以suffix結尾，默認start為0，end為len(S)，返回布爾值。<br/>
S.isalnum() 是否全為字母或數字，返回布爾值。<br/>
S.isalpha() 是否全為字母，返回布爾值。<br/>
S.isdigit() 是否全為數字0-9，返回布爾值。<br/>
S.islower() 是否全是小寫。<br/>
S.isupper() 是否全是大寫。<br/>
S.isspace() 是否全是空白。<br/>
S.istitle() 是否符合title的格式——每個單詞的首字母大寫。<br/>
上述這些函數中，若S為空串，則均返回False。</p>

<p><em>G 編碼</em><br/>
S.decode([encoding[,errors]]) 將字符串S解碼為unicode，encoding為S原來的編碼方式。<br/>
S.encode([encoding[,errors]]) 將unicodeS編碼為python中的字符串，參數指定對應的編碼方式。<br/>
errors指定出錯時對應的操作，默認的strict會在編碼/解碼失敗的時候拋出異常，ignore則忽略。<br/>
關於編碼方式還是有很多的知識的，後續再做研究。</p>

<p><em>H 其他</em><br/>
S.format(*args, **kwargs)<br/>
format也是用來格式化字符串的，argv指定的變量可以在S中用{index}來替換，而kwargs則是對應的變量。如果後面的數據為字典，可以使用{&lt;index|var>[key]}來替換其對應的值。當然還可以指定對應的寬度、精度以及對其格式，{index:[fill][&lt;|>|^][width][.precision][typecode]}。<br/>
fill設置填充位，默認為空格；&lt;左對齊，>右對齊，^居中；寬度和類型見後面格式化表達式部分。註意這裏的精度專指說浮點型數據，整型是不能使用精度的，字符創設置了也沒啥作用。<br/>
``` python</p>

<blockquote><blockquote><blockquote><p>&ldquo;{0},{2},{1},{s}&rdquo;.format(1,2,3,s=&ldquo;four&rdquo;)<br/>
&lsquo;1,3,2,four'<br/>
&ldquo;{0:$&lt;3},{2:^5.2f},{1},{s:>10.6s}&rdquo;.format(1,2,3,s=&ldquo;four&rdquo;)<br/>
'1$$,3.00 ,2,      four'<br/>
&ldquo;{0:&lt;3},{2:^5d},{1},{s:>10s}&rdquo;.format(1,2,3,s=&ldquo;four&rdquo;)<br/>
'1  ,  3  ,2,      four'<br/>
&ldquo;{0:&lt;03},{2:^05.2d},{1},{s:>10s}&rdquo;.format(1,2,3,s=&ldquo;four&rdquo;)<br/>
Traceback (most recent call last):<br/>
  File &ldquo;<stdin>&rdquo;, line 1, in <module><br/>
ValueError: Precision not allowed in integer format specifier<br/>
&ldquo;{0:&lt;03},{2:^5.2f},{1},{s:>10.6s}&rdquo;.format(1,2,3,s=&ldquo;four&rdquo;)<br/>
'100,3.00 ,2,      four&rsquo;
```<br/>
S.expandtabs([tabsize]) 將字符串中的制表符替換為tabsize個空格，默認為8。</p></blockquote></blockquote></blockquote>

<p><em>I 3.0新增</em><br/>
S.isdecimal() 是否全是十進制數字(多語言數字)。<br/>
S.isidentifier() 是否全是合法標識符。<br/>
S.isnumeric() 是否只包含數字字符。<br/>
S.isprintable() 是否全是可打印字符。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Python import與from...import...(轉)]]></title>
    <link href="http://www.aprilzephyr.com/blog/03272014/python-importyu-from-dot-dot-dot-import-dot-dot-dot/"/>
    <updated>2014-03-27T14:23:52+08:00</updated>
    <id>http://www.aprilzephyr.com/blog/03272014/python-importyu-from-dot-dot-dot-import-dot-dot-dot</id>
    <content type="html"><![CDATA[<p><strong>1. 簡單說說python import與from&hellip;import&hellip;.(python模塊)</strong></p>

<p>在python用import或者from&hellip;import來導入相應的模塊。模塊其實就一些函數和類的集合文件，它能實現一些相應的功能，當我們需要使用這些功能的時候，直接把相應的模塊導入到我們的程序中，我們就可以使用了。這類似於C語言中的include頭文件，Python中我們用import導入我們需要的模塊。 <!--more-->
``` python
import sys
print(&lsquo;================Python import mode==========================&rsquo;);
print (&lsquo;The command line arguments are:&rsquo;)
for i in sys.argv:</p>

<pre><code>print (i)
</code></pre>

<p>print (&lsquo;\n The python path&rsquo;,sys.path)</p>

<p>from sys import argv,path #導入特定的成員
print(&lsquo;================python from import===================================&rsquo;)
print(&lsquo;path:&rsquo;,path)</p>

<p>如果你要使用所有sys模塊使用的名字，你可以這樣：</p>

<p>from sys import *
print(&lsquo;path:&rsquo;,path)
```<br/>
從以上我們可以簡單看出：</p>

<p>\==========<br/>
導入mode，import與from&hellip;import的不同之處在於，簡單說：
如果你想要直接輸入argv變量到你的程序中而每次使用它時又不想打sys，則可使用：from sys import argv。<br/>
一般說來，應該避免使用from..import而使用import語句，因為這樣可以使你的程序更加易讀，也可以避免名稱的沖突。<br/>
\==========</p>

<p>在使用 from xxx import * 時，如果想精準的控制模塊導入的內容，可以使用 <strong>all</strong> = [xxx,xxx] 來實現，例如：<br/>
``` python
<strong>all</strong> = [&lsquo;a&rsquo;,&lsquo;b&rsquo;] #__為雙橫線
class two():</p>

<pre><code>def __init__(self):
    print('this is two')
</code></pre>

<p>a = &lsquo;this is two a&rsquo;
b = &lsquo;this is two b&rsquo;
if <strong>name</strong>==&lsquo;<strong>main</strong>&rsquo;:</p>

<pre><code>t = two()
</code></pre>

<p>one.py</p>

<p>from two import *
print a
print b
t = two()</p>

<p>這時，類two()將不會被 import *導入進來
```</p>

<p><strong>2. 關於import中的路徑搜索問題</strong><br/>
類似於頭文件，模塊也是需要系統的搜索路徑的，下面的命令即是系統默認的搜索路徑，當你導入一個模塊時，系統就會在下面的路徑列表中搜索相應的文件。<br/>
``` python</p>

<blockquote><blockquote><blockquote><p>print(sys.path)</p></blockquote></blockquote></blockquote>

<p>[&lsquo;&rsquo;, &lsquo;/usr/lib64/python26.zip&rsquo;, &lsquo;/usr/lib64/python2.6&rsquo;, &lsquo;/usr/lib64/python2.6/plat-linux2&rsquo;, &lsquo;/usr/lib64/python2.6/lib-tk&rsquo;, &lsquo;/usr/lib64/python2.6/lib-old&rsquo;, &lsquo;/usr/lib64/python2.6/lib-dynload&rsquo;, &lsquo;/usr/lib64/python2.6/site-packages&rsquo;, &lsquo;/usr/lib64/python2.6/site-packages/gst-0.10&rsquo;, &lsquo;/usr/lib64/python2.6/site-packages/gtk-2.0&rsquo;, &lsquo;/usr/lib64/python2.6/site-packages/webkit-1.0&rsquo;, &lsquo;/usr/lib/python2.6/site-packages&rsquo;]</p>

<p>(從例中，我們可以看到python會首先在當前工作目錄裏去找)
```</p>

<p>如果沒有找導相應的內容，則報錯：<br/>
``` python</p>

<blockquote><blockquote><blockquote><p>import syssTraceback (most recent call last):  File &ldquo;<stdin>&rdquo;, line 1, in <module>ImportError: No module named syss</p></blockquote></blockquote></blockquote>

<p>當然，我們也可以自行添加要搜索的路徑，調用列表的append方法即可：
import sys
sys.path.append(&lsquo;/usr/xx/python2.6&rsquo;)
```</p>

<p><strong>3. 創建自己的模塊</strong><br/>
在創建之前，有一點需要說明一下：每個Python模塊都有它的__name__（就每個對象都自己的__doc__一樣）。通過<strong>name</strong>我們可以找出每一個模塊的名稱，一般__name__的值有種：1 一是主模塊名稱為："__main__&ldquo;(可以理解為直接運行的那個文件)，2 那些被主模塊導入的模塊名稱為：文件名字（不加後面的.py）。有__name__是很有用的，因為我們可以通過 if __name__  == &lsquo;xxx&rsquo; 判斷來執行那些模塊，那些模塊不被執行。另外：每個Python程序也是一個模塊。它擴展名為：.py擴展名。</p>

<p>下面，我們通過例子來說明：<br/>
首先：我們創建模塊：mymodel.py<br/>
``` python</p>

<h1>!/user/bin/python</h1>

<h1>Filename:mymodel.py</h1>

<p>version = &lsquo;1.0&rsquo;
def sayHello():</p>

<pre><code>print ('Hello world')
</code></pre>

<p>def modelName():</p>

<pre><code>return __name__#返回它自己的名稱
</code></pre>

<h1>end of model</h1>

<p><code>  
以上語句注意：  
1) 這個模塊應該被放置在我們輸入它的程序的同一個目錄中，或者在sys.path所列目錄之一。  
2) 你已經看到，它與我們普通的Python程序相比並沒有什麽特別之處。  
然後：我們在test.py中來調用此模塊：test.py  
</code> python
import sys,mymodel
sys.path.append(&rsquo;D:/xx/PythonSERVER/python31/Code')#提供搜索路径
print(<strong>name</strong>) #此處打印主模塊的名稱：<strong>main</strong>
mymodel.sayHello()
print(&lsquo;Version&rsquo;,mymodel.version)
print(&lsquo;Model Name&rsquo;,mymodel.modelName())#打印被導入模塊的名稱: mymodel</p>

<p>我們使用from..import&hellip;</p>

<p>print(&lsquo;======================from&hellip;..import=====================================&rsquo;)
from mymodel import *
print(<strong>name</strong>)#此處打印主模塊的名稱：<strong>main</strong>
sayHello()
print(&lsquo;Version&rsquo;,version)
print(&lsquo;Model Name&rsquo;,modelName()) #打印被導入模塊的名稱: mymodel
```<br/>
以上語句註意：
1) 我們可以通過import來導入多個模塊，用“,”（逗號）分隔。<br/>
2) 註意import與from..import&hellip;..</p>

<p><strong>4. 創建自己的包</strong><br/>
<em>A 一個包的基本組織如下：</em><br/>
``` python
FC/
  <strong>init</strong>.py
  Libr/</p>

<pre><code>__init__.py
one.py
two.py
....
</code></pre>

<p>  Model/</p>

<pre><code>__init__.py
one.py
....
</code></pre>

<p>在外部加載調用時，有以下方式：</p>

<h1>coding:utf-8</h1>

<h1>加載方式一</h1>

<p>import Fc.Libr.one
print Fc.Libr.one.a</p>

<h1>加載方式二</h1>

<p>from Fc.Libr import one
print one.a</p>

<h1>加載方式三</h1>

<p>from Fc.Libr.one import a
print a</p>

<h1>加載方式四</h1>

<p>from Fc.Libr import *
print one.a
註意直接使用第四種方式是不能正確導入Libr下的one子模塊的，這就需要在Fc目錄下的<strong>init</strong>.py文件中定義好需要加載子模塊的名稱
Fc/Libr/<strong>init</strong>.py
<strong>all</strong>=[&lsquo;one&rsquo;,&lsquo;two&rsquo;] #定義加載子模塊的名稱
```<br/>
在加載包模塊時，在import語句執行期時，遇到的所有__init__.py文件都會被執行，在上面代碼中
首先會執行Fc目錄中的__int__.py，然後執行Libr目錄中的__init__.py</p>

<p><em>B 子模塊加子模塊問題</em><br/>
同一包的相同目錄中：<br/>
``` python</p>

<h1>coding:utf-8</h1>

<h1>加載方式一:使用完全限定名稱</h1>

<p>from Fc.Libr import one
aa = &lsquo;libr two load one&mdash;&ndash;&rsquo;+one.a</p>

<h1>加載方式二:使用相對導入</h1>

<p>from . import one
bb = &lsquo;libr two load one&mdash;&mdash;&rsquo;+one.b
方二中使用.來表示在同一級目錄中。</p>

<h1>加載方式三:(這種方式應當避免:最後找不到會轉移到標準庫)</h1>

<p>import Fc.Libr.one
cc = &lsquo;libr two load one&mdash;&ndash;&rsquo;+Fc.Libr.one.a</p>

<p>在外部使用時：</p>

<h1>coding:utf-8</h1>

<p>from Fc.Libr import *
print two.aa
print two.bb</p>

<p>同一包的不同目錄中：</p>

<h1>coding:utf-8</h1>

<p>from ..Model import one
a = &lsquo;libr two load mode one&mdash;&ndash;&rsquo;+one.a</p>

<p>使用時：</p>

<h1>coding:utf-8</h1>

<p>from Fc.Libr import *
print two.a
將輸出：libr two load mode one&mdash;-fc model one
```</p>

<p>另外在導入一個包時，會定義一個特殊的變量__path__，該變量包含一個目錄列表。<br/>
__path__可通過__init__.py文件中包含的代碼訪問，最初包含的一項具有包的目錄名稱。我們可以向__path__列表提供更多的目錄，以更改查找子模塊時使用的搜索路徑，大型項目中這個很有用。</p>

<p><strong>5. 特別說明</strong><br/>
1) import執行加載源文件中所有語名（所以模塊是一個文件）。<br/>
2) import語句可以出現在程序中的任何位置。但是有一點是：無論import語句被使用了多少次，每個模塊中的代碼僅加載和執行一次，後續的import語句僅將模塊名稱綁定到前一次導入所創建的模塊對象上。<br/>
3) 使用sys.modules可查看當前加載的所有模塊。</p>

<p><a href="http://www.cnblogs.com/ptfblog/archive/2012/07/15/2592122.html">Origin</a></p>
]]></content>
  </entry>
  
</feed>
