<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: python | Themis_Sword's Blog]]></title>
  <link href="http://www.aprilzephyr.com/blog/categories/python/atom.xml" rel="self"/>
  <link href="http://www.aprilzephyr.com/"/>
  <updated>2014-03-30T14:38:58+08:00</updated>
  <id>http://www.aprilzephyr.com/</id>
  <author>
    <name><![CDATA[Themis_Sword]]></name>
    <email><![CDATA[licong0419@outlook.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Python 字符串]]></title>
    <link href="http://www.aprilzephyr.com/blog/20140328/python-zi-fu-chuan/"/>
    <updated>2014-03-28T01:15:00+08:00</updated>
    <id>http://www.aprilzephyr.com/blog/20140328/python-zi-fu-chuan</id>
    <content type="html"><![CDATA[<p><strong>1. 轉義字符</strong></p>

<table>
<tbody>
<tr><td><em>轉義字符</em></td><td><em>描述</em></td></tr>  
<tr><td>\\(在行尾)</td><td>續行符</td></tr>  
<tr><td>\\\ </td><td>反斜槓</td></tr>  
<tr><td>\\' </td><td>單引號</td></tr>  
<tr><td>\\" </td><td>雙引號</td></tr>  
<tr><td>\a</td><td>響鈴</td></tr>  
<tr><td>\b</td><td>退格(Backspace)</td></tr>  
<tr><td>\e</td><td>轉義</td></tr>  
<tr><td>\000</td><td>空</td></tr>  
<tr><td>\n</td><td>換行</td></tr>  
<tr><td>\v</td><td>縱向製表符</td></tr>  
<tr><td>\t</td><td>橫向製表符</td></tr>  
<tr><td>\r</td><td>回車</td></tr>  
<tr><td>\f</td><td>換頁</td></tr>  
<tr><td>\oyy</td><td>八進制數yy代表的字符，例如:\o12代表換行</td></tr>  
<tr><td>\xyy</td><td>十進制數yy代表的字符，例如:\x0a代表換行</td></tr>  
<tr><td>\uhhhh</td><td>Unicode 16位的十六進製值</td></tr>  
<tr><td>\uhhhhhhhh</td><td>Unicode 32位的十六進製值</td></tr>  
<tr><td>\other</td><td>其它的字符以普通格式輸出</td></tr>  
</tbody></table>


<!--more-->


<p><strong>2. 格式化表達</strong></p>

<table><tbody>  
<tr><td><em>格式化表達</em></td><td><em>描述</em></td></tr>  
<tr><td>%s</td><td>字符串</td></tr>  
<tr><td>%r</td><td>repr輸出的字符串</td></tr>  
<tr><td>%d</td><td>十進制整數</td></tr>  
<tr><td>%i</td><td>整數</td></tr>  
<tr><td>%u</td><td>無符號整數</td></tr>  
<tr><td>%o</td><td>八進制</td></tr>  
<tr><td>%x</td><td>十六進制</td></tr>  
<tr><td>%X</td><td>十六進制(大寫)</td></tr>  
<tr><td>%e</td><td>指數</td></tr>  
<tr><td>%E</td><td>指數(大寫)</td></tr>  
<tr><td>%f</td><td>十進制浮點數</td></tr>  
<tr><td>%F</td><td>十進制浮點數(大寫)</td></tr>  
<tr><td>%g</td><td>浮點e或f</td></tr>  
<tr><td>%G</td><td>浮點E或F</td></tr>  
</tbody></table>


<p></p>

<p><strong>3. 索引和切片</strong><br/>
Python中的字符串是有序的字符集合，所以可以通過位置（索引）獲取對應的元素。和c語言中一樣，python的索引也是從0開始的，而且支持使用負索引的方法來獲取元素，一個負的索引可以看做是從字符串結尾處反向計數，-1就表示字符串的最後一個字符。當然也可以理解為負索引與字符串長度相加得到的正索引，即s[-n]等於s[-n+len(s)]。<br/>
``` python</p>

<blockquote><blockquote><blockquote><p>s = &ldquo;hello"<br/>
s[0]<br/>
&lsquo;1'<br/>
s = "hello"<br/>
s[0]<br/>
'h'<br/>
s[-1]<br/>
'o'<br/>
s[0:3]<br/>
'hel'<br/>
s[1:]<br/>
'ello'<br/>
s[:-1]<br/>
'hell&rsquo;
<code>  
其實分片的完整格式為s[start:end:side]，意思就是從start開始到end-1，每隔side個元素取一個元素，返回值為所有取到的元素組成的字符串，side默認值為1。  
side可以取負值，例如s[::-1]會返回”olleh”，實際效果就是對字符串進行了反轉。這裏需要註意的是，如果side為負值，兩個邊界也要進行反轉，s[4:1:-1]就是從4開始反向取到2得到的字符串，如果在sride為負的情況下還是第一個邊界大於第二個邊界那樣的使用的話將返回一個空的字符串。  
</code> python
s[::2]<br/>
&lsquo;hlo'<br/>
s[::-1]<br/>
'olleh'<br/>
s[4:1:-1]<br/>
'oll'<br/>
s[0:4:-1]<br/>
&rsquo;&lsquo;<br/>
```</p></blockquote></blockquote></blockquote>

<p><strong>4. 字符串方法</strong><br/>
<em>A 大小寫</em><br/>
S.upper() 全部大寫<br/>
S.lower() 全部小寫<br/>
S.swapcase() 大小寫互換<br/>
S.capitalize() 首字母大寫，其余都小寫<br/>
S.title() 每個單詞的首字母大寫，其余不變</p>

<p><em>B 對齊</em><br/>
S.ljust(width[, fill]) 獲取固定長度width，左對齊，多余位用fill填充，默認空格<br/>
S.rjust(width[, fill]) 右對齊<br/>
S.center(width[, fill]) 居中<br/>
S.zfill(width) 右對齊，左邊不足的位置用0補齊，相當於S.rjust(width,&ldquo;0&rdquo;)<br/>
如果width&lt;=len(S)，返回於原字符串相同的字符串。</p>

<p><em>C 查找替換</em><br/>
S.find(sub[, start[, end]]) 返回在範圍start到end(不含end)中第一個sub的索引。<br/>
S.rfind(sub[, start[, end]]) 從右邊開始查找，也就是返回在範圍start到end(不含end)中最後一個sub的索引。<br/>
S.index(sub[, start[, end]])功能與find()相同，不同之處在於find()未找到的時候會返回-1，而index()會拋出異常。<br/>
S.rindex(sub[, start[, end]])功能與rfind()相同，不同之處在於find()未找到的時候會返回-1，而index()會拋出異常。<br/>
S.count(sub[, start[, end]]) 返回在範圍start到end(不含end)中sub的個數。<br/>
start默認為0，end默認為len(S)。<br/>
S.replace(old, new[, count])將字符串中的old替換為new，count為替換的次數，未指定的話就是替換所有。<br/>
S.translate(table [,deletechars]) 刪除S中deletechars包含的字符，然後將剩下的字符用table定義的關系進行映射。table是string.maketrans()生成的。</p>

<p><em>D 去空白或指定字符</em><br/>
S.strip([chars]) 去除字符串S兩邊的chars,若chars未指定，則去除兩邊的空白，包括空格、\n、\f、\r、\t和\v。<br/>
S.lstrip([chars]) 去除左邊的chars，未指定同上。<br/>
S.rstrip([chars]) 去除右邊的chars，未指定同上。</p>

<p><em>E 分割和組合</em><br/>
S.split([sep [,maxsplit]]) 以sep為分隔符切割字符串S，不指定sep默認為默認為空白，maxsplit為最大分割次數，未指定則全部分割，返回列表。<br/>
S.rsplit([sep [,maxsplit]]) 只是和split反向相反，split從頭到尾，rsplit從尾到頭。<br/>
S.splitlines([keepends]) 按行分割字符串，若keepends指定並且為True，則保留換行符，反之不保留。<br/>
S.partiton(sep)以sep作為分隔符將S分割為兩個start和end部分，並返回(start,sep, end)這樣格式的元組，若sep沒有找到，則返回S和兩個空串組成的元組(S, &lsquo;&rsquo;, &lsquo;&rsquo;)。<br/>
S.rpartition(sep)從右邊開始，以sep作為分隔符將S分割為兩個start和end部分，並返回(start,sep, end)，若sep沒有找到，則返回兩個空串和S組成的元組(&lsquo;&rsquo;, &lsquo;&rsquo;, S)。<br/>
S.join(iterable) 將叠代器iterable的字符串連接在一起，並用分隔符S隔開，一般來說在連接列表的時候都使用空字符串或者空格作為分隔符，返回字符串。</p>

<p><em>F 判斷</em><br/>
S.startswith(prefix[, start[, end]])判斷字符串start到end(不含end)是否是以prefix開頭，默認start為0，end為len(S)，返回布爾值。<br/>
S.endswith(suffix[, start[, end]]) 判斷字符串start到end(不含end)是否是以suffix結尾，默認start為0，end為len(S)，返回布爾值。<br/>
S.isalnum() 是否全為字母或數字，返回布爾值。<br/>
S.isalpha() 是否全為字母，返回布爾值。<br/>
S.isdigit() 是否全為數字0-9，返回布爾值。<br/>
S.islower() 是否全是小寫。<br/>
S.isupper() 是否全是大寫。<br/>
S.isspace() 是否全是空白。<br/>
S.istitle() 是否符合title的格式——每個單詞的首字母大寫。<br/>
上述這些函數中，若S為空串，則均返回False。</p>

<p><em>G 編碼</em><br/>
S.decode([encoding[,errors]]) 將字符串S解碼為unicode，encoding為S原來的編碼方式。<br/>
S.encode([encoding[,errors]]) 將unicodeS編碼為python中的字符串，參數指定對應的編碼方式。<br/>
errors指定出錯時對應的操作，默認的strict會在編碼/解碼失敗的時候拋出異常，ignore則忽略。<br/>
關於編碼方式還是有很多的知識的，後續再做研究。</p>

<p><em>H 其他</em><br/>
S.format(*args, **kwargs)<br/>
format也是用來格式化字符串的，argv指定的變量可以在S中用{index}來替換，而kwargs則是對應的變量。如果後面的數據為字典，可以使用{&lt;index|var>[key]}來替換其對應的值。當然還可以指定對應的寬度、精度以及對其格式，{index:[fill][&lt;|>|^][width][.precision][typecode]}。<br/>
fill設置填充位，默認為空格；&lt;左對齊，>右對齊，^居中；寬度和類型見後面格式化表達式部分。註意這裏的精度專指說浮點型數據，整型是不能使用精度的，字符創設置了也沒啥作用。<br/>
``` python</p>

<blockquote><blockquote><blockquote><p>&ldquo;{0},{2},{1},{s}&rdquo;.format(1,2,3,s=&ldquo;four&rdquo;)<br/>
&lsquo;1,3,2,four'<br/>
&ldquo;{0:$&lt;3},{2:^5.2f},{1},{s:>10.6s}&rdquo;.format(1,2,3,s=&ldquo;four&rdquo;)<br/>
'1$$,3.00 ,2,      four'<br/>
&ldquo;{0:&lt;3},{2:^5d},{1},{s:>10s}&rdquo;.format(1,2,3,s=&ldquo;four&rdquo;)<br/>
'1  ,  3  ,2,      four'<br/>
&ldquo;{0:&lt;03},{2:^05.2d},{1},{s:>10s}&rdquo;.format(1,2,3,s=&ldquo;four&rdquo;)<br/>
Traceback (most recent call last):<br/>
  File &ldquo;<stdin>&rdquo;, line 1, in <module><br/>
ValueError: Precision not allowed in integer format specifier<br/>
&ldquo;{0:&lt;03},{2:^5.2f},{1},{s:>10.6s}&rdquo;.format(1,2,3,s=&ldquo;four&rdquo;)<br/>
'100,3.00 ,2,      four&rsquo;
```<br/>
S.expandtabs([tabsize]) 將字符串中的制表符替換為tabsize個空格，默認為8。</p></blockquote></blockquote></blockquote>

<p><em>I 3.0新增</em><br/>
S.isdecimal() 是否全是十進制數字(多語言數字)。<br/>
S.isidentifier() 是否全是合法標識符。<br/>
S.isnumeric() 是否只包含數字字符。<br/>
S.isprintable() 是否全是可打印字符。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Python import與from...import...(轉)]]></title>
    <link href="http://www.aprilzephyr.com/blog/20140327/python-importyu-from-dot-dot-dot-import-dot-dot-dot/"/>
    <updated>2014-03-27T14:23:52+08:00</updated>
    <id>http://www.aprilzephyr.com/blog/20140327/python-importyu-from-dot-dot-dot-import-dot-dot-dot</id>
    <content type="html"><![CDATA[<p><strong>1. 簡單說說python import與from&hellip;import&hellip;.(python模塊)</strong></p>

<p>在python用import或者from&hellip;import來導入相應的模塊。模塊其實就一些函數和類的集合文件，它能實現一些相應的功能，當我們需要使用這些功能的時候，直接把相應的模塊導入到我們的程序中，我們就可以使用了。這類似於C語言中的include頭文件，Python中我們用import導入我們需要的模塊。 <!--more-->
``` python
import sys
print(&lsquo;================Python import mode==========================&rsquo;);
print (&lsquo;The command line arguments are:&rsquo;)
for i in sys.argv:</p>

<pre><code>print (i)
</code></pre>

<p>print (&lsquo;\n The python path&rsquo;,sys.path)</p>

<p>from sys import argv,path #導入特定的成員
print(&lsquo;================python from import===================================&rsquo;)
print(&lsquo;path:&rsquo;,path)</p>

<p>如果你要使用所有sys模塊使用的名字，你可以這樣：</p>

<p>from sys import *
print(&lsquo;path:&rsquo;,path)
```<br/>
從以上我們可以簡單看出：</p>

<p>\==========<br/>
導入mode，import與from&hellip;import的不同之處在於，簡單說：
如果你想要直接輸入argv變量到你的程序中而每次使用它時又不想打sys，則可使用：from sys import argv。<br/>
一般說來，應該避免使用from..import而使用import語句，因為這樣可以使你的程序更加易讀，也可以避免名稱的沖突。<br/>
\==========</p>

<p>在使用 from xxx import * 時，如果想精準的控制模塊導入的內容，可以使用 <strong>all</strong> = [xxx,xxx] 來實現，例如：<br/>
``` python
<strong>all</strong> = [&lsquo;a&rsquo;,&lsquo;b&rsquo;] #__為雙橫線
class two():</p>

<pre><code>def __init__(self):
    print('this is two')
</code></pre>

<p>a = &lsquo;this is two a&rsquo;
b = &lsquo;this is two b&rsquo;
if <strong>name</strong>==&lsquo;<strong>main</strong>&rsquo;:</p>

<pre><code>t = two()
</code></pre>

<p>one.py</p>

<p>from two import *
print a
print b
t = two()</p>

<p>這時，類two()將不會被 import *導入進來
```</p>

<p><strong>2. 關於import中的路徑搜索問題</strong><br/>
類似於頭文件，模塊也是需要系統的搜索路徑的，下面的命令即是系統默認的搜索路徑，當你導入一個模塊時，系統就會在下面的路徑列表中搜索相應的文件。<br/>
``` python</p>

<blockquote><blockquote><blockquote><p>print(sys.path)</p></blockquote></blockquote></blockquote>

<p>[&lsquo;&rsquo;, &lsquo;/usr/lib64/python26.zip&rsquo;, &lsquo;/usr/lib64/python2.6&rsquo;, &lsquo;/usr/lib64/python2.6/plat-linux2&rsquo;, &lsquo;/usr/lib64/python2.6/lib-tk&rsquo;, &lsquo;/usr/lib64/python2.6/lib-old&rsquo;, &lsquo;/usr/lib64/python2.6/lib-dynload&rsquo;, &lsquo;/usr/lib64/python2.6/site-packages&rsquo;, &lsquo;/usr/lib64/python2.6/site-packages/gst-0.10&rsquo;, &lsquo;/usr/lib64/python2.6/site-packages/gtk-2.0&rsquo;, &lsquo;/usr/lib64/python2.6/site-packages/webkit-1.0&rsquo;, &lsquo;/usr/lib/python2.6/site-packages&rsquo;]</p>

<p>(從例中，我們可以看到python會首先在當前工作目錄裏去找)
```</p>

<p>如果沒有找導相應的內容，則報錯：<br/>
``` python</p>

<blockquote><blockquote><blockquote><p>import syssTraceback (most recent call last):  File &ldquo;<stdin>&rdquo;, line 1, in <module>ImportError: No module named syss</p></blockquote></blockquote></blockquote>

<p>當然，我們也可以自行添加要搜索的路徑，調用列表的append方法即可：
import sys
sys.path.append(&lsquo;/usr/xx/python2.6&rsquo;)
```</p>

<p><strong>3. 創建自己的模塊</strong><br/>
在創建之前，有一點需要說明一下：每個Python模塊都有它的__name__（就每個對象都自己的__doc__一樣）。通過<strong>name</strong>我們可以找出每一個模塊的名稱，一般__name__的值有種：1 一是主模塊名稱為："__main__&ldquo;(可以理解為直接運行的那個文件)，2 那些被主模塊導入的模塊名稱為：文件名字（不加後面的.py）。有__name__是很有用的，因為我們可以通過 if __name__  == &lsquo;xxx&rsquo; 判斷來執行那些模塊，那些模塊不被執行。另外：每個Python程序也是一個模塊。它擴展名為：.py擴展名。</p>

<p>下面，我們通過例子來說明：<br/>
首先：我們創建模塊：mymodel.py<br/>
``` python</p>

<h1>!/user/bin/python</h1>

<h1>Filename:mymodel.py</h1>

<p>version = &lsquo;1.0&rsquo;
def sayHello():</p>

<pre><code>print ('Hello world')
</code></pre>

<p>def modelName():</p>

<pre><code>return __name__#返回它自己的名稱
</code></pre>

<h1>end of model</h1>

<p><code>  
以上語句注意：  
1) 這個模塊應該被放置在我們輸入它的程序的同一個目錄中，或者在sys.path所列目錄之一。  
2) 你已經看到，它與我們普通的Python程序相比並沒有什麽特別之處。  
然後：我們在test.py中來調用此模塊：test.py  
</code> python
import sys,mymodel
sys.path.append(&rsquo;D:/xx/PythonSERVER/python31/Code')#提供搜索路径
print(<strong>name</strong>) #此處打印主模塊的名稱：<strong>main</strong>
mymodel.sayHello()
print(&lsquo;Version&rsquo;,mymodel.version)
print(&lsquo;Model Name&rsquo;,mymodel.modelName())#打印被導入模塊的名稱: mymodel</p>

<p>我們使用from..import&hellip;</p>

<p>print(&lsquo;======================from&hellip;..import=====================================&rsquo;)
from mymodel import *
print(<strong>name</strong>)#此處打印主模塊的名稱：<strong>main</strong>
sayHello()
print(&lsquo;Version&rsquo;,version)
print(&lsquo;Model Name&rsquo;,modelName()) #打印被導入模塊的名稱: mymodel
```<br/>
以上語句註意：
1) 我們可以通過import來導入多個模塊，用“,”（逗號）分隔。<br/>
2) 註意import與from..import&hellip;..</p>

<p><strong>4. 創建自己的包</strong><br/>
<em>A 一個包的基本組織如下：</em><br/>
``` python
FC/
  <strong>init</strong>.py
  Libr/</p>

<pre><code>__init__.py
one.py
two.py
....
</code></pre>

<p>  Model/</p>

<pre><code>__init__.py
one.py
....
</code></pre>

<p>在外部加載調用時，有以下方式：</p>

<h1>coding:utf-8</h1>

<h1>加載方式一</h1>

<p>import Fc.Libr.one
print Fc.Libr.one.a</p>

<h1>加載方式二</h1>

<p>from Fc.Libr import one
print one.a</p>

<h1>加載方式三</h1>

<p>from Fc.Libr.one import a
print a</p>

<h1>加載方式四</h1>

<p>from Fc.Libr import *
print one.a
註意直接使用第四種方式是不能正確導入Libr下的one子模塊的，這就需要在Fc目錄下的<strong>init</strong>.py文件中定義好需要加載子模塊的名稱
Fc/Libr/<strong>init</strong>.py
<strong>all</strong>=[&lsquo;one&rsquo;,&lsquo;two&rsquo;] #定義加載子模塊的名稱
```<br/>
在加載包模塊時，在import語句執行期時，遇到的所有__init__.py文件都會被執行，在上面代碼中
首先會執行Fc目錄中的__int__.py，然後執行Libr目錄中的__init__.py</p>

<p><em>B 子模塊加子模塊問題</em><br/>
同一包的相同目錄中：<br/>
``` python</p>

<h1>coding:utf-8</h1>

<h1>加載方式一:使用完全限定名稱</h1>

<p>from Fc.Libr import one
aa = &lsquo;libr two load one&mdash;&ndash;&rsquo;+one.a</p>

<h1>加載方式二:使用相對導入</h1>

<p>from . import one
bb = &lsquo;libr two load one&mdash;&mdash;&rsquo;+one.b
方二中使用.來表示在同一級目錄中。</p>

<h1>加載方式三:(這種方式應當避免:最後找不到會轉移到標準庫)</h1>

<p>import Fc.Libr.one
cc = &lsquo;libr two load one&mdash;&ndash;&rsquo;+Fc.Libr.one.a</p>

<p>在外部使用時：</p>

<h1>coding:utf-8</h1>

<p>from Fc.Libr import *
print two.aa
print two.bb</p>

<p>同一包的不同目錄中：</p>

<h1>coding:utf-8</h1>

<p>from ..Model import one
a = &lsquo;libr two load mode one&mdash;&ndash;&rsquo;+one.a</p>

<p>使用時：</p>

<h1>coding:utf-8</h1>

<p>from Fc.Libr import *
print two.a
將輸出：libr two load mode one&mdash;-fc model one
```</p>

<p>另外在導入一個包時，會定義一個特殊的變量__path__，該變量包含一個目錄列表。<br/>
__path__可通過__init__.py文件中包含的代碼訪問，最初包含的一項具有包的目錄名稱。我們可以向__path__列表提供更多的目錄，以更改查找子模塊時使用的搜索路徑，大型項目中這個很有用。</p>

<p><strong>5. 特別說明</strong><br/>
1) import執行加載源文件中所有語名（所以模塊是一個文件）。<br/>
2) import語句可以出現在程序中的任何位置。但是有一點是：無論import語句被使用了多少次，每個模塊中的代碼僅加載和執行一次，後續的import語句僅將模塊名稱綁定到前一次導入所創建的模塊對象上。<br/>
3) 使用sys.modules可查看當前加載的所有模塊。</p>

<p><a href="http://www.cnblogs.com/ptfblog/archive/2012/07/15/2592122.html">Origin</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Python 時間&amp;日期模塊]]></title>
    <link href="http://www.aprilzephyr.com/blog/20140326/python-shi-jian-and-ri-qi-mo-kuai/"/>
    <updated>2014-03-26T16:53:19+08:00</updated>
    <id>http://www.aprilzephyr.com/blog/20140326/python-shi-jian-and-ri-qi-mo-kuai</id>
    <content type="html"><![CDATA[<p>Python提供了time/datetime/calendar等模塊來處理日期和時間。<br/>
<strong>1.time模塊常用的函數</strong><br/>
<em>A. time.time()</em><br/>
1970年1月1日以來的秒數，是一個浮點數。<br/>
<em>B. time.sleep()</em><br/>
可以通過調用time.sleep來挂起當前的進程。time.sleep接收一个浮點型參數，表示進程挂起的時間。<br/>
<em>C. time.clock()</em><br/>
time.clock()返回第一次调用该方法到现在的秒數，其精確度高於1微秒。可以使用该函數來記錄程序執行的時間。 <!--more--><br/>
<em>D. time.gmtime()</em><br/>
該函數原型為time.gmtime([sec])，可選參數sec表示從1970-01-01以來的秒數，默認值為time.time()，函數返回time.struct_time類型的對象。(struct_time是在time模塊中定義的表示時間的對象)，下面是一個簡單的例子：<br/>
``` python</p>

<blockquote><blockquote><blockquote><p>print time.gmtime()                        #獲取當前時間的struct_time對象 <br/>
(2013, 4, 8, 4, 28, 30, 0, 98, 0)
print time.gmtime(time.time())
(2013, 4, 8, 4, 28, 50, 0, 98, 0)
print time.gmtime(time.time()-24<em>60</em>60)    #獲取昨天這個時間的struct_time對象
(2013, 4, 7, 4, 29, 10, 6, 97, 0)
<code>  
*E. time.localtime()*  
與time.gmtime()非常類似，也返回一個struct_time對象，可以看作是gmtime()的本地化版本。  
*F. time.mktime()*  
time.mktime執行與gmtime(), localtime()相反的操作，它接收struct_time對象作為參數，返回用秒數來表示時間的浮點數。  
*G. time.strftime()*  
time.strftime將日期轉換為字符串表示，它的函數原型為：time.strftime(format[, t])。參數format是格式字符串（格式字符串的知識可以參考：[time.strftime](http://docs.python.org/2/library/time.html) ），可選的參數t是一个struct_time對象。  
</code> python
time.strftime參數:
strftime(format[, tuple]) &ndash;> string
將指定的struct_time(默認為當前時間)，根據指定的格式化字符串輸出
python中時間日期格式化符號：
%y 两位數的年份表示（00-99）
%Y 四位數的年份表示（000-9999）
%m 月份（01-12）
%d 月内中的一天（0-31）
%H 24小時製小時數（0-23）
%I 12小時製小時數（01-12）
%M 分鐘數（00=59）
%S 秒（00-59）
%a 本地簡化星期名稱
%A 本地完整星期名稱
%b 本地簡化的月份名稱
%B 本地完整的月份名稱
%c 本地相應的日期表示和時間表示
%j 年内的一天（001-366）
%p 本地A.M.或P.M.的等價符
%U 一年中的星期數（00-53），星期天為星期的開始
%w 星期（0-6），星期天為星期的開始
%W 一年中的星期數（00-53）星期一為星期的開始
%x 本地相應的日期表示
%X 本地相應的時間表示
%Z 當前時區的名稱
%% %號本身
<code>  
*H. time.strptime()*
按指定格式解析一個表示时间的字符串，返回struct_time對象。該函數原型為：time.strptime(string, format)，两個參數都是字符串。  
</code> python
print time.strptime(&lsquo;2013-04-09 12:30:25&rsquo;,&lsquo;%Y-%m-%d %H:%M:%S&rsquo;)
(2013, 4, 9, 12, 30, 25, 1, 99, -1)
```</p></blockquote></blockquote></blockquote>

<p><strong>2. datetime模塊</strong><br/>
<em>A. 兩個常量</em><br/>
datetime.MINYEAR和datetime.MAXYEAR，分別表示datetime所能表示的最小、最大年份。其中，MINYEAR=1,MAXYEAR=0000。<br/>
<em>B. 幾個重要的類</em><br/>
1) datetime.date:表示日期的類，常用的屬性有tear, month, day:<br/>
year的返回在兩個常量之間；<br/>
month的範圍是[1,12]，月份是從1開始；<br/>
day依據month來決定。 <br/>
2) date類提供了常用的類方法和類屬性：<br/>
date.max, date.min：date對象所能表示的最大、最小日期；
date.today()：返回一個表示當前本地日期的date對象。<br/>
``` python</p>

<blockquote><blockquote><blockquote><p>from datetime import *
import time
print date.today()
2014-03-26
print date.max
9999-12-31
print date.min
0001-01-01
<code>  
3) date提供的實例方法和屬性  
date.year、date.month、date.day：年、月、日；  
date.replace(year, month, day)：生成一个新的日期對象，用參數指定的年，月，日代替原有對象中的屬性。（原有對象仍保持不變）；  
date.timetuple()：返回日期對應的time.struct_time對象；  
date.weekday()：返回weekday，如果是星期一，返回0；如果是星期2，返回1，以此類推；  
data.isoweekday()：返回weekday，如果是星期一，返回1；如果是星期2，返回2，以此類推；  
date.isocalendar()：返回格式如(year，month，day)的元組；  
date.isoformat()：返回格式如'YYYY-MM-DD’的字符串；  
date.strftime(fmt)：自定義格式化字符串。  
</code> python
now=date(2014,03,26)
tomorrow=now.replace(day=27)
print &lsquo;now:&rsquo;,now
now: 2014-03-26
print &lsquo;tomorrow:&rsquo;,tomorrow
tomorrow: 2014-03-27
print &lsquo;timetuple():&rsquo;,now.timetuple()
timetuple(): (2013, 4, 8, 0, 0, 0, 2, 85, -1)
print &lsquo;weekday():&rsquo;,now.weekday()
weekday(): 2
print &lsquo;isoweekday():&rsquo;,now.isoweekday()
isoweekday(): 3
print &lsquo;isocalendar():&rsquo;,now.isocalendar()
isocalendar(): (2014, 13, 3)
print &lsquo;isoformat():&rsquo;,now.isoformat()
isoformat(): 2014-03-26
<code>  
4) date還對某些操作進行了重載，它允許我們對日期進行如下一些操作：  
date2 = date1 + timedelta  # 日期加上一個間隔，返回一個新的日期對象（timedelta將在下面介紹，表示時間間隔）
date2 = date1 - timedelta   # 日期隔去間隔，返回一個新的日期對象
timedelta = date1 - date2   # 两個日期相減，返回一個時間間隔對象
date1 &lt; date2  # 两個日期進行比較  
</code> python
now = date.today()<br/>
tomorrow = now.replace(day = 7 )<br/>
delta = tomorrow &ndash; now<br/>
print   &lsquo;now:&rsquo; , now,  &lsquo; tomorrow:&rsquo; , tomorrow<br/>
print   &lsquo;timedelta:&rsquo; , delta<br/>
print  now + delta<br/>
print  tomorrow > now</p>

<h1># &mdash;&mdash; output &mdash;&mdash;</h1>

<h1>now: 2010-04-06  tomorrow: 2010-04-07</h1>

<h1>timedelta: 1 day, 0:00:00</h1>

<h1>2010-04-07</h1>

<h1>True</h1>

<p>```<br/>
<a href="http://www.cnblogs.com/BeginMan/archive/2013/04/08/3007403.html">Origin</a></p></blockquote></blockquote></blockquote>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Python 常用函數之Join, Split, Zip, Map, Reduce, Filter]]></title>
    <link href="http://www.aprilzephyr.com/blog/20140326/python-chang-yong-han-shu-zhi-join/"/>
    <updated>2014-03-26T15:34:48+08:00</updated>
    <id>http://www.aprilzephyr.com/blog/20140326/python-chang-yong-han-shu-zhi-join</id>
    <content type="html"><![CDATA[<p><strong><em>1. Join, Split</em></strong><br/>
<em>A 關於Join和Split方法</em><br/>
1) 只針對字符串進行處理。split:拆分字符串、join連接字符串<br/>
2) string.join(sep): 以string作為分割符，将sep中所有的元素(字符串表示)合併成一個新的字符串<br/>
3) string.split(str=&lsquo; &rsquo;,num=string.count(str)): 以str為分隔符，切片string，如果num有指定值，則僅分隔num個子字符串<br/>
4) 對導入os模塊進行os.path.splie()/os.path.join() 貌似是處理機制不一樣，但是功能上一樣<!--more--></p>

<p><em>B Join</em><br/>
<code>python
a='abcd'
print '.'.join(a)   
print '|'.join(['a','b','c'])　　#可以把['a','b','c']看做是 a='abcd';下面同理
print '.'.join({'a':1,'b':2,'c':3,'d':4})
</code><br/>
注意：'.&lsquo;等做分隔符，將join裏的所有元素(字符串)通過分隔符連接成一個新的字符串。</p>

<p><strong>os.path.join(path1[,path2[,&hellip;&hellip;]])</strong><br/>
``` python
\将多个路径组合后返回，第一个绝对路径之前的参数将被忽略。</p>

<blockquote><blockquote><blockquote><p>os.path.join(&lsquo;c:\&rsquo;, &lsquo;csv&rsquo;, &lsquo;test.csv&rsquo;)
&lsquo;c:\csv\test.csv&rsquo;
os.path.join(&lsquo;windows\temp&rsquo;, &lsquo;c:\&rsquo;, &lsquo;csv&rsquo;, &lsquo;test.csv&rsquo;)
&lsquo;c:\csv\test.csv&rsquo;
os.path.join(&lsquo;/home/aa&rsquo;,&lsquo;/home/aa/bb&rsquo;,&lsquo;/home/aa/bb/c&rsquo;)
&lsquo;/home/aa/bb/c&rsquo;
```</p></blockquote></blockquote></blockquote>

<p><em>C Split</em><br/>
<code>python
s='a b c'
print s.split(' ')
st='hello world'
print st.split('o')
print st.split('o',1)
--------output---------
['a', 'b', 'c']
['hell', ' w', 'rld']
['hell', ' world']
</code><br/>
注意：分隔符不能為空，否則會報錯，但是可以有不含其中的分隔符：<br/>
``` python</p>

<blockquote><blockquote><blockquote><p>s.split(&lsquo;x&rsquo;)
[&lsquo;a b c&rsquo;]
s.split(&lsquo;xsdfadsf&rsquo;)
[&lsquo;a b c&rsquo;]
```</p></blockquote></blockquote></blockquote>

<p><strong>os.path.split()</strong><br/>
os.path.split()是按照路徑將文件名和路徑分隔開，比如d:\python\python.ext，可分割為[&rsquo;d:\python', &lsquo;python.exe&rsquo;]<br/>
<code>python
import os
print os.path.split('c:\\Program File\\123.doc')
print os.path.split('c:\\Program File\\')
-----------------output---------------------
('c:\\Program File', '123.doc')
('c:\\Program File', '')
</code><br/>
<a href="http://www.cnblogs.com/BeginMan/archive/2013/03/21/2972857.html">Origin</a></p>

<p><strong><em>2. Zip</em></strong><br/>
zip()是Python的内建函數，(與序列有關的内建函數有：sorted()、reversed()、enumerate()、zip()),其中sorted()和zip()返回一個序列(列表)對象，reversed()、enumerate()返回一個迭代器(類似序列)。<br/>
定義：zip([seql, &hellip;])接受一系列可迭代對象作為參數，將對象中對應的元素打包成一個個tuple（元组），然後返回由這些tuples組成的list（列表）。若傳入參數的長度不等，则返回list的長度和參數中長度最短的對象相同。<br/>
``` python</p>

<blockquote><blockquote><blockquote><p>z1=[1,2,3]
z2=[4,5,6]
result=zip(z1,z2)
result
[(1, 4), (2, 5), (3, 6)]
z3=[4,5,6,7]
result=zip(z1,z3)
result
[(1, 4), (2, 5), (3, 6)]
<code>  
zip()配合*號操作符，可以將已經zip過的列表對象解壓  
</code> python
zip(<em>result)
[(1, 2, 3), (4, 5, 6)]
<code>  
更近一層了解  
</code> python
* 二維矩陣變換（矩陣的行列互換）
比如我们有一個由列表描述的二維矩陣
a = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]
通过python列表推导的方法，我们也能轻易完成这个任务
print [ [row[col] for row in a] for col in range(len(a[0]))]
[[1, 4, 7], [2, 5, 8], [3, 6, 9]]
另外一種讓人困惑的方法就是利用zip函數：
a = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]
zip(</em>a)
[(1, 4, 7), (2, 5, 8), (3, 6, 9)]
map(list,zip(<em>a))
[[1, 4, 7], [2, 5, 8], [3, 6, 9]]
zip函數接受任意多個序列作為參數，將所有序列按相同的索引組合成一個元素是各個序列合併成的tuple的新序列，新的序列的長度以參數中最短的序列為準。另外(</em>)操作符与zip函數配合可以實現與zip相反的功能，即將合併的序列拆成多個tuple。
①tuple的新序列</p>

<blockquote><p>x=[1,2,3],y=[&lsquo;a&rsquo;,&lsquo;b&rsquo;,&lsquo;c&rsquo;]
zip(x,y)
[(1,&lsquo;a&rsquo;),(2,&lsquo;b&rsquo;),(3,&lsquo;c&rsquo;)]
②新的序列的長度以參數中最短的序列為準.
x=[1,2],y=[&lsquo;a&rsquo;,&lsquo;b&rsquo;,&lsquo;c&rsquo;]
zip(x,y)
[(1,&lsquo;a&rsquo;),(2,&lsquo;b&rsquo;)]
③(<em>)操作符与zip函數配合可以實現與zip相反的功能,即將合併的序列拆成多個tuple。
x=[1,2,3],y=[&lsquo;a&rsquo;,&lsquo;b&rsquo;,&lsquo;c&rsquo;]
zip(</em>zip(x,y))
[(1,2,3),(&lsquo;a&rsquo;,&lsquo;b&rsquo;,&lsquo;c&rsquo;)]
```<br/>
<a href="http://www.cnblogs.com/BeginMan/archive/2013/03/14/2959447.html">Origin</a></p></blockquote></blockquote></blockquote></blockquote>

<p><strong><em>3. Map</em></strong><br/>
對sequence中的item依次執行function(item)，執行結果輸出為list。<br/>
``` python</p>

<blockquote><blockquote><blockquote><p>map(str, range(5))           #對range(5)各項進行str操作
[&lsquo;0&rsquo;, &lsquo;1&rsquo;, &lsquo;2&rsquo;, &lsquo;3&rsquo;, &lsquo;4&rsquo;]        #返回列表
def add(n):return n+n
&hellip;
map(add, range(5))           #對range(5)各項進行add操作
[0, 2, 4, 6, 8]
map(lambda x:x+x,range(5))   #lambda 函數，各項+本身
[0, 2, 4, 6, 8]
map(lambda x:x+1,range(10))  #lambda 函數，各項+1
[1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
map(add,&lsquo;zhoujy&rsquo;)          <br/>
[&lsquo;zz&rsquo;, &lsquo;hh&rsquo;, &lsquo;oo&rsquo;, &lsquo;uu&rsquo;, &lsquo;jj&rsquo;, &lsquo;yy&rsquo;]
<code>  
想要輸入多個序列，需要支持多個參數的函數，注意的是各序列的長度必須一樣，否則報錯：  
</code> python
def add(x,y):return x+y
&hellip;
map(add,&lsquo;zhoujy&rsquo;,&lsquo;Python&rsquo;)
[&lsquo;zP&rsquo;, &lsquo;hy&rsquo;, &lsquo;ot&rsquo;, &lsquo;uh&rsquo;, &lsquo;jo&rsquo;, &lsquo;yn&rsquo;]
def add(x,y,z):return x+y+z
&hellip;
map(add,&lsquo;zhoujy&rsquo;,&lsquo;Python&rsquo;,&lsquo;test&rsquo;)     #&lsquo;test'的長度比其他2個小
Traceback (most recent call last):
  File &ldquo;<stdin>&rdquo;, line 1, in <module>
TypeError: add() takes exactly 2 arguments (3 given)
map(add,'zhoujy&rsquo;,&lsquo;Python&rsquo;,&lsquo;testop&rsquo;)
[&lsquo;zPt&rsquo;, &lsquo;hye&rsquo;, &lsquo;ots&rsquo;, &lsquo;uht&rsquo;, &lsquo;joo&rsquo;, &lsquo;ynp&rsquo;]
```</p></blockquote></blockquote></blockquote>

<p><strong><em>4. Reduce</em></strong><br/>
對sequence中的item顺序迭代調用function，函數必須要有2個參數。要是有第3個參數，則表示初始值，可以繼續调用初始值，返回一個值。<br/>
``` python</p>

<blockquote><blockquote><blockquote><p>def add(x,y):return x+y
&hellip;
reduce(add,range(10))        #1+2+3+&hellip;+9
45
reduce(add,range(11))        #1+2+3+&hellip;+10
55
reduce(lambda x,y:x<em>y,range(1,3),5)           #lambda 函數，5是初始值， 1</em>2<em>5
10
reduce(lambda x,y:x</em>y,range(1,6))             #阶乘，1<em>2</em>3<em>4</em>5
120
reduce(lambda x,y:x<em>y,range(1,6),3)           #初始值3，结果再</em>3
360
reduce(lambda x,y:x+y,[1,2,3,4,5,6])          #1+2+3+4+5+6
21
```</p></blockquote></blockquote></blockquote>

<p><strong><em>5. Filter</em></strong><br/>
對sequence中的item依次執行function(item)，將執行結果為True（！=0）的item組成一個List/String/Tuple（取決于sequence的類型）返回，False則退出（0），進行過濾。<br/>
``` python</p>

<blockquote><blockquote><blockquote><p>def div(n):return n%2
&hellip;
filter(div,range(5))                    #返回div輸出的不等於0的真值
[1, 3]
filter(div,range(10))
[1, 3, 5, 7, 9]
filter(lambda x : x%2,range(10))        #lambda 函數返回奇數，返回列表
[1, 3, 5, 7, 9]
filter(lambda x : not x%2,range(10))
[0, 2, 4, 6, 8]
def fin(n):return n!=&lsquo;z&rsquo;                #過濾'z' 函數，出现z则返回False
&hellip;
filter(fin,&lsquo;zhoujy&rsquo;)                    #&lsquo;z'被過濾
'houjy&rsquo;
filter(lambda x : x !=&lsquo;z&rsquo;,&lsquo;zhoujy&rsquo;)     #labmda返回True值
&lsquo;houjy&rsquo;
filter(lambda x : not x==&lsquo;z&rsquo;,&lsquo;zhoujy&rsquo;)  #返回：字符串
&lsquo;houjy&rsquo;
```</p></blockquote></blockquote></blockquote>

<p><strong><em>6. Map, Reduce, Filter應用</em></strong><br/>
<em>A 實現5!+4!+3!+2!+1</em>
``` python</p>

<h1>!/usr/bin/env python</h1>

<h1>&ndash;<em>&ndash; coding:utf-8 &ndash;</em>&ndash;</h1>

<p>def add_factorial(n):</p>

<pre><code>empty_list=[]           #聲明一個空列表，存各個階乘的結果，方便這些結果相加
for i in map(lambda x:x+1,range(n)):    #用傳進來的變量(n)來生成一个列表，用map讓列表都+1，eg：range(5) =&gt; [1,2,3,4,5]
    a=reduce(lambda x,y:x*y,map(lambda x:x+1,range(i)))   #生成階乘，用map去掉列表中的0
    empty_list.append(a)            #把階乘結果append到空的列表中
return empty_list
</code></pre>

<p>if <strong>name</strong> == &lsquo;<strong>main</strong>&rsquo;:</p>

<pre><code>import sys
</code></pre>

<h1>2選1</h1>

<h1>(一)</h1>

<pre><code>try:
    n = input("Enter a Number(int) : ")
    result=add_factorial(n)   #傳入變量
    print reduce(lambda x,y:x+y,result)      #階乘結果相加
except (NameError,TypeError):
    print "That's not a Number!"
</code></pre>

<h1>(二)</h1>

<h1>result = add_factorial(int(sys.argv[1]))   #傳入變量</h1>

<h1>print reduce(lambda x,y:x+y,result)      #階乘結果相加</h1>

<p>```</p>

<p><em>B 將100-200以內的質數挑選出來</em><br/>
``` python</p>

<h1>!/usr/bin/env python</h1>

<h1>&ndash;<em>&ndash; coding:utf-8 &ndash;</em>&ndash;</h1>

<p>def is_prime(start,stop):</p>

<pre><code>stop  = stop+1     #包含列表右边的值
prime = filter(lambda x : not [x%i for i in range(2,x) if x%i == 0],range(start,stop))   #取出質數,x从range(start,stop) 取的數
print prime
</code></pre>

<p>if <strong>name</strong> == &lsquo;<strong>main</strong>&rsquo;:</p>

<pre><code>try :
    start = input("Enter a start Number :")
except :
    start = 2   #开始值默认2
try :
    stop  = input("Enter a stop  Number :")
except :
    stop  = 0   #停止數，默认0，即不返回任何值
is_prime(start,stop)
</code></pre>

<p>```<br/>
<a href="http://www.cnblogs.com/zhoujinyi/archive/2013/06/07/3121976.html">Origin</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Notes of Python 02]]></title>
    <link href="http://www.aprilzephyr.com/blog/20140306/notes-of-python-02/"/>
    <updated>2014-03-06T17:07:25+08:00</updated>
    <id>http://www.aprilzephyr.com/blog/20140306/notes-of-python-02</id>
    <content type="html"><![CDATA[<ol>
<li><p>不同算法實現Fibonacci數列<br/>
1) 遞歸：<br/>
<code>python
fib=lambda n:1 if n&lt;=2 else fib(n-1)+fib(n-2)
</code><br/>
2) 迭代：<br/>
<code>python
def fib(n):
x,y=0,1
while(n):
x,y,n=y,x+y,n-1
return x
</code><br/>
3) 尾遞歸(SICP)：<br/>
<code>python
def fib(n):
def fib_iter(n,x,y):
if n==0 : return x
else : return fib_iter(n-1,y,x+y)
return fib_iter(n,0,1)
</code><br/>
<a href="http://www.cnblogs.com/figure9/archive/2010/08/30/1812927.html">Origin</a><!--more--></p></li>
<li><p>九九乘法表<br/>
<code>python
for i in range(1,10):
　　for j in range(1,i+1):
　　　　print(" %d*%d=%d" % (j,i,i*j)),
　　print '\n'
</code></p></li>
<li><p>求素數<br/>
<code>python
lis = []
for obj in range(1,10):
 if obj&gt;2:
     for x in range(2,obj):
         if obj % x == 0:
             lis.append(obj)
lis = list(set(lis))
sushu = [obj for obj in range(1,10) if obj not in lis]
print sushu
</code></p></li>
</ol>

]]></content>
  </entry>
  
</feed>
