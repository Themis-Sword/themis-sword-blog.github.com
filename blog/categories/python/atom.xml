<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: python | Themis_Sword's Blog]]></title>
  <link href="http://www.aprilzephyr.com/blog/categories/python/atom.xml" rel="self"/>
  <link href="http://www.aprilzephyr.com/"/>
  <updated>2014-04-16T17:07:30+08:00</updated>
  <id>http://www.aprilzephyr.com/</id>
  <author>
    <name><![CDATA[Themis_Sword]]></name>
    <email><![CDATA[licong0419@outlook.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Improve Your Python: 'yield' and Generators Explained(Fw)]]></title>
    <link href="http://www.aprilzephyr.com/blog/04062014/improve-your-python-yield/"/>
    <updated>2014-04-06T18:07:35+08:00</updated>
    <id>http://www.aprilzephyr.com/blog/04062014/improve-your-python-yield</id>
    <content type="html"><![CDATA[<p>Prior to beginning tutoring sessions, I ask new students to fill out a brief self-assessment where they rate their understanding of various Python concepts. Some topics (&ldquo;control flow with if/else&rdquo; or &ldquo;defining and using functions&rdquo;) are understood by a majority of students before ever beginning tutoring. There are a handful of topics, however, that almost all students report having no knowledge or very limited understanding of. Of these, &ldquo;<code>generators</code> and the <code>yield</code> keyword&rdquo; is one of the biggest culprits. I&rsquo;m guessing this is the case for most novice Python programmers.<!--more--></p>

<p>Many report having difficulty understanding <code>generators</code> and the <code>yield</code> keyword even after making a concerted effort to teach themselves the topic. I want to change that. In this post, I&rsquo;ll explain what the <code>yield</code> keyword does, why it&rsquo;s useful, and how to use it.</p>

<p><em>Note: In recent years, generators have grown more powerful as features have been added through PEPs. In my next post, I&rsquo;ll explore the true power of <code>yield</code> with respect to coroutines, cooperative multitasking and asynchronous I/O (especially their use in the <a href="https://code.google.com/p/tulip/">&ldquo;tulip&rdquo;</a> prototype implementation GvR has been working on). Before we get there, however, we need a solid understanding of how the <code>yield</code> keyword and generators work.</em></p>

<p><strong>Coroutines and Subroutines</strong><br/>
When we call a normal Python function, execution starts at function&rsquo;s first line and continues until a <code>return</code> statement, <code>exception</code>, or the end of the function (which is seen as an implicit <code>return None</code>) is encountered. Once a function returns control to its caller, that&rsquo;s it. Any work done by the function and stored in local variables is lost. A new call to the function creates everything from scratch.</p>

<p>This is all very standard when discussing functions (more generally referred to as <a href="http://en.wikipedia.org/wiki/Subroutine">subroutines</a>) in computer programming. There are times, though, when it&rsquo;s beneficial to have the ability to create a &ldquo;function&rdquo; which, instead of simply returning a single value, is able to yield a series of values. To do so, such a function would need to be able to &ldquo;save its work,&rdquo; so to speak.</p>

<p>I said, &ldquo;yield a series of values&rdquo; because our hypothetical function doesn&rsquo;t &ldquo;return&rdquo; in the normal sense. <code>return</code> implies that the function is <em>returning control</em> of execution to the point where the function was called. &ldquo;Yield,&rdquo; however, implies that the transfer of control is temporary and voluntary, and our function expects to regain it in the future.</p>

<p>In Python, &ldquo;functions&rdquo; with these capabilities are called <code>generators</code>, and they&rsquo;re incredibly useful. <code>generators</code> (and the <code>yield</code> statement) were initially introduced to give programmers a more straightforward way to write code responsible for producing a series of values. Previously, creating something like a random number generator required a class or module that both generated values and kept track of state between calls. With the introduction of <code>generators</code>, this became much simpler.</p>

<p>To better understand the problem generators solve, let&rsquo;s take a look at an example. Throughout the example, keep in mind the core problem being solved: <strong>generating a series of values.</strong></p>

<p><em>Note: Outside of Python, all but the simplest <code>generators</code> would be referred to as <code>coroutines</code>. I&rsquo;ll use the latter term later in the post. The important thing to remember is, in Python, everything described here as a <code>coroutine</code> is still a <code>generator</code>. Python formally defines the term <code>generator</code>; <code>coroutine</code> is used in discussion but has no formal definition in the language.</em></p>

<p><strong>Example: Fun With Prime Numbers</strong><br/>
Suppose our boss asks us to write a function that takes a <code>list</code> of <code>ints</code> and returns some Iterable containing the elements which are prime1 numbers.</p>

<p><em>Remember, an <a href="http://en.wikipedia.org/wiki/Subroutine">Iterable</a> is just an object capable of returning its members one at a time.</em></p>

<p>&ldquo;Simple,&rdquo; we say, and we write the following:<br/>
``` python
def get_primes(input_list):</p>

<pre><code>result_list = list()
for element in input_list:
    if is_prime(element):
        result_list.append()

return result_list
</code></pre>

<h1>or better yet&hellip;</h1>

<p>def get_primes(input_list):</p>

<pre><code>return (element for element in input_list if is_prime(element))
</code></pre>

<h1>not germane to the example, but here&rsquo;s a possible implementation of</h1>

<h1>is_prime&hellip;</h1>

<p>def is_prime(number):</p>

<pre><code>if number &gt; 1:
    if number == 2:
        return True
    if number % 2 == 0:
        return False
    for current in range(3, int(math.sqrt(number) + 1), 2):
        if number % current == 0: 
            return False
    return True
return False
</code></pre>

<p><code>``   
Either</code>get_primes` implementation above fulfills the requirements, so we tell our boss we&rsquo;re done. She reports our function works and is exactly what she wanted.</p>

<p>Dealing With Infinite Sequences</p>

<p>Well, not quite exactly. A few days later, our boss comes back and tells us she&rsquo;s run into a small problem: she wants to use our <code>get_primes</code> function on a very large list of numbers. In fact, the list is so large that merely creating it would consume all of the system&rsquo;s memory. To work around this, she wants to be able to call <code>get_primes</code> with a <code>start</code> value and get all the primes larger than <code>start</code> (perhaps she&rsquo;s solving <a href="http://projecteuler.net/problem=10">Project Euler problem 10</a>).</p>

<p>Once we think about this new requirement, it becomes clear that it requires more than a simple change to <code>get_primes</code>. Clearly, we can&rsquo;t return a list of all the prime numbers from <code>start</code> to infinity (<em>operating on infinite sequences, though, has a wide range of useful applications</em>). The chances of solving this problem using a normal function seem bleak.</p>

<p>Before we give up, let&rsquo;s determine the core obstacle preventing us from writing a function that satisfies our boss&rsquo;s new requirements. Thinking about it, we arrive at the following: <strong>functions only get one chance to return results, and thus must return all results at once.</strong> It seems pointless to make such an obvious statement; &ldquo;functions just work that way,&rdquo; we think. The real value lies in asking, &ldquo;but what if they didn&rsquo;t?&rdquo;</p>

<p>Imagine what we could do if <code>get_primes</code> could simply return the next value instead of all the values at once. It wouldn&rsquo;t need to create a list at all. No list, no memory issues. Since our boss told us she&rsquo;s just iterating over the results, she wouldn&rsquo;t know the difference.</p>

<p>Unfortunately, this doesn&rsquo;t seem possible. Even if we had a magical function that allowed us to iterate from n to <code>infinity</code>, we&rsquo;d get stuck after returning the first value:<br/>
``` python
def get_primes(start):</p>

<pre><code>for element in magical_infinite_range(start):
    if is_prime(element):
        return element
</code></pre>

<p><code>  
Imagine `get_primes` is called like so:  
</code> python
def solve_number_10():</p>

<pre><code># She *is* working on Project Euler #10, I knew it!
total = 2
for next_prime in get_primes(3):
    if next_prime &lt; 2000000:
        total += next_prime
    else:
        print(total)
        return
</code></pre>

<p><code>``  
Clearly, in</code>get_primes<code>, we would immediately hit the case where</code>number = 3<code>and return at line 4. Instead of</code>return`, we need a way to generate a value and, when asked for the next one, pick up where we left off.</p>

<p>Functions, though, can&rsquo;t do this. When they <code>return</code>, they&rsquo;re done for good. Even if we could guarantee a function would be called again, we have no way of saying, &ldquo;OK, now, instead of starting at the first line like we normally do, start up where we left off at line 4.&rdquo; Functions have a single <code>entry point</code>: the first line.</p>

<p><strong>Enter the Generator</strong><br/>
This sort of problem is so common that a new construct was added to Python to solve it: the <code>generator</code>. A <code>generator</code> &ldquo;generates&rdquo; values. Creating <code>generators</code> was made as straightforward as possible through the concept of <code>generator functions</code>, introduced simultaneously.</p>

<p>A <code>generator function</code> is defined like a normal function, but whenever it needs to generate a value, it does so with the <code>yield</code> keyword rather than <code>return</code>. If the body of a <code>def</code> contains <code>yield</code>, the function automatically becomes a <code>generator function</code> (even if it also contains a return statement). There&rsquo;s nothing else we need to do to create one.</p>

<p><code>generator functions</code> create <code>generator iterators</code>. That&rsquo;s the last time you&rsquo;ll see the term <code>generator iterator</code>, though, since they&rsquo;re almost always referred to as &ldquo;<code>generators</code>&rdquo;. Just remember that a <code>generator</code> is a special type of <code>iterator</code>. To be considered an <code>iterator</code>, <code>generators</code> must define a few methods, one of which is <code>__next__()</code>. To get the next value from a <code>generator</code>, we use the same built-in function as for <code>iterators</code>: <code>next()</code>.</p>

<p>This point bears repeating: <strong>to get the next value from a</strong> <code>generator</code><strong>, </strong>we use the same built-in function as for<strong> <code>iterators</code> </strong>:** <code>next()</code>.</p>

<p>(<code>next()</code> takes care of calling the generator&rsquo;s <code>__next__()</code> method). Since a <code>generator</code> is a type of <code>iterator</code>, it can be used in a <code>for</code> loop.</p>

<p>So whenever <code>next()</code> is called on a <code>generator</code>, the <code>generator</code> is responsible for passing back a value to whomever called <code>next()</code>. It does so by calling yield along with the value to be passed back (e.g. <code>yield 7</code>). The easiest way to remember what <code>yield</code> does is to think of it as <code>return</code> (plus a little magic) for <code>generator functions</code>.</p>

<p>Again, this bears repeating: <code>yield</code> <strong>is just</strong> <code>return</code> <strong>(plus a little magic) for</strong> <code>generator functions</code>.</p>

<p>Here&rsquo;s a simple generator function:<br/>
``` python</p>

<blockquote><blockquote><blockquote><p>def simple_generator_function():
   yield 1
   yield 2
   yield 3
<code>  
And here are two simple ways to use it:  
</code> python
for value in simple_generator_function():</p>

<pre><code>print(value)
</code></pre>

<p>1
2
3
our_generator = simple_generator_function()
next(our_generator)
1
next(our_generator)
2
next(our_generator)
3
```</p></blockquote></blockquote></blockquote>

<p><strong>Magic?</strong><br/>
What&rsquo;s the magic part? Glad you asked! When a <code>generator function</code> calls <code>yield</code>, the &ldquo;state&rdquo; of the <code>generator function</code> is frozen; the values of all variables are saved and the next line of code to be executed is recorded until <code>next()</code> is called again. Once it is, the <code>generator function</code> simply resumes where it left off. If <code>next()</code> is never called again, the state recorded during the <code>yield</code> call is (eventually) discarded.</p>

<p>Let&rsquo;s rewrite <code>get_primes</code> as a <code>generator function</code>. Notice that we no longer need the <code>magical_infinite_range function</code>. Using a simple <code>while</code> loop, we can create our own infinite sequence:<br/>
``` python
def get_primes(number):</p>

<pre><code>while True:
    if is_prime(number):
        yield number
    number += 1
</code></pre>

<p><code>  
If a `generator function` calls `return` or reaches the end its definition, a `StopIteration` exception is raised. This signals to whoever was calling `next()` that the `generator` is exhausted (this is normal `iterator` behavior). It is also the reason the `while True:` loop is present in `get_primes`. If it weren't, the first time `next()` was called we would check if the number is prime and possibly yield it. If `next()` were called again, we would uselessly add `1` to `number` and hit the end of the `generator function` (causing `StopIteration` to be raised). Once a generator has been exhausted, calling `next()` on it will result in an error, so you can only consume all the values of a `generator` once. The following will not work:  
</code> python</p>

<blockquote><blockquote><blockquote><p>our_generator = simple_generator_function()
for value in our_generator:</p>

<pre><code>print(value)
</code></pre>

<h1>our_generator has been exhausted&hellip;</h1>

<p>print(next(our_generator))
Traceback (most recent call last):
  File &ldquo;&lt;ipython-input-13-7e48a609051a>&rdquo;, line 1, in <module></p>

<pre><code>next(our_generator)
</code></pre>

<p>StopIteration</p>

<h1>however, we can always create a new generator</h1>

<h1>by calling the generator function again&hellip;</h1>

<p>new_generator = simple_generator_function()
print(next(new_generator)) # perfectly valid
1
```</p></blockquote></blockquote></blockquote>

<p>Thus, the <code>while</code> loop is there to make sure we never reach the end of <code>get_primes</code>. It allows us to generate a value for as long as <code>next()</code> is called on the generator. This is a common idiom when dealing with infinite series (and <code>generators</code> in general).</p>

<p><strong>Visualizing the flow</strong>
Let&rsquo;s go back to the code that was calling <code>get_primes</code>: <code>solve_number_10</code>.<br/>
``` python
def solve_number_10():</p>

<pre><code># She *is* working on Project Euler #10, I knew it!
total = 2
for next_prime in get_primes(3):
    if next_prime &lt; 2000000:
        total += next_prime
    else:
        print(total)
        return
</code></pre>

<p><code>``  
It's helpful to visualize how the first few elements are created when we call</code>get_primes<code>in</code>solve_number_10<code>'s</code>for<code>loop. When the</code>for<code>loop requests the first value from</code>get_primes<code>, we enter</code>get_primes` as we would in a normal function.</p>

<p>1) We enter the while loop on line 3<br/>
2) The if condition holds (3 is prime)<br/>
3) We yield the value 3 and control to  solve_number_10.</p>

<p>Then, back in <code>solve_number_10</code>:</p>

<p>1) The value <code>3</code> is passed back to the <code>for</code> loop<br/>
2) The <code>for</code> loop assigns <code>next_prime</code> to this value<br/>
3) <code>next_prime</code> is added to <code>total</code><br/>
4) The <code>for</code> loop requests the next element from <code>get_primes</code><br/>
This time, though, instead of entering <code>get_primes</code> back at the top, we resume at line <code>5</code>, where we left off.<br/>
``` python
def get_primes(number):</p>

<pre><code>while True:
    if is_prime(number):
        yield number
    number += 1 # &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;
</code></pre>

<p><code>``  
Most importantly,</code>number<code>*still has the same value it did when we called</code>yield<code>(i.e.</code>3<code>).* Remember,</code>yield<code>both passes a value to whoever called</code>next()<code>, and saves the "state" of the</code>generator function<code>. Clearly, then,</code>number<code>is incremented to 4, we hit the top of the</code>while<code>loop, and keep incrementing</code>number<code>until we hit the next prime number (</code>5<code>). Again we</code>yield<code>the value of</code>number<code>to the</code>for<code>loop in solve</code>_number_10<code>. This cycle continues until the</code>for<code>loop stops (at the first prime greater than</code>2,000,000`).</p>

<p><strong>Moar Power</strong><br/>
In <a href="http://www.python.org/dev/peps/pep-0342/">PEP 342</a>, support was added for passing values into generators. <a href="http://www.python.org/dev/peps/pep-0342/">PEP 342</a> gave <code>generators</code> the power to yield a value (as before), receive a value, or both yield a value and receive a (possibly different) value in a single statement.</p>

<p>To illustrate how values are sent to a <code>generator</code>, let&rsquo;s return to our prime number example. This time, instead of simply printing every prime number greater than <code>number</code>, we&rsquo;ll find the smallest prime number greater than successive powers of a number (i.e. for 10, we want the smallest prime greater than 10, then 100, then 1000, etc.). We start in the same way as <code>get_primes</code>:<br/>
``` python
def print_successive_primes(iterations, base=10):</p>

<pre><code># like normal functions, a generator function
# can be assigned to a variable

prime_generator = get_primes(base)
# missing code...
for power in range(iterations):
    # missing code...
</code></pre>

<p>def get_primes(number):</p>

<pre><code>while True:
    if is_prime(number):
    # ... what goes here?
</code></pre>

<p>```</p>

<p>The next line of <code>get_primes</code> takes a bit of explanation. While <code>yield number</code> would yield the value of <code>number</code>, a statement of the form <code>other = yield foo</code> means, &ldquo;yield <code>foo</code> and, when a value is sent to me, set <code>other</code> to that value.&rdquo; You can &ldquo;send&rdquo; values to a generator using the generator&rsquo;s <code>send</code> method.<br/>
``` python
def get_primes(number):</p>

<pre><code>while True:
    if is_prime(number):
        number = yield number
    number += 1
</code></pre>

<p><code>  
In this way, we can set `number` to a different value each time the generator `yield`s. We can now fill in the missing code in `print_successive_primes`:  
</code> python
def print_successive_primes(iterations, base=10):</p>

<pre><code>prime_generator = get_primes(base)
prime_generator.send(None)
for power in range(iterations):
    print(prime_generator.send(base ** power))
</code></pre>

<p><code>``  
Two things to note here: First, we're printing the result of</code>generator.send<code>, which is possible because</code>send<code>both sends a value to the generator and returns the value yielded by the generator (mirroring how</code>yield<code>works from within the</code>generator function`).</p>

<p>Second, notice the <code>prime_generator.send(None)</code> line. When you&rsquo;re using send to &ldquo;start&rdquo; a generator (that is, execute the code from the first line of the generator function up to the first <code>yield</code> statement), you must send <code>None</code>. This makes sense, since by definition the generator hasn&rsquo;t gotten to the first <code>yield</code> statement yet, so if we sent a real value there would be nothing to &ldquo;receive&rdquo; it. Once the generator is started, we can send values as we do above.</p>

<p><strong>Round-up</strong><br/>
In the second half of this series, we&rsquo;ll discuss the various ways in which <code>generators</code> have been enhanced and the power they gained as a result. <code>yield</code> has become one of the most powerful keywords in Python. Now that we&rsquo;ve built a solid understanding of how <code>yield</code> works, we have the knowledge necessary to understand some of the more &ldquo;mind-bending&rdquo; things that <code>yield</code> can be used for.</p>

<p>Believe it or not, we&rsquo;ve barely scratched the surface of the power of <code>yield</code>. For example, while <code>send</code> does work as described above, it&rsquo;s almost never used when generating simple sequences like our example. Below, I&rsquo;ve pasted a small demonstration of one common way <code>send</code> is used. I&rsquo;ll not say any more about it as figuring out how and why it works will be a good warm-up for part two.<br/>
``` python
import random</p>

<p>def get_data():</p>

<pre><code>"""Return 3 random integers between 0 and 9"""
return random.sample(range(10), 3)
</code></pre>

<p>def consume():</p>

<pre><code>"""Displays a running average across lists of integers sent to it"""
running_sum = 0
data_items_seen = 0

while True:
    data = yield
    data_items_seen += len(data)
    running_sum += sum(data)
    print('The running average is {}'.format(running_sum / float(data_items_seen)))
</code></pre>

<p>def produce(consumer):</p>

<pre><code>"""Produces a set of values and forwards them to the pre-defined consumer
function"""
while True:
    data = get_data()
    print('Produced {}'.format(data))
    consumer.send(data)
    yield
</code></pre>

<p>if <strong>name</strong> == &lsquo;<strong>main</strong>&rsquo;:</p>

<pre><code>consumer = consume()
consumer.send(None)
producer = produce(consumer)

for _ in range(10):
    print('Producing...')
    next(producer)
</code></pre>

<p>```</p>

<p><strong>Remember&hellip;</strong><br/>
There are a few key ideas I hope you take away from this discussion:<br/>
* <code>generators</code> are used to generate a series of values<br/>
* <code>yield</code> is like the <code>return</code> of <code>generator functions</code><br/>
* The only other thing <code>yield</code> does is save the &ldquo;state&rdquo; of a <code>generator function</code><br/>
* A <code>generator</code> is just a special type of <code>iterator</code><br/>
* Like <code>iterators</code>, we can get the next value from a <code>generator</code> using <code>next()</code><br/>
** <code>for</code> gets values by calling <code>next()</code> implicitly</p>

<p>I hope this post was helpful. If you had never heard of <code>generators</code>, I hope you now understand what they are, why they&rsquo;re useful, and how to use them. If you were somewhat familiar with <code>generators</code>, I hope any confusion is now cleared up.</p>

<p><a href="http://www.jeffknupp.com/blog/2013/04/07/improve-your-python-yield-and-generators-explained/">Origin</a><br/>
<a href="http://www.oschina.net/translate/improve-your-python-yield-and-generators-explained">Reference</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Python with語句(轉)]]></title>
    <link href="http://www.aprilzephyr.com/blog/04062014/python-with-yu-ju/"/>
    <updated>2014-04-06T16:37:46+08:00</updated>
    <id>http://www.aprilzephyr.com/blog/04062014/python-with-yu-ju</id>
    <content type="html"><![CDATA[<p><strong>1. With 語句是什麼</strong><br/>
Python’s with statement provides a very convenient way of dealing with the situation where you have to do a setup and teardown to make something happen. A very good example for this is the situation where you want to gain a handler to a file, read data from the file and the close the file handler.<br/>
有一些任務，可能事先需要設置，事後做清理工作。對於這種場景，Python的with語句提供了一種非常方便的處理方式。一個很好的例子是文件處理，你需要獲取一個文件句柄，從文件中讀取數據，然後關閉文件句柄。<!--more--></p>

<p>Without the with statement, one would write something along the lines of:<br/>
如果不用with語句，代碼如下： <br/>
<code>python
file = open("/tmp/foo.txt")
data = file.read()
file.close()
</code><br/>
There are two annoying things here. First, you end up forgetting to close the file handler. The second is how to handle exceptions that may occur once the file handler has been obtained. One could write something like this to get around this:<br/>
這裏有兩個問題。一是可能忘記關閉文件句柄；二是文件讀取數據發生異常，沒有進行任何處理。下面是處理異常的加強版本：<br/>
``` python
file = open(&ldquo;/tmp/foo.txt&rdquo;)
try:</p>

<pre><code>data = file.read()
</code></pre>

<p>finally:</p>

<pre><code>file.close()
</code></pre>

<p><code>  
While this works well, it is unnecessarily verbose. This is where with is useful. The good thing about with apart from the better syntax is that it is very good handling exceptions. The above code would look like this, when using with:  
雖然這段代碼運行良好，但是太冗長了。這時候就是with一展身手的時候了。除了有更優雅的語法，with還可以很好的處理上下文環境產生的異常。下面是with版本的代碼：  
</code> python
with open(&ldquo;/tmp/foo.txt&rdquo;) as file:</p>

<pre><code>data = file.read()
</code></pre>

<p>```</p>

<p><strong>2. with如何工作</strong><br/>
while this might look like magic, the way Python handles with is more clever than magic. The basic idea is that the statement after with has to evaluate an object that responds to an __enter__() as well as an __exit__() function.<br/>
這看起來充滿魔法，但不僅僅是魔法，Python對with的處理還很聰明。基本思想是with所求值的對象必須有一個__enter__()方法，一個__exit__()方法。</p>

<p>After the statement that follows with is evaluated, the __enter__() function on the resulting object is called. The value returned by this function is assigned to the variable following as. After every statement in the block is evaluated, the __exit__() function is called.<br/>
緊跟with後面的語句被求值後，返回對象的__enter__()方法被調用，這個方法的返回值將被賦值給as後面的變量。當with後面的代碼塊全部被執行完之後，將調用前面返回對象的__exit__()方法。</p>

<p>This can be demonstrated with the following example:<br/>
下面例子可以具體說明with如何工作：<br/>
``` python</p>

<h1>!/usr/bin/env python</h1>

<h1>with_example01.py</h1>

<p>class Sample:</p>

<pre><code>def __enter__(self):
    print "In __enter__()"
    return "Foo"

def __exit__(self, type, value, trace):
    print "In __exit__()"
</code></pre>

<p>def get_sample():</p>

<pre><code>return Sample()
</code></pre>

<p>with get_sample() as sample:</p>

<pre><code>print "sample:", sample
</code></pre>

<p><code>  
When executed, this will result in:  
運行代碼，輸出如下  
</code> python
bash-3.2$ ./with_example01.py
In <strong>enter</strong>()
sample: Foo
In <strong>exit</strong>()
<code>  
As you can see,  
The \_\_enter\_\_() function is executed  
The value returned by it - in this case "Foo" is assigned to sample  
The body of the block is executed, thereby printing the value of sample ie. "Foo"  
The \_\_exit\_\_() function is called.  
What makes with really powerful is the fact that it can handle exceptions. You would have noticed that the \_\_exit\_\_() function for Sample takes three arguments - val, type and trace. These are useful in exception handling. Let’s see how this works by modifying the above example.  
正如你看到的，  
1) \_\_enter\_\_()方法被執行  
2) \_\_enter\_\_()方法返回的值 - 這個例子中是"Foo"，賦值給變量'sample'  
3) 執行代碼塊，打印變量"sample"的值為 "Foo"  
4) \_\_exit\_\_()方法被調用  
with真正強大之處是它可以處理異常。可能你已經註意到Sample類的\_\_exit()\_\_方法有三個參數- val, type 和 trace。 這些參數在異常處理中相當有用。我們來改一下代碼，看看具體如何工作的。  
</code> python</p>

<h1>!/usr/bin/env python</h1>

<h1>with_example02.py</h1>

<p>class Sample:</p>

<pre><code>def __enter__(self):
    return self

def __exit__(self, type, value, trace):
    print "type:", type
    print "value:", value
    print "trace:", trace

def do_something(self):
    bar = 1/0
    return bar + 10
</code></pre>

<p>with Sample() as sample:</p>

<pre><code>sample.do_something()
</code></pre>

<p>```<br/>
Notice how in this example, instead of get_sample(), with takes Sample(). It does not matter, as long as the statement that follows with evaluates to an object that has an __enter__() and __exit__() functions. In this case, Sample()’s __enter__() returns the newly created instance of Sample and that is what gets passed to sample.<br/>
這個例子中，with後面的get_sample()變成了Sample()。這沒有任何關系，只要緊跟with後面的語句所返回的對象有__enter__()和__exit__()方法即可。此例中，Sample()的__enter__()方法返回新創建的Sample對象，並賦值給變量sample。</p>

<p>When executed:<br/>
代碼執行後：<br/>
``` python
bash-3.2$ ./with_example02.py
type: <type 'exceptions.ZeroDivisionError'>
value: integer division or modulo by zero
trace: <traceback object at 0x1004a8128>
Traceback (most recent call last):
  File &ldquo;./with_example02.py&rdquo;, line 19, in <module></p>

<pre><code>sample.do_something()
</code></pre>

<p>  File &ldquo;./with_example02.py&rdquo;, line 15, in do_something</p>

<pre><code>bar = 1/0
</code></pre>

<p>ZeroDivisionError: integer division or modulo by zero
```<br/>
Essentially, if there are exceptions being thrown from anywhere inside the block, the __exit__() function for the object is called. As you can see, the type, value and the stack trace associated with the exception thrown is passed to this function. In this case, you can see that there was a ZeroDivisionError exception being thrown. People implementing libraries can write code that clean up resources, close files etc. in their __exit__() functions.<br/>
實際上，在with後面的代碼塊拋出任何異常時，__exit__()方法被執行。正如例子所示，異常拋出時，與之關聯的type，value和stack trace傳給__exit__()方法，因此拋出的ZeroDivisionError異常被打印出來了。開發庫時，清理資源，關閉文件等等操作，都可以放在__exit__方法當中。</p>

<p>Thus, Python’s with is a nifty construct that makes code a little less verbose and makes cleaning up during exceptions a bit easier.<br/>
因此，Python的with語句是提供一個有效的機制，讓代碼更簡練，同時在異常產生時，清理工作更簡單。</p>

<p>I have put the code examples given here on <a href="https://github.com/sdqali/python_dojo/tree/master/with">Github</a>.<br/>
示例代碼可以在<a href="https://github.com/sdqali/python_dojo/tree/master/with">Github</a>上面找到。</p>

<p>譯註：本文原文見<a href="http://blog.sdqali.in/blog/2012/07/09/understanding-pythons-with/">Understanding Python&rsquo;s &ldquo;With&rdquo; Statement</a></p>

<p><a href="http://python.42qu.com/11155501">Origin</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Python 動態類型(轉)]]></title>
    <link href="http://www.aprilzephyr.com/blog/04022014/python-dong-tai-lei-xing/"/>
    <updated>2014-04-02T15:15:39+08:00</updated>
    <id>http://www.aprilzephyr.com/blog/04022014/python-dong-tai-lei-xing</id>
    <content type="html"><![CDATA[<p>Python中只有一個賦值模型</p>

<h4>1. 缺少類型聲明語句的情況</h4>

<p>在Python中，類型是在運行過程中自動決定的，而不是通過代碼聲明。這意味著沒有必要事聲明變量。只要記住，這個概念實質上對變量，對象和它們之間的關系都適用。那麽這個概念也容易理解並掌握。</p>

<p><strong>A 變量，對象和引用</strong><br/>
變量創建：一個變量，當代碼第一次給它賦值時它就被創建了。之後的賦值將會改變已創建的變量名的值。Python在代碼運行之前先檢測變量名，可以當成是最初的賦值創建變量。<!--more--><br/>
變量類型：變量永遠不會有任何的它關聯的類型信息或約束。類型的概念是存在於對象中而不是變量中。變量原本是通用的。它只是在一個特定的時間點，簡單地引用了一個特定的對像而已。<br/>
變量的使用：當變量出現在表達式中時，它會馬上被當前引用的對像所代替，無論這個對象是什麽類型。<br/>
此外，所有的變量都必須在其使用前明確地賦值。使用未賦值的變量會產生錯誤。<br/>
<code>&gt;&gt;&gt;a=3</code></p>

<p>在概念上說，Python將執行三個不同的步驟去完成這個請求。<br/>
1) 創建一個對象來代表值3<br/>
2) 創建一個變量a，如果它還沒有創建的話<br/>
3) 將變量與新的對象3連接</p>

<p>在python中從變量到對象的連接稱作引用。引用是一種關系，以內存中的指針形式實現。<br/>
* 變量 是一個系統表的元素，擁有指向對象的連接空間。<br/>
* 對象 是被分配的一塊內存，有足夠的空間去表現它們所代表的值。<br/>
* 引用 是自動形成的從變量到對象的指針。</p>

<p>每一個對象都用兩個標準的頭部信息：一個類型標誌符去標識這個對象的類型，以及一個引用的計數器，用來決定是不是可以回收這個對象。</p>

<p><strong>B 類型屬於對象，而不是變量</strong><br/>
Python中的類型是與對象相關聯的，而不是和變量關聯。<br/>
變量沒有類型，變量指向對象。對象有類型，知道自己的類型，每個對象都包含了一個頭部信息，其中標記了這個對象的類型。</p>

<p><strong>C 對象的垃圾收集</strong><br/>
對象生命結束時發生了什麽變化？<br/>
每當一個變量名被賦與了一個新的對象，之前的那個對象占用的空間就會被收回（如果它沒有被其他變量名和對象所引用).這種自動回收對象空間的技術稱作垃圾收集。<br/>
在內部，Python是通過保持用每個對象中的計數器記錄引用指到這個對象上的次數來完成這一功能。一旦（並精確在同一時間）這個計數器被設置為零，這個對象的內存空間就會自動收回。垃圾收集最直接的，可感受到的好處就是這意味著可以在腳本中任意使用對象而不需要考慮釋放內存空間。<br/>
```</p>

<blockquote><blockquote><blockquote><p>x=42
id(x)
674748828
x=&ldquo;cli&rdquo;
id(x)  <br/>
676367648
```</p></blockquote></blockquote></blockquote>

<h4>2. 共享引用</h4>

<p>上面所講都是單個變量被賦值引用了多個對象的情況。現在，在交互模式下，引入另一個變量，並看一下變量名和對象的變化。<br/>
```</p>

<blockquote><blockquote><blockquote><p>a=10
b=a
id(a)
674749212
id(b)
674749212
```<br/>
第二行會使用python創建變量b。使用的是變量a,並且它在這裏沒有被賦值，所以它被替換成其應用的對象10，從而b也成為這個對象的一個引用。實際效果就是變量a和b都引用相同的對象（也就是說指向了相同的內存空間。在Python中稱作是共享引用&mdash;多個變量名應用了同一個對象。)</p></blockquote></blockquote></blockquote>

<p>```</p>

<blockquote><blockquote><blockquote><p>a=10
b=a<br/>
a=&lsquo;cli&rsquo;
id(a)
676367648
id(b)
674749212
```<br/>
變量a改變了，但是不影響變量b.這完全可以說明變量b是指向對象10內存空間的。</p></blockquote></blockquote></blockquote>

<p>在ptyhon中，變量總是一個指向對象的指針，而不是可以改變的內存區域的標簽。給一變量賦一個新的值，並不是替換了原始的對象，而是讓這個變量去引用完全不同的一個對象。實際的效果就是對一個變量賦值，僅僅會影響那個被賦值的變量。</p>

<p><strong>A 共享引用和在原處修改</strong><br/>
有一些對象和類型確實會在實地改變對象。例如，在一個列表中對一個偏移進行賦值確實會改變這個列表對象，而不是生成一個新的列表對象。<br/>
```</p>

<blockquote><blockquote><blockquote><p>T1=[11,12,13]
T2=T1
T1
[11, 12, 13]
T2
[11, 12, 13]
T1=22
T1
22
T2
[11, 12, 13]
```</p></blockquote></blockquote></blockquote>

<p>這個和先前一樣T1改變了T2沒有改變，T2改變也不影響T1<br/>
```</p>

<blockquote><blockquote><blockquote><p>T1=[11,12,13]
T2=T1
T1
[11, 12, 13]
T2
[11, 12, 13]
T2[1]=33   <br/>
T1
[33, 12, 13]
T2
[33, 12, 13]
<code>  
發現T2改變了，T1也跟這改變了  
同樣T1改變了，T2也改變了  
</code>
T1[1]=99<br/>
T2
[33, 99, 13]
T1
[33, 99, 13]
```<br/>
這裏T1沒有改變，改變了T1所引用對象的一個元素。這類修改會覆蓋列表對象中的某部分。因為這個列表對象是與其他對象共享的（被其他對象引用），那麽一個像這樣在原處的改變不僅僅會對T1有影響。必須意識到當做了這樣的修改，它會影響程序的其他部分。</p></blockquote></blockquote></blockquote>

<p>如果不想要這樣的現象發生，需要Python拷貝對象，而不是創建引用。方法包括內置列表函數以及標準庫的copy模塊，最常用的辦法就是從頭到尾的分片T1[:]<br/>
```</p>

<blockquote><blockquote><blockquote><p>T1=[11,12,13]
T2=T1[:]
T1
[11, 12, 13]
T2
[11, 12, 13]
T1[0]=99
T1
[99, 12, 13]
T2
[11, 12, 13]
id(T1)
676366604
id(T2)
675542060
<code>  
T1和T2指向不同的對象，所以不會相互影響。  
註意：這種分片技術不會引用在其他的可變的核心類型上（字典，因為它們不是序列），對字典應該使用D.copy（）方法.而且，註意標準庫中的copy模塊有一個通用的拷貝任意對象的調用，也有一個拷貝嵌套對象的結構的調用.  
</code>
X={&lsquo;name&rsquo;:&lsquo;cli&rsquo;,&lsquo;age&rsquo;:27}<br/>
import copy
Y=copy.copy(X)
X
{&lsquo;age&rsquo;: 27, &lsquo;name&rsquo;: &lsquo;cli&rsquo;}
Y
{&lsquo;age&rsquo;: 27, &lsquo;name&rsquo;: &lsquo;cli&rsquo;}
id(X)
676370468
id(Y)
676414436
X={&lsquo;name&rsquo;:{&lsquo;FirstName&rsquo;:&lsquo;cli&rsquo;,&lsquo;LastName&rsquo;:&lsquo;cli&rsquo;},&lsquo;age&rsquo;:27}  <br/>
X
{&lsquo;age&rsquo;: 27, &lsquo;name&rsquo;: {&lsquo;LastName&rsquo;: &lsquo;cli&rsquo;, &lsquo;FirstName&rsquo;: &lsquo;cli&rsquo;}}
Y=copy.copy(X)
Y
{&lsquo;age&rsquo;: 27, &lsquo;name&rsquo;: {&lsquo;LastName&rsquo;: &lsquo;cli&rsquo;, &lsquo;FirstName&rsquo;: &lsquo;cli&rsquo;}}
Z=copy.deepcopy(X)
Z
{&lsquo;age&rsquo;: 27, &lsquo;name&rsquo;: {&lsquo;LastName&rsquo;: &lsquo;cli&rsquo;, &lsquo;FirstName&rsquo;: &lsquo;cli&rsquo;}}
```</p></blockquote></blockquote></blockquote>

<p><strong>B 共享引用和相等</strong>
```</p>

<blockquote><blockquote><blockquote><p>x=33
x=&lsquo;cli&rsquo;
```<br/>
因為Python緩存並復用了小的整數和小的字符串，就像前文提到的那樣，這裏對象33也許不像前期所說的被收回，相反，它將可能仍保持在一個系統表中，等待下一次你的代碼生成另一個33來利用。盡快如此，大多數種類的對象都會在不再引用時馬上回收。對於那些不會被回收的，緩沖機制與代碼並沒有什麽關系。</p></blockquote></blockquote></blockquote>

<p>判斷是否相等<br/>
```</p>

<blockquote><blockquote><blockquote><p>L=[1,2,3]
M=L
L==M
True
L is M
True
<code>  
==檢查對象是否有相同的值。 is操作符，檢查對象的同一性。如果兩個變量名精準地指向同一個對象，它會返回True。所以這是一種更嚴格的相等測試。  
實際上,is只是比較現實引用的指針。所以如果必要的話是代碼中檢測共享引用的一種方法。如果變量名引用值相等。但是為不同的對象，它的返回值將是False.  
</code>
L=[1,2,3]
M=[1,2,3]
L==M
True
L is M
False
id(L)
676367788
id(M)
676367724
```<br/>
通過id()函數可以看到兩個變量指向不同的對象。</p></blockquote></blockquote></blockquote>

<p>```</p>

<blockquote><blockquote><blockquote><p>X=33
Y=33
X==Y
True
X is Y
True
id(X)
674748936
id(Y)
674748936
<code>  
這個is測試返回True因為小的整數和字符串被緩存被復用了。
如果想更進一步了解，可以向Python查詢一個對象應用的次數：在sys模塊中的getrefcount函數返回對象應用的次數。  
</code>
import sys
sys.getrefcount(33)
13
sys.getrefcount(1)
427
sys.getrefcount(00)
296
sys.getrefcount(99)
6
```</p></blockquote></blockquote></blockquote>

<p><a href="http://ipseek.blog.51cto.com/1041109/786518">Origin</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Python 文件處理]]></title>
    <link href="http://www.aprilzephyr.com/blog/03312014/python-wen-jian-chu-li/"/>
    <updated>2014-03-31T17:48:17+08:00</updated>
    <id>http://www.aprilzephyr.com/blog/03312014/python-wen-jian-chu-li</id>
    <content type="html"><![CDATA[<p>python對文件的處理的兩個內建函數：<br/>
open()、file()，這個兩函數提供了初始化輸入\輸出（I\O）操作的通用接口。兩函數的功能相同。<br/>
基本用法：<br/>
file_object=open(filename, access_mode=&lsquo;r&rsquo;, buffering=-1）
file_object 是定義一個打開文件的對象<br/>
access_mode 是打開文件的模式；通常，文件使用模式  &lsquo;r&rsquo;,&lsquo;w&rsquo;,&lsquo;a&rsquo; 來打開，分別代表，讀取，寫入，追加。<br/>
&lsquo;r&rsquo; 模式打開已經存在的文件<br/>
&lsquo;w&rsquo; 模式打開的文件若存在則首先清空，再加入內容。<br/>
&lsquo;a&rsquo; 這個模式是追加內容到文件中<!--more--><br/>
註. &lsquo;b&rsquo; 模式這個是打開二進制文件，對於unix-like/unix類型的系統'b'模式是可有可無的。<br/>
buffering 訪問文件所采用的緩沖方式。其中0表示不緩沖，1表示只緩沖一行數據，任何其它大於1的值代表使用給定的值作為緩沖區大小。不給定此參數或者參數為負數都表示使用系統默認的緩沖機制。<br/>
使用open打開文件之後一定記得調用close()關閉文件。</p>

<p>常用的文件訪問方式如下：<br/>
r        以讀方式打開<br/>
rU或Ua   以讀方式打開同時提供通用換行符支持<br/>
w        以寫方式打開<br/>
a        以追加方式打開<br/>
r+       以讀寫方式打開<br/>
w+       以讀寫方式打開<br/>
a+       以讀寫方式打開</p>

<p>文件的輸入：<br/>
python中有三個方法來處理文件內容的輸入：<br/>
read() 一次讀取全部的文件內容。<br/>
readline() 每次讀取文件的一行。<br/>
readlines() 讀取文件的所有行，返回一個字符串列表。</p>

<p>寫數據：<br/>
<code>python
file_object = open('thefile.txt', 'w')
file_object.write(all_the_text)
file_object.close( )
</code></p>

<p>寫入多行：<br/>
<code>file_object.writelines(list_of_text_strings)</code></p>

<p>seek(offset,where):  默認值where=0表示從起始位置移動"offset"個字節，where=1表示從當前位置移動"offset"個字節，where=2表示從結束位置移動"offset"個字節。當有換行時，會被換行截斷。seek()無返回值，故值為None。</p>

<p>tell():  文件的當前位置,即tell是獲得文件指針位置，受seek、readline、read、readlines影響，不受truncate影響。</p>

<p>truncate(n):  從文件的首行首字符開始截斷，截斷文件為n個字符；無n表示從當前位置起截斷；截斷之後n後面的所有字符被刪除。其中win下的換行代表2個字符大小。<br/>
``` python</p>

<pre><code>  fso = open("f:\\a.txt",'w+')    #以w+方式，並非a方式打開文件，故文件原內容被清空
  print fso.tell()    #文件原內容被清空，故此時tell()=0

  fso.write("abcde\n")  #寫入文件abcde\n，因為換行\n占兩個字符，故共寫入7個字符
  print fso.tell()  #此時tell()=7

  fso.write("fghwm")  #又寫入文件fghwm，故此時文件共寫入7+5 =142個字符
  print fso.tell()  #此時tell()=12 

  fso.seek(1, 0)  #從起始位置即文件首行首字符開始移動1個字符
  print fso.tell()   #此時tell() =1

  print  fso.readline()  #讀取當前行，即文件的第1行，但是從第二個字符(tell()+1)開始讀，結果為:bcde。'若換成for讀取整個文件或read讀取整個文件則結果為bcdefghwm     

  print fso.tell()   #因為readline此時tell() =7,

  fso.truncate(8)  #從寫入後文件的首行首字符開始階段，截斷為8個字符，即abcde\nf，即文件的內容為：abcde\nf

  print fso.tell()   #tell() 依舊為7,並為受truncate(8)影響，但是此時文件內容為abcde\nf

  print  fso.readline()  #從tell()+1=8開始讀取，讀取當前行內容：f

  fso.close()
</code></pre>

<p>```</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Python os &amp; sys模塊]]></title>
    <link href="http://www.aprilzephyr.com/blog/03312014/python-os-sys/"/>
    <updated>2014-03-31T16:06:01+08:00</updated>
    <id>http://www.aprilzephyr.com/blog/03312014/python-os-sys</id>
    <content type="html"><![CDATA[<p><strong>1. os模塊</strong><br/>
Python os模塊包含普遍的操作系統功能。如果你希望你的程序能夠與平臺無關的話，這個模塊是尤為重要的。</p>

<p>1) os.name<br/>
輸出字符串指示正在使用的平臺。如果是window 則用'nt'表示，對於Linux/Unix用戶，它是'posix'。<br/>
2) os.mkdir(path [,mode=0777])<br/>
創建目錄<br/>
3) os.rmdir()<br/>
刪除目錄<!--more--><br/>
4) os.mkdirs()<br/>
創建多層目錄，類似系統makedir -p<br/>
5) os.removedirs()<br/>
刪除多層目錄，每層都是空的，除了要刪除的目錄外。<br/>
6) os.getcwd()<br/>
函數得到當前工作目錄，即當前Python腳本工作的目錄路徑。<br/>
7) os.listdir()<br/>
返回指定目錄下的所有文件和目錄名。
``` python</p>

<blockquote><blockquote><blockquote><p>import os
os.listdir(os.getcwd())
[&lsquo;.bash_history&rsquo;, &lsquo;.bundler&rsquo;, &lsquo;.CFUserTextEncoding&rsquo;, &lsquo;.config&rsquo;, &lsquo;.DS_Store&rsquo;, &lsquo;.gem&rsquo;, &lsquo;.gitconfig&rsquo;, &lsquo;.matplotlib&rsquo;, &lsquo;.ssh&rsquo;, &lsquo;.Trash&rsquo;, &lsquo;.Trash-500&rsquo;, &lsquo;.vim&rsquo;, &lsquo;.viminfo&rsquo;, &lsquo;Applications&rsquo;, &lsquo;Applications (Parallels)&rsquo;, &lsquo;Desktop&rsquo;, &lsquo;Documents&rsquo;, &lsquo;Downloads&rsquo;, &lsquo;Library&rsquo;, &lsquo;Movies&rsquo;, &lsquo;Music&rsquo;, &lsquo;octopress&rsquo;, &lsquo;Pictures&rsquo;, &lsquo;Public&rsquo;, &lsquo;PycharmProjects&rsquo;, &lsquo;\xe7\x99\xbe\xe5\xba\xa6\xe4\xba\x91\xe5\x90\x8c\xe6\xad\xa5\xe7\x9b\x98&rsquo;]</p>

<p>```<br/>
8) os.remove()<br/>
刪除一個文件。<br/>
9) os.system()<br/>
運行shell命令。<br/>
10) os.sep<br/>
可以取代操作系統特定的路徑分隔符。<br/>
11) os.linesep<br/>
給出當前平台使用的行終止符。<br/>
12) os.path.split()<br/>
函數返回一個路徑的目錄名和文件名<br/>
13) os.path.isfile()和os.path.isdir()函數<br/>
分別檢驗給出的路徑是一個文件還是目錄，給出True或者False。<br/>
14) os.path.exists()<br/>
檢驗給出的路徑是否真實的存在，給出True或者False。<br/>
15) os.path.abspath(name)<br/>
獲得絕對路徑。<br/>
16) os.path.normpath(path)<br/>
規範path的字符串形式。<br/>
17) os.path.getsize(name)<br/>
獲得文件大小，如果name是目錄返回0L。<br/>
18) os.path.splitext()<br/>
分離文件名與擴展名。<br/>
19) os.path.join(path,name)<br/>
連接目錄與文件名或目錄。<br/>
20) os.path.basename(path)<br/>
返回文件名。<br/>
21) os.path.dirname(path)<br/>
返回文件路徑。</p></blockquote></blockquote></blockquote>

<p><strong>2. sys模塊</strong><br/>
1) sys.argv<br/>
命令行參數List，第一個元素是程序本身路徑。<br/>
2) sys.modules.keys()<br/>
返回所有已經導入的模塊列表。<br/>
3) sys.exc_info()<br/>
獲取當前正在處理的異常類,exc_type、4) exc_value、exc_traceback當前處理的異常詳細信息。<br/>
5) sys.exit(n)<br/>
退出程序，正常退出時exit(0)。<br/>
6) sys.hexversion<br/>
獲取Python解釋程序的版本值，16進制格式如：0x020403F0。<br/>
7) sys.version<br/>
獲取Python解釋程序的版本信息。<br/>
8) sys.maxint<br/>
最大的Int值。<br/>
9) sys.maxunicode<br/>
最大的Unicode值。<br/>
10) sys.modules<br/>
返回系統導入的模塊字段，key是模塊名，value是模塊。<br/>
11) sys.path<br/>
返回模塊的搜索路徑，初始化時使用PYTHONPATH環境變量的值。<br/>
12) sys.platform<br/>
返回操作系統平臺名稱。<br/>
13) sys.stdout<br/>
標準輸出。<br/>
14) sys.stdin<br/>
標準輸入。<br/>
15) sys.stderr<br/>
錯誤輸出。<br/>
16) sys.exc_clear()<br/>
用來清除當前線程所出現的當前的或最近的錯誤信息。<br/>
17) sys.exec_prefix<br/>
返回平臺獨立的python文件安裝的位置。<br/>
18) sys.byteorder<br/>
本地字節規則的指示器，big-endian平臺的值是'big',little-endian平臺的值是'little'。<br/>
19) sys.copyright<br/>
記錄python版權相關的東西。<br/>
20) sys.api_version<br/>
解釋器的C的API版本。<br/>
21) sys.version_info<br/>
<code>&gt;&gt;&gt; sys.version_info(major=2, minor=7, micro=5, releaselevel='final', serial=0)</code><br/>
22) sys.displayhook(value)<br/>
如果value非空，這個函數會把他輸出到sys.stdout，並且將他保存進__builtin__._.指在python的交互式解釋器裏，'_&lsquo;代表上次你輸入得到的結果，hook是鉤子的意思，將上次的結果鉤過來。<br/>
23) sys.getdefaultencoding()<br/>
返回當前你所用的默認的字符編碼格式。<br/>
24) sys.getfilesystemencoding()<br/>
返回將Unicode文件名轉換成系統文件名的編碼的名字。<br/>
25) sys.setdefaultencoding(name)<br/>
用來設置當前默認的字符編碼，如果name和任何一個可用的編碼都不匹配，拋出LookupError，這個函數只會被site模塊的sitecustomize使用，一旦別site模塊使用了，他會從sys模塊移除。<br/>
26) sys.builtin_module_names<br/>
Python解釋器導入的模塊列表。<br/>
27) sys.executable<br/>
Python解釋程序路徑。<br/>
28) sys.getwindowsversion()<br/>
獲取Windows的版本。<br/>
29) sys.stdin.readline()<br/>
從標準輸入讀一行。<br/>
30) sys.stdout.write(&ldquo;a&rdquo;)<br/>
屏幕輸出a。</p>
]]></content>
  </entry>
  
</feed>
