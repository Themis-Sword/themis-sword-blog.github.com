<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: python | Themis_Sword's Blog]]></title>
  <link href="http://www.aprilzephyr.com/blog/categories/python/atom.xml" rel="self"/>
  <link href="http://www.aprilzephyr.com/"/>
  <updated>2014-04-28T19:20:35+08:00</updated>
  <id>http://www.aprilzephyr.com/</id>
  <author>
    <name><![CDATA[Themis_Sword]]></name>
    <email><![CDATA[licong0419@outlook.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Python with語句(轉)]]></title>
    <link href="http://www.aprilzephyr.com/blog/04062014/python-with-yu-ju/"/>
    <updated>2014-04-06T16:37:46+08:00</updated>
    <id>http://www.aprilzephyr.com/blog/04062014/python-with-yu-ju</id>
    <content type="html"><![CDATA[<p><strong>1. With 語句是什麼</strong><br/>
Python’s with statement provides a very convenient way of dealing with the situation where you have to do a setup and teardown to make something happen. A very good example for this is the situation where you want to gain a handler to a file, read data from the file and the close the file handler.<br/>
有一些任務，可能事先需要設置，事後做清理工作。對於這種場景，Python的with語句提供了一種非常方便的處理方式。一個很好的例子是文件處理，你需要獲取一個文件句柄，從文件中讀取數據，然後關閉文件句柄。<!--more--></p>

<p>Without the with statement, one would write something along the lines of:<br/>
如果不用with語句，代碼如下： <br/>
<code>python
file = open("/tmp/foo.txt")
data = file.read()
file.close()
</code><br/>
There are two annoying things here. First, you end up forgetting to close the file handler. The second is how to handle exceptions that may occur once the file handler has been obtained. One could write something like this to get around this:<br/>
這裏有兩個問題。一是可能忘記關閉文件句柄；二是文件讀取數據發生異常，沒有進行任何處理。下面是處理異常的加強版本：<br/>
``` python
file = open(&ldquo;/tmp/foo.txt&rdquo;)
try:</p>

<pre><code>data = file.read()
</code></pre>

<p>finally:</p>

<pre><code>file.close()
</code></pre>

<p><code>  
While this works well, it is unnecessarily verbose. This is where with is useful. The good thing about with apart from the better syntax is that it is very good handling exceptions. The above code would look like this, when using with:  
雖然這段代碼運行良好，但是太冗長了。這時候就是with一展身手的時候了。除了有更優雅的語法，with還可以很好的處理上下文環境產生的異常。下面是with版本的代碼：  
</code> python
with open(&ldquo;/tmp/foo.txt&rdquo;) as file:</p>

<pre><code>data = file.read()
</code></pre>

<p>```</p>

<p><strong>2. with如何工作</strong><br/>
while this might look like magic, the way Python handles with is more clever than magic. The basic idea is that the statement after with has to evaluate an object that responds to an __enter__() as well as an __exit__() function.<br/>
這看起來充滿魔法，但不僅僅是魔法，Python對with的處理還很聰明。基本思想是with所求值的對象必須有一個__enter__()方法，一個__exit__()方法。</p>

<p>After the statement that follows with is evaluated, the __enter__() function on the resulting object is called. The value returned by this function is assigned to the variable following as. After every statement in the block is evaluated, the __exit__() function is called.<br/>
緊跟with後面的語句被求值後，返回對象的__enter__()方法被調用，這個方法的返回值將被賦值給as後面的變量。當with後面的代碼塊全部被執行完之後，將調用前面返回對象的__exit__()方法。</p>

<p>This can be demonstrated with the following example:<br/>
下面例子可以具體說明with如何工作：<br/>
``` python</p>

<h1>!/usr/bin/env python</h1>

<h1>with_example01.py</h1>

<p>class Sample:</p>

<pre><code>def __enter__(self):
    print "In __enter__()"
    return "Foo"

def __exit__(self, type, value, trace):
    print "In __exit__()"
</code></pre>

<p>def get_sample():</p>

<pre><code>return Sample()
</code></pre>

<p>with get_sample() as sample:</p>

<pre><code>print "sample:", sample
</code></pre>

<p><code>  
When executed, this will result in:  
運行代碼，輸出如下  
</code> python
bash-3.2$ ./with_example01.py
In <strong>enter</strong>()
sample: Foo
In <strong>exit</strong>()
<code>  
As you can see,  
The \_\_enter\_\_() function is executed  
The value returned by it - in this case "Foo" is assigned to sample  
The body of the block is executed, thereby printing the value of sample ie. "Foo"  
The \_\_exit\_\_() function is called.  
What makes with really powerful is the fact that it can handle exceptions. You would have noticed that the \_\_exit\_\_() function for Sample takes three arguments - val, type and trace. These are useful in exception handling. Let’s see how this works by modifying the above example.  
正如你看到的，  
1) \_\_enter\_\_()方法被執行  
2) \_\_enter\_\_()方法返回的值 - 這個例子中是"Foo"，賦值給變量'sample'  
3) 執行代碼塊，打印變量"sample"的值為 "Foo"  
4) \_\_exit\_\_()方法被調用  
with真正強大之處是它可以處理異常。可能你已經註意到Sample類的\_\_exit()\_\_方法有三個參數- val, type 和 trace。 這些參數在異常處理中相當有用。我們來改一下代碼，看看具體如何工作的。  
</code> python</p>

<h1>!/usr/bin/env python</h1>

<h1>with_example02.py</h1>

<p>class Sample:</p>

<pre><code>def __enter__(self):
    return self

def __exit__(self, type, value, trace):
    print "type:", type
    print "value:", value
    print "trace:", trace

def do_something(self):
    bar = 1/0
    return bar + 10
</code></pre>

<p>with Sample() as sample:</p>

<pre><code>sample.do_something()
</code></pre>

<p>```<br/>
Notice how in this example, instead of get_sample(), with takes Sample(). It does not matter, as long as the statement that follows with evaluates to an object that has an __enter__() and __exit__() functions. In this case, Sample()’s __enter__() returns the newly created instance of Sample and that is what gets passed to sample.<br/>
這個例子中，with後面的get_sample()變成了Sample()。這沒有任何關系，只要緊跟with後面的語句所返回的對象有__enter__()和__exit__()方法即可。此例中，Sample()的__enter__()方法返回新創建的Sample對象，並賦值給變量sample。</p>

<p>When executed:<br/>
代碼執行後：<br/>
``` python
bash-3.2$ ./with_example02.py
type: <type 'exceptions.ZeroDivisionError'>
value: integer division or modulo by zero
trace: <traceback object at 0x1004a8128>
Traceback (most recent call last):
  File &ldquo;./with_example02.py&rdquo;, line 19, in <module></p>

<pre><code>sample.do_something()
</code></pre>

<p>  File &ldquo;./with_example02.py&rdquo;, line 15, in do_something</p>

<pre><code>bar = 1/0
</code></pre>

<p>ZeroDivisionError: integer division or modulo by zero
```<br/>
Essentially, if there are exceptions being thrown from anywhere inside the block, the __exit__() function for the object is called. As you can see, the type, value and the stack trace associated with the exception thrown is passed to this function. In this case, you can see that there was a ZeroDivisionError exception being thrown. People implementing libraries can write code that clean up resources, close files etc. in their __exit__() functions.<br/>
實際上，在with後面的代碼塊拋出任何異常時，__exit__()方法被執行。正如例子所示，異常拋出時，與之關聯的type，value和stack trace傳給__exit__()方法，因此拋出的ZeroDivisionError異常被打印出來了。開發庫時，清理資源，關閉文件等等操作，都可以放在__exit__方法當中。</p>

<p>Thus, Python’s with is a nifty construct that makes code a little less verbose and makes cleaning up during exceptions a bit easier.<br/>
因此，Python的with語句是提供一個有效的機制，讓代碼更簡練，同時在異常產生時，清理工作更簡單。</p>

<p>I have put the code examples given here on <a href="https://github.com/sdqali/python_dojo/tree/master/with">Github</a>.<br/>
示例代碼可以在<a href="https://github.com/sdqali/python_dojo/tree/master/with">Github</a>上面找到。</p>

<p>譯註：本文原文見<a href="http://blog.sdqali.in/blog/2012/07/09/understanding-pythons-with/">Understanding Python&rsquo;s &ldquo;With&rdquo; Statement</a></p>

<p><a href="http://python.42qu.com/11155501">Origin</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Python 動態類型(轉)]]></title>
    <link href="http://www.aprilzephyr.com/blog/04022014/python-dong-tai-lei-xing/"/>
    <updated>2014-04-02T15:15:39+08:00</updated>
    <id>http://www.aprilzephyr.com/blog/04022014/python-dong-tai-lei-xing</id>
    <content type="html"><![CDATA[<p>Python中只有一個賦值模型</p>

<h4>1. 缺少類型聲明語句的情況</h4>

<p>在Python中，類型是在運行過程中自動決定的，而不是通過代碼聲明。這意味著沒有必要事聲明變量。只要記住，這個概念實質上對變量，對象和它們之間的關系都適用。那麽這個概念也容易理解並掌握。</p>

<p><strong>A 變量，對象和引用</strong><br/>
變量創建：一個變量，當代碼第一次給它賦值時它就被創建了。之後的賦值將會改變已創建的變量名的值。Python在代碼運行之前先檢測變量名，可以當成是最初的賦值創建變量。<!--more--><br/>
變量類型：變量永遠不會有任何的它關聯的類型信息或約束。類型的概念是存在於對象中而不是變量中。變量原本是通用的。它只是在一個特定的時間點，簡單地引用了一個特定的對像而已。<br/>
變量的使用：當變量出現在表達式中時，它會馬上被當前引用的對像所代替，無論這個對象是什麽類型。<br/>
此外，所有的變量都必須在其使用前明確地賦值。使用未賦值的變量會產生錯誤。<br/>
<code>&gt;&gt;&gt;a=3</code></p>

<p>在概念上說，Python將執行三個不同的步驟去完成這個請求。<br/>
1) 創建一個對象來代表值3<br/>
2) 創建一個變量a，如果它還沒有創建的話<br/>
3) 將變量與新的對象3連接</p>

<p>在python中從變量到對象的連接稱作引用。引用是一種關系，以內存中的指針形式實現。<br/>
* 變量 是一個系統表的元素，擁有指向對象的連接空間。<br/>
* 對象 是被分配的一塊內存，有足夠的空間去表現它們所代表的值。<br/>
* 引用 是自動形成的從變量到對象的指針。</p>

<p>每一個對象都用兩個標準的頭部信息：一個類型標誌符去標識這個對象的類型，以及一個引用的計數器，用來決定是不是可以回收這個對象。</p>

<p><strong>B 類型屬於對象，而不是變量</strong><br/>
Python中的類型是與對象相關聯的，而不是和變量關聯。<br/>
變量沒有類型，變量指向對象。對象有類型，知道自己的類型，每個對象都包含了一個頭部信息，其中標記了這個對象的類型。</p>

<p><strong>C 對象的垃圾收集</strong><br/>
對象生命結束時發生了什麽變化？<br/>
每當一個變量名被賦與了一個新的對象，之前的那個對象占用的空間就會被收回（如果它沒有被其他變量名和對象所引用).這種自動回收對象空間的技術稱作垃圾收集。<br/>
在內部，Python是通過保持用每個對象中的計數器記錄引用指到這個對象上的次數來完成這一功能。一旦（並精確在同一時間）這個計數器被設置為零，這個對象的內存空間就會自動收回。垃圾收集最直接的，可感受到的好處就是這意味著可以在腳本中任意使用對象而不需要考慮釋放內存空間。<br/>
```</p>

<blockquote><blockquote><blockquote><p>x=42
id(x)
674748828
x=&ldquo;cli&rdquo;
id(x)  <br/>
676367648
```</p></blockquote></blockquote></blockquote>

<h4>2. 共享引用</h4>

<p>上面所講都是單個變量被賦值引用了多個對象的情況。現在，在交互模式下，引入另一個變量，並看一下變量名和對象的變化。<br/>
```</p>

<blockquote><blockquote><blockquote><p>a=10
b=a
id(a)
674749212
id(b)
674749212
```<br/>
第二行會使用python創建變量b。使用的是變量a,並且它在這裏沒有被賦值，所以它被替換成其應用的對象10，從而b也成為這個對象的一個引用。實際效果就是變量a和b都引用相同的對象（也就是說指向了相同的內存空間。在Python中稱作是共享引用&mdash;多個變量名應用了同一個對象。)</p></blockquote></blockquote></blockquote>

<p>```</p>

<blockquote><blockquote><blockquote><p>a=10
b=a<br/>
a=&lsquo;cli&rsquo;
id(a)
676367648
id(b)
674749212
```<br/>
變量a改變了，但是不影響變量b.這完全可以說明變量b是指向對象10內存空間的。</p></blockquote></blockquote></blockquote>

<p>在ptyhon中，變量總是一個指向對象的指針，而不是可以改變的內存區域的標簽。給一變量賦一個新的值，並不是替換了原始的對象，而是讓這個變量去引用完全不同的一個對象。實際的效果就是對一個變量賦值，僅僅會影響那個被賦值的變量。</p>

<p><strong>A 共享引用和在原處修改</strong><br/>
有一些對象和類型確實會在實地改變對象。例如，在一個列表中對一個偏移進行賦值確實會改變這個列表對象，而不是生成一個新的列表對象。<br/>
```</p>

<blockquote><blockquote><blockquote><p>T1=[11,12,13]
T2=T1
T1
[11, 12, 13]
T2
[11, 12, 13]
T1=22
T1
22
T2
[11, 12, 13]
```</p></blockquote></blockquote></blockquote>

<p>這個和先前一樣T1改變了T2沒有改變，T2改變也不影響T1<br/>
```</p>

<blockquote><blockquote><blockquote><p>T1=[11,12,13]
T2=T1
T1
[11, 12, 13]
T2
[11, 12, 13]
T2[1]=33   <br/>
T1
[33, 12, 13]
T2
[33, 12, 13]
<code>  
發現T2改變了，T1也跟這改變了  
同樣T1改變了，T2也改變了  
</code>
T1[1]=99<br/>
T2
[33, 99, 13]
T1
[33, 99, 13]
```<br/>
這裏T1沒有改變，改變了T1所引用對象的一個元素。這類修改會覆蓋列表對象中的某部分。因為這個列表對象是與其他對象共享的（被其他對象引用），那麽一個像這樣在原處的改變不僅僅會對T1有影響。必須意識到當做了這樣的修改，它會影響程序的其他部分。</p></blockquote></blockquote></blockquote>

<p>如果不想要這樣的現象發生，需要Python拷貝對象，而不是創建引用。方法包括內置列表函數以及標準庫的copy模塊，最常用的辦法就是從頭到尾的分片T1[:]<br/>
```</p>

<blockquote><blockquote><blockquote><p>T1=[11,12,13]
T2=T1[:]
T1
[11, 12, 13]
T2
[11, 12, 13]
T1[0]=99
T1
[99, 12, 13]
T2
[11, 12, 13]
id(T1)
676366604
id(T2)
675542060
<code>  
T1和T2指向不同的對象，所以不會相互影響。  
註意：這種分片技術不會引用在其他的可變的核心類型上（字典，因為它們不是序列），對字典應該使用D.copy（）方法.而且，註意標準庫中的copy模塊有一個通用的拷貝任意對象的調用，也有一個拷貝嵌套對象的結構的調用.  
</code>
X={&lsquo;name&rsquo;:&lsquo;cli&rsquo;,&lsquo;age&rsquo;:27}<br/>
import copy
Y=copy.copy(X)
X
{&lsquo;age&rsquo;: 27, &lsquo;name&rsquo;: &lsquo;cli&rsquo;}
Y
{&lsquo;age&rsquo;: 27, &lsquo;name&rsquo;: &lsquo;cli&rsquo;}
id(X)
676370468
id(Y)
676414436
X={&lsquo;name&rsquo;:{&lsquo;FirstName&rsquo;:&lsquo;cli&rsquo;,&lsquo;LastName&rsquo;:&lsquo;cli&rsquo;},&lsquo;age&rsquo;:27}  <br/>
X
{&lsquo;age&rsquo;: 27, &lsquo;name&rsquo;: {&lsquo;LastName&rsquo;: &lsquo;cli&rsquo;, &lsquo;FirstName&rsquo;: &lsquo;cli&rsquo;}}
Y=copy.copy(X)
Y
{&lsquo;age&rsquo;: 27, &lsquo;name&rsquo;: {&lsquo;LastName&rsquo;: &lsquo;cli&rsquo;, &lsquo;FirstName&rsquo;: &lsquo;cli&rsquo;}}
Z=copy.deepcopy(X)
Z
{&lsquo;age&rsquo;: 27, &lsquo;name&rsquo;: {&lsquo;LastName&rsquo;: &lsquo;cli&rsquo;, &lsquo;FirstName&rsquo;: &lsquo;cli&rsquo;}}
```</p></blockquote></blockquote></blockquote>

<p><strong>B 共享引用和相等</strong>
```</p>

<blockquote><blockquote><blockquote><p>x=33
x=&lsquo;cli&rsquo;
```<br/>
因為Python緩存並復用了小的整數和小的字符串，就像前文提到的那樣，這裏對象33也許不像前期所說的被收回，相反，它將可能仍保持在一個系統表中，等待下一次你的代碼生成另一個33來利用。盡快如此，大多數種類的對象都會在不再引用時馬上回收。對於那些不會被回收的，緩沖機制與代碼並沒有什麽關系。</p></blockquote></blockquote></blockquote>

<p>判斷是否相等<br/>
```</p>

<blockquote><blockquote><blockquote><p>L=[1,2,3]
M=L
L==M
True
L is M
True
<code>  
==檢查對象是否有相同的值。 is操作符，檢查對象的同一性。如果兩個變量名精準地指向同一個對象，它會返回True。所以這是一種更嚴格的相等測試。  
實際上,is只是比較現實引用的指針。所以如果必要的話是代碼中檢測共享引用的一種方法。如果變量名引用值相等。但是為不同的對象，它的返回值將是False.  
</code>
L=[1,2,3]
M=[1,2,3]
L==M
True
L is M
False
id(L)
676367788
id(M)
676367724
```<br/>
通過id()函數可以看到兩個變量指向不同的對象。</p></blockquote></blockquote></blockquote>

<p>```</p>

<blockquote><blockquote><blockquote><p>X=33
Y=33
X==Y
True
X is Y
True
id(X)
674748936
id(Y)
674748936
<code>  
這個is測試返回True因為小的整數和字符串被緩存被復用了。
如果想更進一步了解，可以向Python查詢一個對象應用的次數：在sys模塊中的getrefcount函數返回對象應用的次數。  
</code>
import sys
sys.getrefcount(33)
13
sys.getrefcount(1)
427
sys.getrefcount(00)
296
sys.getrefcount(99)
6
```</p></blockquote></blockquote></blockquote>

<p><a href="http://ipseek.blog.51cto.com/1041109/786518">Origin</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Python 文件處理]]></title>
    <link href="http://www.aprilzephyr.com/blog/03312014/python-wen-jian-chu-li/"/>
    <updated>2014-03-31T17:48:17+08:00</updated>
    <id>http://www.aprilzephyr.com/blog/03312014/python-wen-jian-chu-li</id>
    <content type="html"><![CDATA[<p>python對文件的處理的兩個內建函數：<br/>
open()、file()，這個兩函數提供了初始化輸入\輸出（I\O）操作的通用接口。兩函數的功能相同。<br/>
基本用法：<br/>
file_object=open(filename, access_mode=&lsquo;r&rsquo;, buffering=-1）
file_object 是定義一個打開文件的對象<br/>
access_mode 是打開文件的模式；通常，文件使用模式  &lsquo;r&rsquo;,&lsquo;w&rsquo;,&lsquo;a&rsquo; 來打開，分別代表，讀取，寫入，追加。<br/>
&lsquo;r&rsquo; 模式打開已經存在的文件<br/>
&lsquo;w&rsquo; 模式打開的文件若存在則首先清空，再加入內容。<br/>
&lsquo;a&rsquo; 這個模式是追加內容到文件中<!--more--><br/>
註. &lsquo;b&rsquo; 模式這個是打開二進制文件，對於unix-like/unix類型的系統'b'模式是可有可無的。<br/>
buffering 訪問文件所采用的緩沖方式。其中0表示不緩沖，1表示只緩沖一行數據，任何其它大於1的值代表使用給定的值作為緩沖區大小。不給定此參數或者參數為負數都表示使用系統默認的緩沖機制。<br/>
使用open打開文件之後一定記得調用close()關閉文件。</p>

<p>常用的文件訪問方式如下：<br/>
r        以讀方式打開<br/>
rU或Ua   以讀方式打開同時提供通用換行符支持<br/>
w        以寫方式打開<br/>
a        以追加方式打開<br/>
r+       以讀寫方式打開<br/>
w+       以讀寫方式打開<br/>
a+       以讀寫方式打開</p>

<p>文件的輸入：<br/>
python中有三個方法來處理文件內容的輸入：<br/>
read() 一次讀取全部的文件內容。<br/>
readline() 每次讀取文件的一行。<br/>
readlines() 讀取文件的所有行，返回一個字符串列表。</p>

<p>寫數據：<br/>
<code>python
file_object = open('thefile.txt', 'w')
file_object.write(all_the_text)
file_object.close( )
</code></p>

<p>寫入多行：<br/>
<code>file_object.writelines(list_of_text_strings)</code></p>

<p>seek(offset,where):  默認值where=0表示從起始位置移動"offset"個字節，where=1表示從當前位置移動"offset"個字節，where=2表示從結束位置移動"offset"個字節。當有換行時，會被換行截斷。seek()無返回值，故值為None。</p>

<p>tell():  文件的當前位置,即tell是獲得文件指針位置，受seek、readline、read、readlines影響，不受truncate影響。</p>

<p>truncate(n):  從文件的首行首字符開始截斷，截斷文件為n個字符；無n表示從當前位置起截斷；截斷之後n後面的所有字符被刪除。其中win下的換行代表2個字符大小。<br/>
``` python</p>

<pre><code>  fso = open("f:\\a.txt",'w+')    #以w+方式，並非a方式打開文件，故文件原內容被清空
  print fso.tell()    #文件原內容被清空，故此時tell()=0

  fso.write("abcde\n")  #寫入文件abcde\n，因為換行\n占兩個字符，故共寫入7個字符
  print fso.tell()  #此時tell()=7

  fso.write("fghwm")  #又寫入文件fghwm，故此時文件共寫入7+5 =142個字符
  print fso.tell()  #此時tell()=12 

  fso.seek(1, 0)  #從起始位置即文件首行首字符開始移動1個字符
  print fso.tell()   #此時tell() =1

  print  fso.readline()  #讀取當前行，即文件的第1行，但是從第二個字符(tell()+1)開始讀，結果為:bcde。'若換成for讀取整個文件或read讀取整個文件則結果為bcdefghwm     

  print fso.tell()   #因為readline此時tell() =7,

  fso.truncate(8)  #從寫入後文件的首行首字符開始階段，截斷為8個字符，即abcde\nf，即文件的內容為：abcde\nf

  print fso.tell()   #tell() 依舊為7,並為受truncate(8)影響，但是此時文件內容為abcde\nf

  print  fso.readline()  #從tell()+1=8開始讀取，讀取當前行內容：f

  fso.close()
</code></pre>

<p>```</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Python os &amp; sys模塊]]></title>
    <link href="http://www.aprilzephyr.com/blog/03312014/python-os-sys/"/>
    <updated>2014-03-31T16:06:01+08:00</updated>
    <id>http://www.aprilzephyr.com/blog/03312014/python-os-sys</id>
    <content type="html"><![CDATA[<p><strong>1. os模塊</strong><br/>
Python os模塊包含普遍的操作系統功能。如果你希望你的程序能夠與平臺無關的話，這個模塊是尤為重要的。</p>

<p>1) os.name<br/>
輸出字符串指示正在使用的平臺。如果是window 則用'nt'表示，對於Linux/Unix用戶，它是'posix'。<br/>
2) os.mkdir(path [,mode=0777])<br/>
創建目錄<br/>
3) os.rmdir()<br/>
刪除目錄<!--more--><br/>
4) os.mkdirs()<br/>
創建多層目錄，類似系統makedir -p<br/>
5) os.removedirs()<br/>
刪除多層目錄，每層都是空的，除了要刪除的目錄外。<br/>
6) os.getcwd()<br/>
函數得到當前工作目錄，即當前Python腳本工作的目錄路徑。<br/>
7) os.listdir()<br/>
返回指定目錄下的所有文件和目錄名。
``` python</p>

<blockquote><blockquote><blockquote><p>import os
os.listdir(os.getcwd())
[&lsquo;.bash_history&rsquo;, &lsquo;.bundler&rsquo;, &lsquo;.CFUserTextEncoding&rsquo;, &lsquo;.config&rsquo;, &lsquo;.DS_Store&rsquo;, &lsquo;.gem&rsquo;, &lsquo;.gitconfig&rsquo;, &lsquo;.matplotlib&rsquo;, &lsquo;.ssh&rsquo;, &lsquo;.Trash&rsquo;, &lsquo;.Trash-500&rsquo;, &lsquo;.vim&rsquo;, &lsquo;.viminfo&rsquo;, &lsquo;Applications&rsquo;, &lsquo;Applications (Parallels)&rsquo;, &lsquo;Desktop&rsquo;, &lsquo;Documents&rsquo;, &lsquo;Downloads&rsquo;, &lsquo;Library&rsquo;, &lsquo;Movies&rsquo;, &lsquo;Music&rsquo;, &lsquo;octopress&rsquo;, &lsquo;Pictures&rsquo;, &lsquo;Public&rsquo;, &lsquo;PycharmProjects&rsquo;, &lsquo;\xe7\x99\xbe\xe5\xba\xa6\xe4\xba\x91\xe5\x90\x8c\xe6\xad\xa5\xe7\x9b\x98&rsquo;]</p>

<p>```<br/>
8) os.remove()<br/>
刪除一個文件。<br/>
9) os.system()<br/>
運行shell命令。<br/>
10) os.sep<br/>
可以取代操作系統特定的路徑分隔符。<br/>
11) os.linesep<br/>
給出當前平台使用的行終止符。<br/>
12) os.path.split()<br/>
函數返回一個路徑的目錄名和文件名<br/>
13) os.path.isfile()和os.path.isdir()函數<br/>
分別檢驗給出的路徑是一個文件還是目錄，給出True或者False。<br/>
14) os.path.exists()<br/>
檢驗給出的路徑是否真實的存在，給出True或者False。<br/>
15) os.path.abspath(name)<br/>
獲得絕對路徑。<br/>
16) os.path.normpath(path)<br/>
規範path的字符串形式。<br/>
17) os.path.getsize(name)<br/>
獲得文件大小，如果name是目錄返回0L。<br/>
18) os.path.splitext()<br/>
分離文件名與擴展名。<br/>
19) os.path.join(path,name)<br/>
連接目錄與文件名或目錄。<br/>
20) os.path.basename(path)<br/>
返回文件名。<br/>
21) os.path.dirname(path)<br/>
返回文件路徑。</p></blockquote></blockquote></blockquote>

<p><strong>2. sys模塊</strong><br/>
1) sys.argv<br/>
命令行參數List，第一個元素是程序本身路徑。<br/>
2) sys.modules.keys()<br/>
返回所有已經導入的模塊列表。<br/>
3) sys.exc_info()<br/>
獲取當前正在處理的異常類,exc_type、4) exc_value、exc_traceback當前處理的異常詳細信息。<br/>
5) sys.exit(n)<br/>
退出程序，正常退出時exit(0)。<br/>
6) sys.hexversion<br/>
獲取Python解釋程序的版本值，16進制格式如：0x020403F0。<br/>
7) sys.version<br/>
獲取Python解釋程序的版本信息。<br/>
8) sys.maxint<br/>
最大的Int值。<br/>
9) sys.maxunicode<br/>
最大的Unicode值。<br/>
10) sys.modules<br/>
返回系統導入的模塊字段，key是模塊名，value是模塊。<br/>
11) sys.path<br/>
返回模塊的搜索路徑，初始化時使用PYTHONPATH環境變量的值。<br/>
12) sys.platform<br/>
返回操作系統平臺名稱。<br/>
13) sys.stdout<br/>
標準輸出。<br/>
14) sys.stdin<br/>
標準輸入。<br/>
15) sys.stderr<br/>
錯誤輸出。<br/>
16) sys.exc_clear()<br/>
用來清除當前線程所出現的當前的或最近的錯誤信息。<br/>
17) sys.exec_prefix<br/>
返回平臺獨立的python文件安裝的位置。<br/>
18) sys.byteorder<br/>
本地字節規則的指示器，big-endian平臺的值是'big',little-endian平臺的值是'little'。<br/>
19) sys.copyright<br/>
記錄python版權相關的東西。<br/>
20) sys.api_version<br/>
解釋器的C的API版本。<br/>
21) sys.version_info<br/>
<code>&gt;&gt;&gt; sys.version_info(major=2, minor=7, micro=5, releaselevel='final', serial=0)</code><br/>
22) sys.displayhook(value)<br/>
如果value非空，這個函數會把他輸出到sys.stdout，並且將他保存進__builtin__._.指在python的交互式解釋器裏，'_&lsquo;代表上次你輸入得到的結果，hook是鉤子的意思，將上次的結果鉤過來。<br/>
23) sys.getdefaultencoding()<br/>
返回當前你所用的默認的字符編碼格式。<br/>
24) sys.getfilesystemencoding()<br/>
返回將Unicode文件名轉換成系統文件名的編碼的名字。<br/>
25) sys.setdefaultencoding(name)<br/>
用來設置當前默認的字符編碼，如果name和任何一個可用的編碼都不匹配，拋出LookupError，這個函數只會被site模塊的sitecustomize使用，一旦別site模塊使用了，他會從sys模塊移除。<br/>
26) sys.builtin_module_names<br/>
Python解釋器導入的模塊列表。<br/>
27) sys.executable<br/>
Python解釋程序路徑。<br/>
28) sys.getwindowsversion()<br/>
獲取Windows的版本。<br/>
29) sys.stdin.readline()<br/>
從標準輸入讀一行。<br/>
30) sys.stdout.write(&ldquo;a&rdquo;)<br/>
屏幕輸出a。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Python 字符串]]></title>
    <link href="http://www.aprilzephyr.com/blog/03282014/python-string/"/>
    <updated>2014-03-28T01:15:00+08:00</updated>
    <id>http://www.aprilzephyr.com/blog/03282014/python-string</id>
    <content type="html"><![CDATA[<p><strong>1. 類型轉換</strong><br/>
1) Python是動態類型，是强類型的編程語言。<br/>
2) Python內建函數的實現類型轉換：</p>

<table><tbody>
<tr><td><em> 函數 </em></td><td><em> 描述 </em></td></tr>  
<tr><td>int(x [,base ]) </td><td>將x轉換為一個整數</td></tr>
<tr><td>long(x [,base ]) </td><td>將x轉換為一個長整數</td></tr>
<tr><td>float(x) </td><td>將x轉換為一個浮點數</td></tr>
<tr><td>complax(real [, img ]) </td><td>創建一個複數</td></tr>
<tr><td>str(x) </td><td>將對象x轉換為字符串</td></tr>
<tr><td>repr(x) </td><td>將對象x轉換為表達式字符串</td></tr>
<tr><td>eval(str) </td><td>計算在字符串中的有效python表達式，並返回一個對象</td></tr>
<tr><td>tuple(s) </td><td>將序列s轉換為一個元組</td></tr>
<tr><td>list(s) </td><td>將序列s轉換為一個列表</td></tr>
<tr><td>chr(x) </td><td>將一個整數轉換為一個字符</td></tr>
<tr><td>unichr(x) </td><td>將一個整數轉換為一個Unicode字符</td></tr>
<tr><td>ord(x) </td><td>將一個字符轉換為它的整數值</td></tr>
<tr><td>hex(x) </td><td>將一個整數轉換為一個十六進制字符串</td></tr>
<tr><td>oct(x) </td><td>將一個整數轉換為一個八進制字符串</td></tr>
</tbody>
</table>


<p> <!--more--></p>

<p><strong>2. 轉義字符</strong></p>

<table>
<tbody>
<tr><td><em>轉義字符</em></td><td><em>描述</em></td></tr>  
<tr><td>\\(在行尾)</td><td>續行符</td></tr>  
<tr><td>\\\ </td><td>反斜槓</td></tr>  
<tr><td>\\' </td><td>單引號</td></tr>  
<tr><td>\\" </td><td>雙引號</td></tr>  
<tr><td>\a</td><td>響鈴</td></tr>  
<tr><td>\b</td><td>退格(Backspace)</td></tr>  
<tr><td>\e</td><td>轉義</td></tr>  
<tr><td>\000</td><td>空</td></tr>  
<tr><td>\n</td><td>換行</td></tr>  
<tr><td>\v</td><td>縱向製表符</td></tr>  
<tr><td>\t</td><td>橫向製表符</td></tr>  
<tr><td>\r</td><td>回車</td></tr>  
<tr><td>\f</td><td>換頁</td></tr>  
<tr><td>\oyy</td><td>八進制數yy代表的字符，例如:\o12代表換行</td></tr>  
<tr><td>\xyy</td><td>十進制數yy代表的字符，例如:\x0a代表換行</td></tr>  
<tr><td>\uhhhh</td><td>Unicode 16位的十六進製值</td></tr>  
<tr><td>\uhhhhhhhh</td><td>Unicode 32位的十六進製值</td></tr>  
<tr><td>\other</td><td>其它的字符以普通格式輸出</td></tr>  
</tbody></table>


<p><strong>3. 格式化表達</strong></p>

<table><tbody>  
<tr><td><em>格式化表達</em></td><td><em>描述</em></td></tr>  
<tr><td>%s</td><td>字符串</td></tr>  
<tr><td>%r</td><td>repr輸出的字符串</td></tr>  
<tr><td>%d</td><td>十進制整數</td></tr>  
<tr><td>%i</td><td>整數</td></tr>  
<tr><td>%u</td><td>無符號整數</td></tr>  
<tr><td>%o</td><td>八進制</td></tr>  
<tr><td>%x</td><td>十六進制</td></tr>  
<tr><td>%X</td><td>十六進制(大寫)</td></tr>  
<tr><td>%e</td><td>指數</td></tr>  
<tr><td>%E</td><td>指數(大寫)</td></tr>  
<tr><td>%f</td><td>十進制浮點數</td></tr>  
<tr><td>%F</td><td>十進制浮點數(大寫)</td></tr>  
<tr><td>%g</td><td>浮點e或f</td></tr>  
<tr><td>%G</td><td>浮點E或F</td></tr>  
</tbody></table>


<p></p>

<p><strong>4. 索引和切片</strong><br/>
Python中的字符串是有序的字符集合，所以可以通過位置（索引）獲取對應的元素。和c語言中一樣，python的索引也是從0開始的，而且支持使用負索引的方法來獲取元素，一個負的索引可以看做是從字符串結尾處反向計數，-1就表示字符串的最後一個字符。當然也可以理解為負索引與字符串長度相加得到的正索引，即s[-n]等於s[-n+len(s)]。<br/>
``` python</p>

<blockquote><blockquote><blockquote><p>s = &ldquo;hello"<br/>
s[0]<br/>
&lsquo;1'<br/>
s = "hello"<br/>
s[0]<br/>
'h'<br/>
s[-1]<br/>
'o'<br/>
s[0:3]<br/>
'hel'<br/>
s[1:]<br/>
'ello'<br/>
s[:-1]<br/>
'hell&rsquo;
<code>  
其實分片的完整格式為s[start:end:side]，意思就是從start開始到end-1，每隔side個元素取一個元素，返回值為所有取到的元素組成的字符串，side默認值為1。  
side可以取負值，例如s[::-1]會返回”olleh”，實際效果就是對字符串進行了反轉。這裏需要註意的是，如果side為負值，兩個邊界也要進行反轉，s[4:1:-1]就是從4開始反向取到2得到的字符串，如果在sride為負的情況下還是第一個邊界大於第二個邊界那樣的使用的話將返回一個空的字符串。  
</code> python
s[::2]<br/>
&lsquo;hlo'<br/>
s[::-1]<br/>
'olleh'<br/>
s[4:1:-1]<br/>
'oll'<br/>
s[0:4:-1]<br/>
&rsquo;&lsquo;<br/>
```</p></blockquote></blockquote></blockquote>

<p><strong>5. 字符串方法</strong><br/>
<em>A 大小寫</em><br/>
S.upper() 全部大寫<br/>
S.lower() 全部小寫<br/>
S.swapcase() 大小寫互換<br/>
S.capitalize() 首字母大寫，其余都小寫<br/>
S.title() 每個單詞的首字母大寫，其余不變</p>

<p><em>B 對齊</em><br/>
S.ljust(width[, fill]) 獲取固定長度width，左對齊，多余位用fill填充，默認空格<br/>
S.rjust(width[, fill]) 右對齊<br/>
S.center(width[, fill]) 居中<br/>
S.zfill(width) 右對齊，左邊不足的位置用0補齊，相當於S.rjust(width,&ldquo;0&rdquo;)<br/>
如果width&lt;=len(S)，返回於原字符串相同的字符串。</p>

<p><em>C 查找替換</em><br/>
S.find(sub[, start[, end]]) 返回在範圍start到end(不含end)中第一個sub的索引。<br/>
S.rfind(sub[, start[, end]]) 從右邊開始查找，也就是返回在範圍start到end(不含end)中最後一個sub的索引。<br/>
S.index(sub[, start[, end]])功能與find()相同，不同之處在於find()未找到的時候會返回-1，而index()會拋出異常。<br/>
S.rindex(sub[, start[, end]])功能與rfind()相同，不同之處在於find()未找到的時候會返回-1，而index()會拋出異常。<br/>
S.count(sub[, start[, end]]) 返回在範圍start到end(不含end)中sub的個數。<br/>
start默認為0，end默認為len(S)。<br/>
S.replace(old, new[, count])將字符串中的old替換為new，count為替換的次數，未指定的話就是替換所有。<br/>
S.translate(table [,deletechars]) 刪除S中deletechars包含的字符，然後將剩下的字符用table定義的關系進行映射。table是string.maketrans()生成的。</p>

<p><em>D 去空白或指定字符</em><br/>
S.strip([chars]) 去除字符串S兩邊的chars,若chars未指定，則去除兩邊的空白，包括空格、\n、\f、\r、\t和\v。<br/>
S.lstrip([chars]) 去除左邊的chars，未指定同上。<br/>
S.rstrip([chars]) 去除右邊的chars，未指定同上。</p>

<p><em>E 分割和組合</em><br/>
S.split([sep [,maxsplit]]) 以sep為分隔符切割字符串S，不指定sep默認為默認為空白，maxsplit為最大分割次數，未指定則全部分割，返回列表。<br/>
S.rsplit([sep [,maxsplit]]) 只是和split反向相反，split從頭到尾，rsplit從尾到頭。<br/>
S.splitlines([keepends]) 按行分割字符串，若keepends指定並且為True，則保留換行符，反之不保留。<br/>
S.partiton(sep)以sep作為分隔符將S分割為兩個start和end部分，並返回(start,sep, end)這樣格式的元組，若sep沒有找到，則返回S和兩個空串組成的元組(S, &lsquo;&rsquo;, &lsquo;&rsquo;)。<br/>
S.rpartition(sep)從右邊開始，以sep作為分隔符將S分割為兩個start和end部分，並返回(start,sep, end)，若sep沒有找到，則返回兩個空串和S組成的元組(&lsquo;&rsquo;, &lsquo;&rsquo;, S)。<br/>
S.join(iterable) 將叠代器iterable的字符串連接在一起，並用分隔符S隔開，一般來說在連接列表的時候都使用空字符串或者空格作為分隔符，返回字符串。</p>

<p><em>F 判斷</em><br/>
S.startswith(prefix[, start[, end]])判斷字符串start到end(不含end)是否是以prefix開頭，默認start為0，end為len(S)，返回布爾值。<br/>
S.endswith(suffix[, start[, end]]) 判斷字符串start到end(不含end)是否是以suffix結尾，默認start為0，end為len(S)，返回布爾值。<br/>
S.isalnum() 是否全為字母或數字，返回布爾值。<br/>
S.isalpha() 是否全為字母，返回布爾值。<br/>
S.isdigit() 是否全為數字0-9，返回布爾值。<br/>
S.islower() 是否全是小寫。<br/>
S.isupper() 是否全是大寫。<br/>
S.isspace() 是否全是空白。<br/>
S.istitle() 是否符合title的格式——每個單詞的首字母大寫。<br/>
上述這些函數中，若S為空串，則均返回False。</p>

<p><em>G 編碼</em><br/>
S.decode([encoding[,errors]]) 將字符串S解碼為unicode，encoding為S原來的編碼方式。<br/>
S.encode([encoding[,errors]]) 將unicodeS編碼為python中的字符串，參數指定對應的編碼方式。<br/>
errors指定出錯時對應的操作，默認的strict會在編碼/解碼失敗的時候拋出異常，ignore則忽略。<br/>
關於編碼方式還是有很多的知識的，後續再做研究。</p>

<p><em>H 其他</em><br/>
S.format(*args, **kwargs)<br/>
format也是用來格式化字符串的，argv指定的變量可以在S中用{index}來替換，而kwargs則是對應的變量。如果後面的數據為字典，可以使用{&lt;index|var>[key]}來替換其對應的值。當然還可以指定對應的寬度、精度以及對其格式，{index:[fill][&lt;|>|^][width][.precision][typecode]}。<br/>
fill設置填充位，默認為空格；&lt;左對齊，>右對齊，^居中；寬度和類型見後面格式化表達式部分。註意這裏的精度專指說浮點型數據，整型是不能使用精度的，字符創設置了也沒啥作用。<br/>
``` python</p>

<blockquote><blockquote><blockquote><p>&ldquo;{0},{2},{1},{s}&rdquo;.format(1,2,3,s=&ldquo;four&rdquo;)<br/>
&lsquo;1,3,2,four'<br/>
&ldquo;{0:$&lt;3},{2:^5.2f},{1},{s:>10.6s}&rdquo;.format(1,2,3,s=&ldquo;four&rdquo;)<br/>
'1$$,3.00 ,2,      four'<br/>
&ldquo;{0:&lt;3},{2:^5d},{1},{s:>10s}&rdquo;.format(1,2,3,s=&ldquo;four&rdquo;)<br/>
'1  ,  3  ,2,      four'<br/>
&ldquo;{0:&lt;03},{2:^05.2d},{1},{s:>10s}&rdquo;.format(1,2,3,s=&ldquo;four&rdquo;)<br/>
Traceback (most recent call last):<br/>
  File &ldquo;<stdin>&rdquo;, line 1, in <module><br/>
ValueError: Precision not allowed in integer format specifier<br/>
&ldquo;{0:&lt;03},{2:^5.2f},{1},{s:>10.6s}&rdquo;.format(1,2,3,s=&ldquo;four&rdquo;)<br/>
'100,3.00 ,2,      four&rsquo;
```<br/>
S.expandtabs([tabsize]) 將字符串中的制表符替換為tabsize個空格，默認為8。</p></blockquote></blockquote></blockquote>

<p><em>I 3.0新增</em><br/>
S.isdecimal() 是否全是十進制數字(多語言數字)。<br/>
S.isidentifier() 是否全是合法標識符。<br/>
S.isnumeric() 是否只包含數字字符。<br/>
S.isprintable() 是否全是可打印字符。</p>
]]></content>
  </entry>
  
</feed>
